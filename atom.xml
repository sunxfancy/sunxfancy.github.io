<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[西风广场]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://sunxfancy.github.io/"/>
  <updated>2015-11-13T07:23:51.447Z</updated>
  <id>http://sunxfancy.github.io/</id>
  
  <author>
    <name><![CDATA[西风逍遥游]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[C和C++的面向对象专题（8）——更为高级的预处理器PHP]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E6%9B%B4%E4%B8%BA%E9%AB%98%E7%BA%A7%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8PHP/"/>
    <id>http://sunxfancy.github.io/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（8）——更为高级的预处理器PHP/</id>
    <published>2016-03-28T15:45:02.491Z</published>
    <updated>2015-11-13T07:23:51.447Z</updated>
    <content type="html"><![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="八、更为高级的预处理器PHP"><a href="#八、更为高级的预处理器PHP" class="headerlink" title="八、更为高级的预处理器PHP"></a>八、更为高级的预处理器PHP</h2><p>C++的宏在某些情况下非常难用，例如将代码展开成为这样：</p>
<p>Macro( A, B, C, D )</p>
<p>=&gt;</p>
<p>func(“A”, A);<br>func(“B”, B);<br>func(“C”, C);<br>func(“D”, D);</p>
<p>test(A);<br>test(B);<br>test(C);<br>test(D);</p>
<p>这对于宏来说，太困难了，为了能实现复杂的宏展开，我们希望用更高级的预处理器来实现该功能。</p>
<p>我们这里使用PHP进行代码的预处理工作，将PHP代码当做C++的宏使用。<br>当然，你也可以用python做代码生成工作，但由于php是内嵌式的，处理起来可能更方便一些，当然，其他语言配上模板也是可以的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.php */</span></span><br><span class="line">&lt;?php $return_m = <span class="string">"return a + b;"</span> ?&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">true&lt;?php echo $return_m; ?&gt; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="built_in">cout</span> &lt;&lt; func(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">true<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用如下指令生成C++代码：</p>
<pre><code>php main.php &gt; main.cpp
</code></pre><p>好的，下面就和正常的项目编译一样了，你甚至可以将php的命令写入到makefile中，自动化生成</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C和C++的面向对象专题（9）——Gtkmm的最佳实践]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94Gtkmm%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://sunxfancy.github.io/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（9）——Gtkmm的最佳实践/</id>
    <published>2016-03-28T15:45:02.490Z</published>
    <updated>2015-11-13T07:23:49.274Z</updated>
    <content type="html"><![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="九、Gtkmm的最佳实践"><a href="#九、Gtkmm的最佳实践" class="headerlink" title="九、Gtkmm的最佳实践"></a>九、Gtkmm的最佳实践</h2><p>在跨平台的gui开发中，Qt一直是非常受欢迎的GUI开发框架，但Qt一个是依赖反射，需要特殊的预处理步骤，一个是库太过庞大，这就造成了一些不便的地方。今天介绍给大家的是Gtk库的C++绑定，Gtkmm，一个方便的跨平台GUI开发框架。</p>
<p>由于是C++的封装，GTK不再那么的难以使用，变得简洁优雅，而且效率非常高，编译也较QT快许多。<br>虽然C也能编写，而且我们之前也介绍过了GObject的使用。但比较其实现起来较为繁琐，代码行数较C++多一些，而且每个成员函数都要手动传入this指针，较为不便。</p>
<p>现在C++如果合理的封装和按照之前的设计思想进行设计，结构十分紧凑，而且书写非常方便，非常易用。</p>
<h3 id="Gtkmm版的2048程序设计"><a href="#Gtkmm版的2048程序设计" class="headerlink" title="Gtkmm版的2048程序设计"></a>Gtkmm版的2048程序设计</h3><p>为了更好的实践，我们举一个简单的2048小游戏的程序作为实例。大家会发现，合理的设计，能够使代码既清晰明了，又方便维护，可靠性很高。<br>我们简要的进行一下程序设计，这里我们不是要学会2048如何制作，而是要体会程序设计中的思想，以及设计中的美感和艺术感。</p>
<p>首先，2048作为一个简单的小游戏，广受大家喜欢，原理很简单，在一个4×4的数组中，让数字不断向各个方向合并，每次进行后，随机位置创建新数字。</p>
<p>程序界面，一个窗口，上面一行标签书写当前得分，下面一个绘图界面，自由绘图，画上4×4个的矩阵，上面书写内容。</p>
<p>程序结构设计，按照一般程序架构设计，可以用MVC的结构，一个界面类，负责显示，一个控制类，负责游戏逻辑，一个模型类，负责数据的存储与管理。</p>
<p>但由于数据的管理太过简单，就放弃了模型类，直接使用一个4×4的矩阵就完成任务。</p>
<h3 id="程序实践"><a href="#程序实践" class="headerlink" title="程序实践"></a>程序实践</h3><p>由于Gtkmm的良好封装，我们并不需要太多复杂的处理，首先是Main文件引导程序的启动，所有gtk程序集合都是这样引导。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">* @Author: sxf</span><br><span class="line">* @Date:   2015-05-07 12:22:40</span><br><span class="line">* @Last Modified by:   sxf</span><br><span class="line">* @Last Modified time: 2015-05-20 21:58:16</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtkmm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"game.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">trueGlib::RefPtr&lt;Gtk::Application&gt; app = Gtk::Application::create(argc, argv, <span class="string">"org.abs.gtk2048"</span>);</span><br><span class="line"></span><br><span class="line">trueGame game;</span><br><span class="line">true<span class="comment">//Shows the window and returns when it is closed.</span></span><br><span class="line">true<span class="keyword">return</span> app-&gt;run(game);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Game类作为最核心的窗口类，也是游戏的主要控制类，并不需要暴露什么方法给外部成员使用，所以它的定义很简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">* @Author: sxf</span><br><span class="line">* @Date:   2015-05-19 11:20:42</span><br><span class="line">* @Last Modified by:   sxf</span><br><span class="line">* @Last Modified time: 2015-05-20 21:58:35</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtkmm/window.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Game_private;</span><br><span class="line"><span class="keyword">class</span> Game : <span class="keyword">public</span> Gtk::Window</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">trueGame();</span><br><span class="line">true<span class="keyword">virtual</span> ~Game();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">trueGame_private* priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GAME_H</span></span></span><br></pre></td></tr></table></figure></p>
<p>这种写法，就是在前几章提到的增强代码封装性的方法，通过一个priv指针，解决了C++封装不完善的问题。</p>
<p>这样还有一个很大的好处就是，由于priv指针的书写较为繁琐，如果在public方法中，反复的通过priv指针调用函数，就会显得无比麻烦，但这正提醒你，你的写法有问题，因为一般的方法，要尽可能写成内部的private的，这样你在不自觉的时刻，就形成了最大化private方法，最小化接口的设计习惯，这对于提升程序的内聚性，很有意义。</p>
<p>于是我们的Game类的内部定义就变得十分复杂，但这就使得代码内聚性更高，暴露给外层的接口就更简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Game_private</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">trueGame_private(Game* game);</span><br><span class="line">true~Game_private();</span><br><span class="line">true</span><br><span class="line"> 	Game* game;</span><br><span class="line">trueMyArea m_area;		// 渲染类</span><br><span class="line">trueGtk::Box m_box;		// 布局控件</span><br><span class="line">trueGtk::Label m_score;	// 得分标签</span><br><span class="line">trueint score;			// 得分具体数字</span><br><span class="line">trueconst static int fx[4][2];</span><br><span class="line"></span><br><span class="line">trueint data[4][4];		// 数据模型</span><br><span class="line"></span><br><span class="line">truebool combine(int i, int j, int k); 	// 将一个位置的数字向下合并</span><br><span class="line"></span><br><span class="line">truebool randomNew();	// 随机创建新数字</span><br><span class="line"></span><br><span class="line">truevoid cleanData();	// 删除全部数字，用来开局初始化</span><br><span class="line"></span><br><span class="line">truevoid gameWin();		// 显示用户胜利</span><br><span class="line"></span><br><span class="line">truevoid gameOver();	// 显示游戏结束</span><br><span class="line"></span><br><span class="line">truevoid gameRun(int k);	// 游戏控制循环</span><br><span class="line"></span><br><span class="line">truebool on_key_press_event(GdkEventKey* event); // 监听键盘事件响应</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我不喜欢比脸还长的函数，但这里的函数设计的还是不是那么尽如人意，虽然如此，这里也是本着简单易懂的方式设计的。</p>
<p>这里的combine方法设计的很特殊，因为合并时，还有可能出现游戏胜利的情况，所以里面包含了判断胜利的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool combine(int i, int j, int k) &#123;</span><br><span class="line">trueint ni = i; int nj = j;</span><br><span class="line">trueni += fx[k][0];	// fx是方向数组</span><br><span class="line">truenj += fx[k][1];</span><br><span class="line">trueint obji = i, objj = j;</span><br><span class="line">truewhile ( 0 &lt;= ni &amp;&amp; ni &lt; 4 &amp;&amp;</span><br><span class="line">truetruetrue0 &lt;= nj &amp;&amp; nj &lt; 4 )		</span><br><span class="line">true// 防止越界，我这里比较贪便宜，很多人处理越界是通过在数组外增加一个特殊值的外边框来处理的</span><br><span class="line">true&#123;</span><br><span class="line">truetrueif (data[ni][nj] == 0) &#123;</span><br><span class="line">truetruetrueobji = ni; objj = nj;</span><br><span class="line">truetrue&#125; else &#123;</span><br><span class="line">truetruetrueif (data[ni][nj] == data[i][j]) &#123;</span><br><span class="line">truetruetruetruescore += (1 &lt;&lt; data[ni][nj]);	// 处理得分</span><br><span class="line">truetruetruetrue++data[ni][nj];</span><br><span class="line">truetruetruetruedata[i][j] = 0;</span><br><span class="line">truetruetruetrueif (data[ni][nj] == 12) return true; // 处理胜利条件</span><br><span class="line">truetruetruetruereturn false;</span><br><span class="line">truetruetrue&#125; else break;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrueni += fx[k][0];</span><br><span class="line">truetruenj += fx[k][1];</span><br><span class="line">true&#125;</span><br><span class="line">trueif (!(obji == i &amp;&amp; objj == j)) &#123;	// 未能合并的情况</span><br><span class="line">truetruedata[obji][objj] = data[i][j];</span><br><span class="line">truetruedata[i][j] = 0;</span><br><span class="line">true&#125;</span><br><span class="line">truereturn false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数设计的很健壮，考虑了许多边界条件，这么做是在模拟物体碰撞时，碰撞面不断挤压的情况。例如下面的情况：<br>1 1 2 4<br>0 0 0 0<br>0 0 0 0<br>0 0 0 0<br>向左合并，能够一次就被合成为8，但这也是和外层的合并顺序控制是分不开的<br>在游戏主循环控制时，是这样处理的，对于不同的方向，循环顺序是不一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void gameRun(int k) &#123;</span><br><span class="line">truetruebool winflag = false;</span><br><span class="line">truetrueswitch (k) &#123;</span><br><span class="line">truetruetruecase 0 : </span><br><span class="line">truetruetruetruefor (int i = 0; i &lt; 4; ++i)</span><br><span class="line">truetruetruetruetruefor (int j = 0; j &lt; 4; ++j)</span><br><span class="line">truetruetruetruetruetrueif (combine(i,j,k)) winflag = true;</span><br><span class="line">truetruetruebreak;</span><br><span class="line">truetruetruecase 1 : </span><br><span class="line">truetruetruetruefor (int j = 3; j &gt;= 0; --j)</span><br><span class="line">truetruetruetruetruefor (int i = 0; i &lt; 4; ++i)</span><br><span class="line">truetruetruetruetruetrueif (combine(i,j,k)) winflag = true;</span><br><span class="line">truetruetruebreak;</span><br><span class="line">truetruetruecase 2 : </span><br><span class="line">truetruetruetruefor (int i = 3; i &gt;= 0; --i)</span><br><span class="line">truetruetruetruetruefor (int j = 0; j &lt; 4; ++j)</span><br><span class="line">truetruetruetruetruetrueif (combine(i,j,k)) winflag = true;</span><br><span class="line">truetruetruebreak;</span><br><span class="line">truetruetruecase 3 : </span><br><span class="line">truetruetruetruefor (int j = 0; j &lt; 4; ++j)</span><br><span class="line">truetruetruetruetruefor (int i = 0; i &lt; 4; ++i)</span><br><span class="line">truetruetruetruetruetrueif (combine(i,j,k)) winflag = true;</span><br><span class="line">truetruetruebreak;</span><br><span class="line">truetrue&#125;</span><br><span class="line"></span><br><span class="line">truetrue// 判断胜负条件</span><br><span class="line">truetrueif (winflag) &#123;</span><br><span class="line">truetruetruegameWin();</span><br><span class="line">truetruetruereturn;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrueif (!randomNew()) &#123;</span><br><span class="line">truetruetruegameOver();</span><br><span class="line">truetrue&#125;</span><br><span class="line"></span><br><span class="line">truetrueGlib::RefPtr&lt;Gdk::Window&gt; win = game-&gt;get_window();</span><br><span class="line">truetrueif (win)</span><br><span class="line">truetrue&#123;</span><br><span class="line">truetruetruem_area.setData(data);</span><br><span class="line">truetrue    Gdk::Rectangle r(0, 0, 600, 600);</span><br><span class="line">truetrue    win-&gt;invalidate_rect(r, false);</span><br><span class="line">truetruetruem_area.show();</span><br><span class="line">truetruetruechar score_text[20]; memset(score_text, 0, 20);</span><br><span class="line">truetruetruesprintf(score_text, &quot;Score : %d&quot;, score);</span><br><span class="line">truetruetruem_score.set_text(score_text);</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br></pre></td></tr></table></figure></p>
<p>而创建新数字的方式也很清晰，但这里使用模拟栈的方式进行了处理。<br>设计很独特，由于目前的位置数目有限，直接rand的方式，效率较低，我们先扫描所有可能的位置，然后将其入栈，random时，直接找一个位置，然后直接随机从其中找一个就可以了。数组模拟栈的方式，主要是希望避免vector的低效率，实现较简易。而且扩展较方便，如果你想random跟多，修改起来也十分方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool randomNew() &#123;</span><br><span class="line">trueint empty_block[17][2]; int sum = 0;</span><br><span class="line">truefor (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">truetruefor (int j = 0; j &lt; 4; ++j) &#123;</span><br><span class="line">truetruetrueif (data[i][j] == 0) &#123;</span><br><span class="line">truetruetruetrueempty_block[sum][0] = i; </span><br><span class="line">truetruetruetrueempty_block[sum][1] = j;</span><br><span class="line">truetruetruetrue++sum;</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">trueif (sum &lt; 1) return false;</span><br><span class="line"></span><br><span class="line">trueint t = rand() % sum;</span><br><span class="line">truedata[ empty_block[t][0] ][ empty_block[t][1] ] = (rand() % 4) &lt; 3 ? 1 : 2;</span><br><span class="line">trueempty_block[t][0] = empty_block[sum-1][0];</span><br><span class="line">trueempty_block[t][1] = empty_block[sum-1][1]; </span><br><span class="line">true--sum;</span><br><span class="line">true</span><br><span class="line">truereturn true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染类十分简单，主要就是根据数组中的数值，渲染出对应的图像，设计思想就是不断将问题抽象，不断简化，将复杂的问题从上层一层层拨开，这样就使得结构更加简洁优雅。</p>
<p>整个项目完整代码已经放到Github上了，需要的可以参考：<br><a href="https://github.com/sunxfancy/Gtk2048" target="_blank" rel="external">【github仓库】</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C和C++的面向对象专题（1）——何为面向对象]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E4%BD%95%E4%B8%BA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://sunxfancy.github.io/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（1）——何为面向对象/</id>
    <published>2016-03-28T15:45:02.489Z</published>
    <updated>2015-11-13T07:23:30.885Z</updated>
    <content type="html"><![CDATA[<p>面向对象是一种思想，而不是一门语言<br>我们上哪去找对象，都面向对象去了</p>
<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="一、何为面向对象"><a href="#一、何为面向对象" class="headerlink" title="一、何为面向对象"></a>一、何为面向对象</h2><p>现在学软件开发，都讲面向对象的编程模型，其实也很简单。用一句话来总结，面向对象就是将方法和方法的属性整合在一起，让每个方法引用的属性值尽可能在对象内部，对外保持简洁的接口。</p>
<p>实现面向对象的设计，目标不是写类，而是设计结构，对每一个对象设计良好的接口和封装模式，将优雅的接口提供给使用者，最大程度的降低代码耦合。</p>
<p>面向对象的设计，可以用一本书来讲解，但我们这里将演示面向对象的基本思想和如何实现</p>
<h3 id="从一个简单的例子看对象"><a href="#从一个简单的例子看对象" class="headerlink" title="从一个简单的例子看对象"></a>从一个简单的例子看对象</h3><p>恩，那好，我们现在构建一个对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">truewindow(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height) &#123;</span><br><span class="line">truetrue<span class="keyword">this</span>.x = x; <span class="keyword">this</span>.y = y;</span><br><span class="line">truetrue<span class="keyword">this</span>.width = width;</span><br><span class="line">truetrue<span class="keyword">this</span>.height = height;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">true<span class="keyword">int</span> x, y, width, height;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 也许你还可以添加更多属性，例如透明度、子元素列表、菜单、状态栏等待</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一个基本的窗口对象，也许它并不能给你直观的印象，但我希望能通过其说明一些问题。<br>对象有公开方法，有私有属性，我们在构造这个对象的时候，将一些参数传入，那么我们发现，这个过程简化了我们对于某些方法的使用。</p>
<p>例如在C函数中，如何你希望绘制一些内容，那么你可能需要做的是写这样一个函数：</p>
<pre><code>int Draw(struct window*, int, int, int, int);
</code></pre><p>将全部的参数传入进去，但如果使用次数多后，我们发现参数大多一样，那么不如把他们都打包进入window结构体中，于是函数变成了这样：</p>
<pre><code>int Draw(struct window*);
</code></pre><p>这样我们只需要改变结构体中的值就可以了，这个思想，就是面向对象的基础，而C++正是让这要传入的结构体自动传入，进而演变为了this指针。</p>
<h3 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h3><p>几乎软件的设计原则都是高内聚，低耦合。</p>
<p>C++的设计也是一样，类的公共方法应该尽可能清晰明确，简单好用，而不必要外部了解的信息，和细节过程，都放入到私有成员中，避免被误用。</p>
<p>避免过度继承和重载，虽然继承和重载很大程度上能够降低两个模块间的耦合，但其实现复杂，结构混乱，容易使得代码不够清晰。同样，也要避免设计模式的滥用。</p>
<p>C++的开发应该本着面向对象的思想，利用类的封装特性，将模块内部的部分高效的组织在一起，而接口，可以采用多态调用的方式，保证灵活性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>面向对象是一种思想，而不是一门语言<br>我们上哪去找对象，都面向对象去了</p>
<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C和C++的面向对象专题（2）——C语言也能实现面向对象]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94C%E8%AF%AD%E8%A8%80%E4%B9%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://sunxfancy.github.io/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（2）——C语言也能实现面向对象/</id>
    <published>2016-03-28T15:45:02.488Z</published>
    <updated>2015-11-13T07:24:03.883Z</updated>
    <content type="html"><![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="二、C语言也能实现面向对象"><a href="#二、C语言也能实现面向对象" class="headerlink" title="二、C语言也能实现面向对象"></a>二、C语言也能实现面向对象</h2><p>今天要为大家介绍C语言的面向对象设计方法，正如题记上面所说，面向对象是一种思想，而并非是一种语言，我们将会介绍C语言实现的面向对象开发方式。</p>
<h3 id="简单实用的C语言面向对象设计思路"><a href="#简单实用的C语言面向对象设计思路" class="headerlink" title="简单实用的C语言面向对象设计思路"></a>简单实用的C语言面向对象设计思路</h3><p>众所周知，C++中的面向对象十分方便，但在C中，并没有类，但我们可以通过C的结构体来实现，然后，手动将this指针传入<br>目前这个方法，应该是C语言设计中，简便易用的方式，而且能较好的体现面向对象的设计思路，然而遗憾的是，没有继承和多态。</p>
<p>例如，我们这样一个C++类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> test &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">truetest(<span class="keyword">char</span>* str, <span class="keyword">int</span> k) &#123;</span><br><span class="line">truetrue<span class="keyword">this</span>-&gt;str = str;</span><br><span class="line">truetrue<span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">ShowMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">truetruetrue<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);	</span><br><span class="line">true&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">true<span class="keyword">int</span> k;</span><br><span class="line">true<span class="keyword">char</span>* str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么我们可以这样转换为一个C类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test.h */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _test &#123;</span><br><span class="line">true<span class="keyword">int</span> k;</span><br><span class="line">true<span class="keyword">char</span>* str;</span><br><span class="line">&#125; test;</span><br><span class="line"></span><br><span class="line"><span class="function">test* <span class="title">TestCreate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowMessage</span><span class="params">(test*)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test.c */</span></span><br><span class="line"></span><br><span class="line"><span class="function">test* <span class="title">TestCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="keyword">return</span> (test*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowMessage</span><span class="params">(test* t)</span> </span>&#123;</span><br><span class="line">true<span class="keyword">int</span> i;</span><br><span class="line">true<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; t-&gt;k; ++i) &#123;</span><br><span class="line">truetrue<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, t-&gt;str);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实思路也很清晰，思路简单易懂，实现也很清新明快，在各类C工程中使用极为广泛。</p>
<h3 id="复杂的基于GObject的面向对象程序设计"><a href="#复杂的基于GObject的面向对象程序设计" class="headerlink" title="复杂的基于GObject的面向对象程序设计"></a>复杂的基于GObject的面向对象程序设计</h3><p>如果你希望学习C语言的GUI程序设计，那么，必定要学习的就是GObject的类实现方式。<br>GObject相当于从C层面上模拟了一个C++的类对象模型，实现当然相对复杂的多。</p>
<p>下面我们来实际看一下一个GTK的窗口类，这是GTK+-3.0的一段样例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* appwin.h */</span><br><span class="line">#ifndef APPWIN_H</span><br><span class="line">#define APPWIN_H</span><br><span class="line"></span><br><span class="line">#include &quot;app.h&quot;</span><br><span class="line">#include &lt;gtk/gtk.h&gt;</span><br><span class="line"></span><br><span class="line">/* 该类的类型定义以及类型转换宏 */</span><br><span class="line">#define APP_WINDOW_TYPE (app_window_get_type())</span><br><span class="line">#define APP_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), APP_WINDOW_TYPE, AppWindow))</span><br><span class="line"></span><br><span class="line">/* 该类分成两部分，一部分是成员，一部分是类本身 */</span><br><span class="line">typedef struct _AppWindow      AppWindow;</span><br><span class="line">typedef struct _AppWindowClass AppWindowClass;</span><br><span class="line"></span><br><span class="line">GType      app_window_get_type (void);</span><br><span class="line">AppWindow* app_window_new      (App *app);</span><br><span class="line">void       app_window_open     (AppWindow *win, GFile *file);</span><br><span class="line"></span><br><span class="line">#endif // APPWIN_H</span><br></pre></td></tr></table></figure>
<p>而其真实的定义是在.c文件中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _AppWindow</span><br><span class="line">&#123;</span><br><span class="line">trueGtkApplicationWindow parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _AppWindowClass</span><br><span class="line">&#123;</span><br><span class="line">trueGtkApplicationWindowClass parent_class;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _AppWindowPrivate AppWindowPrivate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _AppWindowPrivate</span><br><span class="line">&#123;</span><br><span class="line">trueGSettings *settings;</span><br><span class="line">trueGtkWidget *<span class="built_in">stack</span>;</span><br><span class="line">trueGtkWidget *search;</span><br><span class="line">trueGtkWidget *searchbar;</span><br><span class="line">trueGtkWidget *searchentry;</span><br><span class="line">trueGtkWidget *gears;</span><br><span class="line">trueGtkWidget *sidebar;</span><br><span class="line">trueGtkWidget *words;</span><br><span class="line">trueGtkWidget *lines;</span><br><span class="line">trueGtkWidget *lines_label;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">G_DEFINE_TYPE_WITH_PRIVATE(AppWindow, app_window, GTK_TYPE_APPLICATION_WINDOW);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后面有具体的实现方法，这里就不一一列举 */</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现，这种定义方式比C++中的其实更有优势，封装的更加彻底。为何这样说呢？首先，我们的声明文件十分的简洁，如果公开方法不修改的话，那么将其余内容如何改动，都不会影响我们的外部接口。</p>
<p>其次，由于需要显示的向GObject注册，那么动态进行类注册就成为可能，这样的设计优势表现在哪里呢？多语言的互通性就很好了，因为很多动态语言，是支持类的动态加载以及反射加载的。</p>
<p>另外，vala语言就是基于GObject类型的，他是一门新兴的编译时语言，但其也有很多动态语言的特性，用其开发gtk程序，比C具有明显的优势。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C和C++的面向对象专题（3）——C++中的不优雅特性]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94C++%E4%B8%AD%E7%9A%84%E4%B8%8D%E4%BC%98%E9%9B%85%E7%89%B9%E6%80%A7/"/>
    <id>http://sunxfancy.github.io/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（3）——C++中的不优雅特性/</id>
    <published>2016-03-28T15:45:02.487Z</published>
    <updated>2015-11-13T07:24:01.693Z</updated>
    <content type="html"><![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="三、C-中的不优雅特性"><a href="#三、C-中的不优雅特性" class="headerlink" title="三、C++中的不优雅特性"></a>三、C++中的不优雅特性</h2><p>今天来说一说C++中不优雅的一些问题，C++虽然是面向对象的设计语言，但也有很多缺陷和弊病，我们将会讨论如何通过良好的设计解决这些问题。</p>
<h3 id="C-编译缓慢"><a href="#C-编译缓慢" class="headerlink" title="C++编译缓慢"></a>C++编译缓慢</h3><p>C++编译慢已经成为了业界共识，一个大型C++项目甚至要用专用的服务器编译好久才能完成，Java和.net作为大型开发平台， 却也没发现编译如此缓慢的问题，那么究竟是什么，导致了C++编译难的问题呢？</p>
<h3 id="模板的纠结"><a href="#模板的纠结" class="headerlink" title="模板的纠结"></a>模板的纠结</h3><p>C++中模板有个很神奇的问题，就是实现和声明都必须被使用者引用，这段模板代码才有效，也就是说，模板是在编译时展开的代码生成机制。</p>
<p>我们不妨做个实验，这是类的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class CObject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">trueCObject(T k) &#123;obj = k;&#125;</span><br><span class="line">true~CObject() &#123;&#125;</span><br><span class="line">trueT getObj();</span><br><span class="line">private:</span><br><span class="line">trueT obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面是类的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;CObject.h&quot;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T CObject&lt;T&gt;::getObj()&#123;</span><br><span class="line">truereturn this-&gt;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主函数中调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;CObject.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">trueCObject&lt;int&gt; Obj(10);</span><br><span class="line">trueint k = Obj.getObj();</span><br><span class="line">trueprintf(&quot;%d\n&quot;, k);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一切看起来是那么的顺利，但是！我的电脑给我显示如下错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scanning dependencies of target template_test</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/template_test.dir/src/CObject.cpp.o</span><br><span class="line">[100%] Building CXX object CMakeFiles/template_test.dir/src/main.cpp.o</span><br><span class="line">Linking CXX executable template_test</span><br><span class="line">CMakeFiles/template_test.dir/src/main.cpp.o：在函数‘main’中：</span><br><span class="line">main.cpp:(.text+0x22)：对‘CObject&lt;int&gt;::getObj()’未定义的引用</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make[2]: *** [template_test] 错误 1</span><br><span class="line">make[1]: *** [CMakeFiles/template_test.dir/all] 错误 2</span><br><span class="line">make: *** [all] 错误 2</span><br></pre></td></tr></table></figure></p>
<p>链接器告诉我，我们找不到一个叫做‘CObject<int>::getObj()’的函数，恩？为何，我们不是将类实现链接进来了么？</int></p>
<p>如果你这样想就错了，上网查找解决方案，得到的回复居然是这样：<br><code>#include &quot;CObject.h&quot;</code> =&gt; <code>#include &quot;CObject.cpp&quot;</code></p>
<p>omg，那我还不如把两个文件写成一个hpp来的方便呢，其实C++也是推荐你这样做的，理由就是——模板是编译时，在用到的时候进行代码展开得到的<br>如果不这样做，链接器是不会找到对应的代码的。</p>
<p>那么也找到了很多大型工程如boost库，为何编译缓慢的直接原因，大量的模板展开消耗了巨大的资源，而且模板展开是很不利于代码复用的，同样的算法，换一种类型，必须全部编译，生成新的代码，并且这类模板生成的代码，不能提前编译成二进制库，这样的结果就是，项目哪里改动一点，好多文件重复编译，造成编译十分缓慢。</p>
<h3 id="封装的问题"><a href="#封装的问题" class="headerlink" title="封装的问题"></a>封装的问题</h3><p>C++的类并没有很好的将代码封起来，这和上次讲到的GObject对比可以发现，C++的私有变量是一同放置在类的声明中，而我们知道，一个类的声明，是会被很多其他类引用的。<br>那么，思考我们的C++编译过程，很多类都引用了一个.h文件，那么这个.h文件一旦发生更改，那么所有引用这个文件的cpp文件都将被触发重复编译，而我们在实现一个类时，对类的成员函数小修小补是很平常的，但由于封装的不彻底，那么我们的项目又将被反复编译，带来编译的速度缓慢。</p>
<p>而且，如果是库的话，那么私有成员的更新甚至还会影响用户使用，非常麻烦。<br>例如下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">public:</span><br><span class="line">trueTest();</span><br><span class="line">true~Test();</span><br><span class="line"></span><br><span class="line">truevoid Show();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">truestd::string message;</span><br><span class="line">trueint pointer;</span><br><span class="line">truevoid formatMessage(std::string&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>很明显，一般的C++类，私有成员都会比公开成员多，那么私有成员修改一点，哪怕只是一不小心多了个空格，都会带来这个文件的更新，触发makefile的重编译，带来了低效率。</p>
<h3 id="缺乏反射机制"><a href="#缺乏反射机制" class="headerlink" title="缺乏反射机制"></a>缺乏反射机制</h3><p>最新的C++11，引入了众多的新特性，包括好用的auto关键字以及模板元编程特性等，但这些，还是不能弥补反射机制缺失带来的影响。反射是对象串行化、GUI界面事件响应和根据数据动态调用代码等技术的核心，缺乏反射机制，会使得C++很多地方十分的不便。</p>
<p>很多大型软件，如firefox，在实现中，往往搭建了反射框架，供系统使用。但由于C++本身语法的问题，缺乏反射依旧会使得类书写变得困难。</p>
<h3 id="跨平台困难"><a href="#跨平台困难" class="headerlink" title="跨平台困难"></a>跨平台困难</h3><p>C++的跨平台性真的不好，甚至很多编译器上都会出现匪夷所思的问题，例如在不同平台上，基本类型的大小会随CPU字长而变化，如果有跨平台需求的软件，最好使用跨平台定义的类型。<br>C++的结构体中数据往往有内存对齐的问题，有些编译器还能通过编译器指令对其设置，这些问题最好还是能避开就避开。</p>
<p>跨平台时，还应小心异常处理的代码，因为有些版本的C++编译器对抛出的异常规格并不很遵守规范。<br>另外，不同平台的宽字符集也是大问题，往往并不能轻松统一，另外MinGW里貌似就没有宽字符- -</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C和C++的面向对象专题（4）——解决封装，避免接口]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E5%B0%81%E8%A3%85%EF%BC%8C%E9%81%BF%E5%85%8D%E6%8E%A5%E5%8F%A3/"/>
    <id>http://sunxfancy.github.io/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（4）——解决封装，避免接口/</id>
    <published>2016-03-28T15:45:02.486Z</published>
    <updated>2015-11-13T07:23:59.567Z</updated>
    <content type="html"><![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="四、解决封装，避免接口"><a href="#四、解决封装，避免接口" class="headerlink" title="四、解决封装，避免接口"></a>四、解决封装，避免接口</h2><p>恩，今天我们来讨论，如何通过设计，解决C++中的不优雅特性，改进项目的结构，改善编译速度。</p>
<p>上次我们提到，如果一个类的封装不好，容易导致种种不便，那么如何设计能够避免这种现象呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">public:</span><br><span class="line">truevoid print() &#123;</span><br><span class="line">truetrueprintf(&quot;Hello\n&quot;);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truevoid print2() &#123;</span><br><span class="line">truetrueprintf(&quot;K : %d\n&quot;, k);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">trueint k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="简要的改进，将函数的实现移动到类cpp实现文件中"><a href="#简要的改进，将函数的实现移动到类cpp实现文件中" class="headerlink" title="简要的改进，将函数的实现移动到类cpp实现文件中"></a>简要的改进，将函数的实现移动到类cpp实现文件中</h3><p>最简单的想法就是将实现和声明分开，这也是C++提倡的，这样虽然文件会增多，但编译速度和代码的清晰度会提升。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* test.h */</span><br><span class="line">class test &#123;</span><br><span class="line">public:</span><br><span class="line">truevoid print();</span><br><span class="line">truevoid print2();</span><br><span class="line">private:</span><br><span class="line">trueint k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* test.cpp */</span><br><span class="line">#include &quot;test.h&quot;</span><br><span class="line">void test::print() &#123;</span><br><span class="line">trueprintf(&quot;Hello\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test::print2() &#123;</span><br><span class="line">trueprintf(&quot;K : %d\n&quot;, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显的，这样我们改动cpp文件中，.h文件不会受到影响，但假若我的private方法增加了，那么还是需要改动.h文件，进而会影响所有引用我的部分，为了避免这种情况出现，有什么好设计方法么？</p>
<h3 id="使用接口降低代码耦合"><a href="#使用接口降低代码耦合" class="headerlink" title="使用接口降低代码耦合"></a>使用接口降低代码耦合</h3><p>一种标准的设计模式是使用接口，这在很多库的设计时也被经常采用，核心思想是通过多态调用的方式，避免内部方法的暴露。</p>
<p>接口一般就是C++的多态类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* Itest.h */</span><br><span class="line">class Itest &#123;</span><br><span class="line">public:</span><br><span class="line">truevirtual void print() = 0;</span><br><span class="line">truevirtual void print2() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern ITest* createItest(); // 类似工厂的方式为你构建类</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Itest.cpp */</span><br><span class="line">#include &quot;test.h&quot;</span><br><span class="line"></span><br><span class="line">ITest* createItest() &#123;</span><br><span class="line">truereturn new test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让test从这个接口继承出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* test.h */</span><br><span class="line">class test : public Itest &#123;</span><br><span class="line">public:</span><br><span class="line">truevirtual void print();</span><br><span class="line">truevirtual void print2();</span><br><span class="line">private:</span><br><span class="line">trueint k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样的好处当然十分明显了，将类转成接口的形式，就能方便的修改下面的实现类，无论实现类如何改动，都在模块范围内，接口不变。<br>但这样做的坏处也很明显，如果C++大量使用这样的方式实现内部封装，那么很多情况下效率比较低，而且代码复杂度就上来了，需要添加很多的接口类。</p>
<h3 id="轻便的成员类封装"><a href="#轻便的成员类封装" class="headerlink" title="轻便的成员类封装"></a>轻便的成员类封装</h3><p>下面介绍一种简单的方式来实现类封装性的提升，首先还是看这个test类，我们将其提示为test2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* test2.h */</span><br><span class="line">class test2 &#123;</span><br><span class="line">public:</span><br><span class="line">truevoid print();</span><br><span class="line">truevoid print2();</span><br><span class="line">private:</span><br><span class="line">trueint k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里的k实际上并不需要写在这里，我们需要的是将private的部分整体的封装成一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* test2.h */</span><br><span class="line">class test2_private;</span><br><span class="line"></span><br><span class="line">class test2 &#123;</span><br><span class="line">public:</span><br><span class="line">truetest2();</span><br><span class="line">truetest2(int);</span><br><span class="line">true~test2();</span><br><span class="line"></span><br><span class="line">truevoid print();</span><br><span class="line">truevoid print2();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">truetest2_private* that;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* test2.cpp */</span><br><span class="line">#include &quot;test2.h&quot;</span><br><span class="line"></span><br><span class="line">class test2_private &#123;</span><br><span class="line">public:</span><br><span class="line">trueint k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test2::test2() &#123;</span><br><span class="line">truethat = new test2_private();</span><br><span class="line">truethat-&gt;k = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test2::test2(int k) &#123;</span><br><span class="line">truethat = new test2_private();</span><br><span class="line">truethat-&gt;k = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2::~test2() &#123;</span><br><span class="line">truedelete that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我们发现，这种封装可以很有效的解决类的接口不便的问题，而由于只使用了类指针，所以我们并不需要前向声明这个私有类，于是这个类可以方便的被修改，从而避免了接口和多态调用的问题。</p>
<p>这种设计还有一个用途，假若你有另外的代码生成器生成的代码，需要和已有的类嵌入使用，那么推荐使用这种方式，Qt中就是这样做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MAINWINDOW_H</span><br><span class="line">#define MAINWINDOW_H</span><br><span class="line"></span><br><span class="line">#include &lt;QMainWindow&gt;</span><br><span class="line"></span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class MainWindow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainWindow : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit MainWindow(QWidget *parent = 0);</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // MAINWINDOW_H</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &quot;ui_mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(new Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现这里有一个神奇的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespace Ui &#123;</span><br><span class="line">class MainWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实这只是另外一个类，和本类并不同名，Ui::MainWindow是qt设计器帮忙生成的类，用来标注UI界面生成的一些代码，为了让代码很好的和我们自己的类统一起来，他们用了这种方式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C和C++的面向对象专题（5）——合理使用模板，避免代码冗余]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%EF%BC%8C%E9%81%BF%E5%85%8D%E4%BB%A3%E7%A0%81%E5%86%97%E4%BD%99/"/>
    <id>http://sunxfancy.github.io/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（5）——合理使用模板，避免代码冗余/</id>
    <published>2016-03-28T15:45:02.484Z</published>
    <updated>2015-11-13T07:23:57.306Z</updated>
    <content type="html"><![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="五、合理使用模板，避免代码冗余"><a href="#五、合理使用模板，避免代码冗余" class="headerlink" title="五、合理使用模板，避免代码冗余"></a>五、合理使用模板，避免代码冗余</h2><p>下面我们来讨论一下，如何解决模板的不易封装的问题。</p>
<p>我们提供这样一种思路，对于链表一类的通用类型，我们尽量采取强制类型转换的方式，尽量避免模板的滥用。</p>
<p>同样，我们应该避免对结构体的直接存储，尽量使用类似java的指针传递方式来传递对象。</p>
<p>我们首先来写一个单类型的list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ifndef LIST_C_H</span><br><span class="line">#define LIST_C_H</span><br><span class="line"></span><br><span class="line">class list_c_private;</span><br><span class="line">struct list_c_node;</span><br><span class="line"></span><br><span class="line">class list_c &#123;</span><br><span class="line">public:</span><br><span class="line">truelist_c();</span><br><span class="line">true~list_c();</span><br><span class="line"></span><br><span class="line">truevoid insert(void*);</span><br><span class="line">trueint size();</span><br><span class="line">truevoid* get(int);</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">truelist_c_private* priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // LIST_C_H</span><br></pre></td></tr></table></figure>
<p>这里我们使用了上面讲到的封装方式，降低了类间的耦合度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;list_c.h&quot;</span><br><span class="line"></span><br><span class="line">class list_c_private</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">trueint size;</span><br><span class="line">truelist_c_node* head;</span><br><span class="line">&#125;;	</span><br><span class="line"></span><br><span class="line">struct list_c_node</span><br><span class="line">&#123;</span><br><span class="line">truevoid* data;</span><br><span class="line">truelist_c_node* next;</span><br><span class="line"></span><br><span class="line">truelist_c_node() &#123;</span><br><span class="line">truetruedata = next = nullptr;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_c::list_c() &#123;</span><br><span class="line">truepriv = new list_c_private();</span><br><span class="line">truepriv-&gt;head = new list_c_node();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list_c::~list_c() &#123;</span><br><span class="line">truedelete priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void list_c::insert(void* data) &#123;</span><br><span class="line">truelist_c_node* p;</span><br><span class="line">truefor (p = priv-&gt;head; p-&gt;next != nullptr; p = p-&gt;next) &#123;&#125;</span><br><span class="line">truep-&gt;next = new list_c_node();</span><br><span class="line">truep-&gt;next-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int list_c::size() &#123;</span><br><span class="line">truereturn priv-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* list_c::get(int k) &#123;</span><br><span class="line">trueint t; list_c_node* p;</span><br><span class="line">truefor (p = priv-&gt;head-&gt;next, t = 0; p != nullptr &amp;&amp; t != k ; p = p-&gt;next, ++t) &#123;&#125;</span><br><span class="line">truereturn p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的链表，只是作为示例使用，写了插入和获取的两个方法。</p>
<p>而为了通用性支持，我们写一个模板，进行类型的强制转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#ifndef LIST</span><br><span class="line">#define LIST</span><br><span class="line"></span><br><span class="line">#include &quot;list_c.h&quot;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class list &#123;</span><br><span class="line">public:</span><br><span class="line">truelist() &#123; clist = new list_c(); &#125;</span><br><span class="line">true~list() &#123; delete clist; &#125;</span><br><span class="line"></span><br><span class="line">truevoid insert(T data) &#123;</span><br><span class="line">truetrueclist-&gt;insert((void*)data);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueint size() &#123; return clist-&gt;size(); &#125;</span><br><span class="line"></span><br><span class="line">trueT get(int k) &#123;</span><br><span class="line">truetruereturn (T)clist-&gt;get(k);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">truelist_c* clist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // LIST</span><br></pre></td></tr></table></figure>
<p>这样，带来的好处有，首先能够将模板封装操作，其次，能够在封装类中，动态的调整内部实例。<br>对于一个传入的类型，你可以判断一下，是否适合当前的模板，如果不适合，可以在其中动态的报错。</p>
<p>最后是模板的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;list&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">truelist&lt;long&gt; testlist;</span><br><span class="line">truetestlist.insert(10);</span><br><span class="line">truetestlist.insert(20);</span><br><span class="line"></span><br><span class="line">truelong k = testlist.get(1);</span><br><span class="line">trueprintf(&quot;%d\n&quot;, k);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C和C++的面向对象专题（6）——C++也能反射]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94C++%E4%B9%9F%E8%83%BD%E5%8F%8D%E5%B0%84/"/>
    <id>http://sunxfancy.github.io/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（6）——C++也能反射/</id>
    <published>2016-03-28T15:45:02.483Z</published>
    <updated>2015-11-13T07:23:55.535Z</updated>
    <content type="html"><![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="六、C-也能反射"><a href="#六、C-也能反射" class="headerlink" title="六、C++也能反射"></a>六、C++也能反射</h2><p>今天我们来探讨C++的反射问题，缺乏反射机制一直是C++的大问题，很多系统的设计时，需要根据外部资源文件的定义，动态的调用内部的函数和接口，如果没有反射，将很难将外部的数据，转换为内部的方法。</p>
<p>Java和.net的反射机制很容易实现，由于其动态语言的特性，在编译时就存储了大量的<strong>元数据</strong>，而在动态装载时，也是根据这些元数据载入的模块。由于C++缺乏这些信息，往往并不能很好的动态装载和链接。操作系统为了实现C和C++的动态装载功能，特意设计了动态链接库，将符号表保存在动态库中，运行时重定位代码，然后进行链接操作。而这是操作系统实现的，并不能很好的被用在用户工程中，所以我们有必要自己构建一套<strong>元数据</strong>集合，保存反射所需的内容。</p>
<h3 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h3><p>反射的核心就是根据字符串名字，创建对应的类或者调用对应类的方法，为此，我们使用C++中的map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, meta_class*&gt;</span><br></pre></td></tr></table></figure>
<p>meta_class 是保存一个类中的关键元数据用的类，可以支持反射构造，反射调用函数等功能。</p>
<p>meta_func 是保存一个方法的关键信息类，但由于方法有不定的参数和返回类型，我们使用模板的方式，将一个抽象存储的成员函数指针，转换为我们确定类型的成员函数指针，然后再去调用，达到动态调用的目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename R, typename... Args&gt;</span><br><span class="line">R Call(T* that, Args... args) &#123;</span><br><span class="line">trueR (T::*mp)();</span><br><span class="line">truemp = *((R (T::**)())func_pointer);</span><br><span class="line">truereturn (that-&gt;*mp)(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的代码十分混乱，如果你没学过C的函数指针的话，建议先去补习一下函数指针的定义和用法。</p>
<p>这里涉及到的是成员函数指针的传递，一会儿将会详细讲解如何传递任意一个函数指针。</p>
<h3 id="反射类对象"><a href="#反射类对象" class="headerlink" title="反射类对象"></a>反射类对象</h3><p>首先，我们肯定要为类对象建立meta_class的模型，但每个meta_class，应该都能够构建本类的对象，为了实现这一特点，我们想到了模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class MetaClass : public IMetaClass &#123;</span><br><span class="line">public:</span><br><span class="line">truevirtual void* CreateObject() &#123;</span><br><span class="line">truetruereturn new T();</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了让每个类都能有统一的创建方法，我们将使用IMetaClass接口进行多态调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class IMetaClass &#123;</span><br><span class="line">public:</span><br><span class="line">truevirtual void* CreateObject() = 0;</span><br><span class="line"></span><br><span class="line">truetemplate&lt;typename T&gt;</span><br><span class="line">trueT* Create() &#123;</span><br><span class="line">truetruereturn (T*) CreateObject();</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truevoid AddFunc(const std::string s, MetaFunc* c) &#123; func_map[s] = c; &#125;</span><br><span class="line">trueMetaFunc* GetFunc(const std::string s) &#123;</span><br><span class="line">truetrueif (func_map.find(s) != func_map.end()) return func_map[s];</span><br><span class="line">truetrueelse return NULL;</span><br><span class="line">true&#125;</span><br><span class="line">private:</span><br><span class="line">truestd::map&lt;const std::string, MetaFunc*&gt; func_map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们在接口类中编写了方法和成员函数，我觉得这是C++的优势，不像Java，为了安全性，而取消了这么简单好用的功能。</p>
<p>接口统一实现相同的类对象构建方式，避免了在实现类中反复编写的困难。</p>
<p>这样，我们只要在每个类的定义时，向我们的类注册器注册该MetaClass对象就可以了</p>
<p>但问题是，如何才能在类定义时编写代码呢？我们的C和C++可是只能在函数中调用代码，不能像脚本一样随时随地执行。</p>
<h3 id="利用全局对象的构造函数执行代码"><a href="#利用全局对象的构造函数执行代码" class="headerlink" title="利用全局对象的构造函数执行代码"></a>利用全局对象的构造函数执行代码</h3><p>我们发现，C++有一个很有趣的特性，有些代码是可以在main函数执行前就执行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">truetest() &#123;</span><br><span class="line">truetrueprintf(&quot;%s\n&quot;,&quot;Hello Ctor!&quot;);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test show_message();</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">trueprintf(&quot;Main function run!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，哦？好像不大对，貌似我们的对象并没有启动，这有可能是被编译器优化掉了。。。= =！<br>控制台的显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sxf@sxf-PC:~/data/workspace/C++/OObyCpp/testCppRunCode$ ./main</span><br><span class="line">Main function run!</span><br></pre></td></tr></table></figure></p>
<p>稍加改动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">truetest(const char* msg) &#123;</span><br><span class="line">truetrueprintf(&quot;%s\n&quot;,msg);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test show_message(&quot;Hello Ctor!&quot;);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">trueprintf(&quot;Main function run!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好的，我们发现构造函数运行在了main函数之前，也就是我们的类型定义的构造期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sxf@sxf-PC:~/data/workspace/C++/OObyCpp/testCppRunCode$ ./main</span><br><span class="line">Hello Ctor!</span><br><span class="line">Main function run!</span><br></pre></td></tr></table></figure></p>
<p>具体想详细了解C++的运行环境的细节，推荐看一本英文的开源书：<br>【How to Make a Computer Operating System】<br>这本书讲解如何利用C++开发了一个小型操作系统，而在C++运行时的导入过程中，就介绍了C++全局对象构造函数的运行过程，可以清楚的看出，C++的主函数在汇编层的调用流程是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">truepush ebx</span><br><span class="line">true </span><br><span class="line">static_ctors_loop: 					; 全局构造函数初始化</span><br><span class="line">   mov ebx, start_ctors</span><br><span class="line">   jmp .test</span><br><span class="line">.body:</span><br><span class="line">   call [ebx]</span><br><span class="line">   add ebx,4</span><br><span class="line">.test:</span><br><span class="line">   cmp ebx, end_ctors</span><br><span class="line">   jb .body</span><br><span class="line"> </span><br><span class="line">   call kmain  						; 调用主函数</span><br><span class="line"> </span><br><span class="line">static_dtors_loop:					; 全局对象的析构函数调用</span><br><span class="line">   mov ebx, start_dtors</span><br><span class="line">   jmp .test</span><br><span class="line">.body:</span><br><span class="line">   call [ebx]</span><br><span class="line">   add ebx,4</span><br><span class="line">.test:</span><br><span class="line">   cmp ebx, end_dtors</span><br><span class="line">   jb .body</span><br></pre></td></tr></table></figure>
<p>于是我们可以这样编写一个类，专门用来注册一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class reflector_class &#123;</span><br><span class="line">public:</span><br><span class="line">truereflector_class(const char* name, IMetaClass* meta_class) &#123;</span><br><span class="line">truetrueClassRegister::Add(name, meta_class);</span><br><span class="line">truetrueprintf(&quot;define class: %s\n&quot;, name);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类的对象在构造时，会去调用ClassRegister类中的静态方法，向其中添加类名和类元数据</p>
<h3 id="利用宏定义处理类的注册"><a href="#利用宏定义处理类的注册" class="headerlink" title="利用宏定义处理类的注册"></a>利用宏定义处理类的注册</h3><p>我们希望每个类对象能够方便的找到自己的meta_class，最简单的方式就是将其添加为自己的成员，为何不用继承机制呢？首先继承较为复杂，并且父类也同样可能拥有meta_class, 我们希望每个类型都能方便的找到meta_class，那么可以建一条Reflectible宏，让大家写在class中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef Reflectible</span><br><span class="line">#define Reflectible \</span><br><span class="line">public:\</span><br><span class="line">truestatic IMetaClass* meta_class;\</span><br><span class="line">private:</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>为了避免放置在最上面时，影响下面成员的private的默认定义，所以写成这样。</p>
<p>我们在写一个宏，让用户添加到类的cpp文件中，真正定义该meta_class对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef ReflectClass</span><br><span class="line">#define ReflectClass(class_name) \</span><br><span class="line">trueIMetaClass* class_name :: meta_class = new MetaClass&lt; class_name &gt;(); \</span><br><span class="line">truereflector_class class_name##reflector_class( #class_name , class_name::meta_class)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>这里我们用到了两个宏技巧：</p>
<pre><code>## 表示将两个符号连接在一起，由于词法分析中，宏是按照词的顺序分隔的，如果直接连接，往往会造成符号分析不清。
#something 表示将该内容展开成字符串的形式 =&gt; &quot;something data&quot;，所以我们可以很方便的用这个宏将宏符号转为字符串传入到函数中。
</code></pre><h3 id="反射成员函数"><a href="#反射成员函数" class="headerlink" title="反射成员函数"></a>反射成员函数</h3><p>首先编写一个能调用成员函数的模板类，根据我们的反射原理，将一个函数指针转换为成员函数的指针：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MetaFunc &#123;</span><br><span class="line">public:</span><br><span class="line">trueMetaFunc(void* p) &#123; func_pointer = p; &#125;</span><br><span class="line">truevoid setFuncPointer(void* p) &#123; func_pointer = p; &#125;</span><br><span class="line">truetemplate &lt;typename T, typename R, typename... Args&gt;</span><br><span class="line">trueR Call(T* that, Args... args) &#123;</span><br><span class="line">truetrueR (T::*mp)();</span><br><span class="line">truetruemp = *((R (T::**)())func_pointer);</span><br><span class="line">truetruereturn (that-&gt;*mp)(args...);</span><br><span class="line">true&#125;</span><br><span class="line">private:</span><br><span class="line">truevoid* func_pointer;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我在这里使用了C++11的新特性，可变参数的模板，这样可以更方便的接受目标参数<br>如果我们直接对成员函数取地址，返回的是一个return_type (ClassName::<em>)(args)这样的成员函数指针。<br>注意，成员函数指针不能直接被传递，成员函数指针由于包含了很多其他数据信息，并不能被被强制类型转换成void</em>,一个显而易见的例子是，成员函数指针，往往比较大，最大的指针甚至可以达到20byte。</p>
<p>为了能够传递函数指针，我们可以将成员函数指针赋值给一个该成员函数指针类型的对象，然后再对这个指针对象取地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto p = &amp;test::print;</span><br><span class="line">&amp;p  //这个地址可以被轻松传递</span><br></pre></td></tr></table></figure>
<p>这个地址是一个指针的指针<code>return_type (ClassName::**)(args)</code><br>于是就有了我们前面代码中，强制类型转换的方法</p>
<h3 id="利用C语言的可变参数函数来定义函数"><a href="#利用C语言的可变参数函数来定义函数" class="headerlink" title="利用C语言的可变参数函数来定义函数"></a>利用C语言的可变参数函数来定义函数</h3><p>我们目前要将地址传递过来，但是我们并不知道每个类中有多少个函数，所以我们要使用C语言的宏，对可变参数进行处理。</p>
<p>下面将reflector_class进行一下修改，支持多个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class reflector_class &#123;</span><br><span class="line">public:</span><br><span class="line">truereflector_class(const char* name, IMetaClass* meta_class, ...) &#123;</span><br><span class="line">truetrueClassRegister::Add(name, meta_class);</span><br><span class="line">truetrueprintf(&quot;define class: %s\n&quot;, name);</span><br><span class="line"></span><br><span class="line">truetrueva_list ap;</span><br><span class="line">truetrueva_start(ap, meta_class);  </span><br><span class="line">truetruefor (int arg = va_arg(ap, int); arg != -1; arg = va_arg(ap, int) ) </span><br><span class="line">truetrue&#123;</span><br><span class="line">truetruetruestd::string name(va_arg(ap, const char*));  </span><br><span class="line">truetruetruevoid* p = va_arg(ap, void*);</span><br><span class="line">truetruetrueif (arg == 0) &#123;</span><br><span class="line">truetruetruetrueprintf(&quot;\tdefine func: %s\n&quot;, name.c_str());</span><br><span class="line">truetruetruetrueMetaFunc* f = new MetaFunc(p);</span><br><span class="line">truetruetruetruemeta_class-&gt;AddFunc(name, f);</span><br><span class="line">truetruetrue&#125; else &#123;</span><br><span class="line">truetruetruetrueprintf(&quot;\tdefine prop: %s\n&quot;, name.c_str());</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetrue&#125;  </span><br><span class="line">truetrueva_end(ap);  </span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<pre><code>va_list ap; 可变参数列表

va_start(ap, meta_class);  这里的第二个参数，是当前函数的最后一个固定参数位置

void* p = va_arg(ap, void*); 可以用来获得一个固定类型的参数
</code></pre><p>使用过后释放资源：</p>
<pre><code>va_end(ap);  
</code></pre><p>为了支持函数和属性两种声明，我们定义如下宏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#ifndef DefReflectFunc</span><br><span class="line">#define DefReflectFunc(class_name, func_name) \</span><br><span class="line">trueauto func_name##_function_pointer = &amp;class_name::func_name</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef ReflectClass</span><br><span class="line">#define ReflectClass(class_name) \</span><br><span class="line">trueIMetaClass* class_name :: meta_class = new MetaClass&lt; class_name &gt;(); \</span><br><span class="line">truereflector_class class_name##reflector_class( #class_name , class_name::meta_class ,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef ReflectFunc</span><br><span class="line">#define ReflectFunc(func_name) \</span><br><span class="line">true0, #func_name, _F(func_name##_function_pointer) ,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef ReflectProp</span><br><span class="line">#define ReflectProp(prop_names) \</span><br><span class="line">true1, #prop_names, _F(prop_names) ,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef _F</span><br><span class="line">#define _F(x) reinterpret_cast&lt;void*&gt;(&amp;x)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef End</span><br><span class="line">#define End -1 )</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>这样我们在cpp中使用这些宏时只需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DefReflectFunc(test2,print2);</span><br><span class="line">ReflectClass(test2)</span><br><span class="line">trueReflectFunc(print2)</span><br><span class="line">End;</span><br></pre></td></tr></table></figure></p>
<h3 id="类的全局注册难题"><a href="#类的全局注册难题" class="headerlink" title="类的全局注册难题"></a>类的全局注册难题</h3><p>好的，关键的部分已经都清楚了，但目前我们还欠缺一个很重要的类，就是类的全局注册器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ClassRegister</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">truestatic std::map&lt;const std::string, IMetaClass*&gt; class_map;</span><br><span class="line">truestatic void Add(const std::string s, IMetaClass* k) &#123;</span><br><span class="line">truetrueclass_map[s] = k;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这个类有一个严重的漏洞，会造成程序崩溃，我们在接下来的章节中，将会介绍这个尴尬的问题的发生原因。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C和C++的面向对象专题（7）——单例模式解决静态成员对象和全局对象的构造顺序难题]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98/C%E5%92%8CC++%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%93%E9%A2%98%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F%E9%9A%BE%E9%A2%98/"/>
    <id>http://sunxfancy.github.io/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（7）——单例模式解决静态成员对象和全局对象的构造顺序难题/</id>
    <published>2016-03-28T15:45:02.482Z</published>
    <updated>2015-11-13T07:23:53.531Z</updated>
    <content type="html"><![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="七、单例模式解决静态成员对象和全局对象的构造顺序难题"><a href="#七、单例模式解决静态成员对象和全局对象的构造顺序难题" class="headerlink" title="七、单例模式解决静态成员对象和全局对象的构造顺序难题"></a>七、单例模式解决静态成员对象和全局对象的构造顺序难题</h2><p>上回书说道，我们的程序有一个隐藏的漏洞，如果ClassRegister这个类所在的.o文件，如果在所有.o文件中是第一个被链接的的，那么就不会出问题。<br>这么说太抽象了，让我们画个图表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassRegister.o</span><br><span class="line">--------------------</span><br><span class="line">Meta.o</span><br><span class="line">--------------------</span><br><span class="line">Main.o</span><br></pre></td></tr></table></figure>
<p>这样的结构，也就是链接顺序要这样指定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main ClassRegister.o Meta.o Main.o</span><br></pre></td></tr></table></figure></p>
<p>就不会出问题，但如果调换一下顺序就可能出问题。</p>
<p>思考一下原因，ClassRegister中的map对象，是一个全局对象，而我们注册类的时候，也使用了全局对象的构造函数，两个谁先执行呢？这个就不得而知了，C++并未说明两个谁先谁后，而一般链接器，都是从前往后链接代码，而构造函数的执行顺序，也往往和链接时的顺序有关。</p>
<p>但这样实现就很不好，我们的系统居然要靠链接器的顺序才能正确编译执行，太不可靠了，万一用户没注意到这一点，直接编译链接，就会出现未知的错误。</p>
<p>那么如何避免这种情况呢？</p>
<h3 id="C-的单例模式"><a href="#C-的单例模式" class="headerlink" title="C++的单例模式"></a>C++的单例模式</h3><p>C++中有一种极好的设计模式很适合这种情况，那就是用单例，单例模式也很容易理解，核心就是推迟构造，如果没有使用时，就不会被构造，被用到时，对象就会构造，并且仅一次，最常见的写法就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CSingleton  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    CSingleton()   //构造函数是私有的  </span><br><span class="line">    &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    static CSingleton *m_pInstance;  </span><br><span class="line">public:  </span><br><span class="line">    static CSingleton * GetInstance()  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(m_pInstance == NULL)  //判断是否第一次调用  </span><br><span class="line">            m_pInstance = new CSingleton();  </span><br><span class="line">        return m_pInstance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，我们这里并没有考虑多线程，因为多线程时单例模式一般要加锁来保障不会多次构造引发冲突。</p>
<p>于是经过简要修改，就能用单例模式设计一个类注册器了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ClassRegister</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">trueClassRegister() &#123; printf(&quot;register\n&quot;); &#125;  //构造函数是私有的   </span><br><span class="line">truestd::map&lt;const std::string, IMetaClass*&gt; class_map;</span><br><span class="line">public:</span><br><span class="line">truestatic ClassRegister * GetInstance() &#123;  </span><br><span class="line">truetruestatic ClassRegister instance;   //局部静态变量  </span><br><span class="line">truetruereturn &amp;instance;</span><br><span class="line">true&#125;</span><br><span class="line">truestatic void Add(const std::string s, IMetaClass* k) &#123;</span><br><span class="line">truetrueGetInstance()-&gt;class_map[s] = k;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truestatic IMetaClass* Get(const std::string s) &#123;</span><br><span class="line">truetruestd::map&lt;const std::string, IMetaClass*&gt;&amp; m =  GetInstance()-&gt;class_map;</span><br><span class="line">truetrueif (m.find(s) != m.end()) return m[s];</span><br><span class="line">truetrueelse return NULL;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个类注册器简单实用，采用的设计方式和指针的模式稍有不同，这里用到了局部静态变量的概念。<br>局部静态变量能够改变对象的生存周期，这样就能很好的符合我们的要求。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译器架构的王者LLVM——（10）变量的存储与读取]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85%E2%80%94%E2%80%94LLVM/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85LLVM%E2%80%94%E2%80%94%EF%BC%8810%EF%BC%89%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AF%BB%E5%8F%96/"/>
    <id>http://sunxfancy.github.io/2016/03/28/编译器架构的王者——LLVM/编译器架构的王者LLVM——（10）变量的存储与读取/</id>
    <published>2016-03-28T15:45:02.479Z</published>
    <updated>2015-12-06T10:53:30.765Z</updated>
    <content type="html"><![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://blog.csdn.net/xfxyy_sxfancy" target="_blank" rel="external">http://blog.csdn.net/xfxyy_sxfancy</a></p>
<h1 id="变量的存储与读取"><a href="#变量的存储与读取" class="headerlink" title="变量的存储与读取"></a>变量的存储与读取</h1><p>变量是一款编程语言中的核心，说编译语言是一种符号处理工具，其实是有些道理的。栈式符号表可以方便的记录编译过程中的变量和语法符号，我们上节已经了解了其中的实现方法。那么，还有没有其他的办法能够简单的实现变量的存取呢？</p>
<h2 id="LLVM的内置符号表"><a href="#LLVM的内置符号表" class="headerlink" title="LLVM的内置符号表"></a>LLVM的内置符号表</h2><p>其实LLVM还提供了一个内部符号表，这个和我们的符号表不一样，它的符号是以函数为界的，函数内的是局部符号，外面的是全局符号。这个符号表的作用，主要是供LLVM找到各个底层的语法元素而设计的，所以它的功能较为有限。</p>
<p>例如下面这段字节码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define void @print(i64 %k1) &#123;</span><br><span class="line">entry:</span><br><span class="line">true...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过符号表，找到k1这个元素。</p>
<p>这个符号表的获取也很简单，只要你有basicblock，你就能够找到这个符号表的指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BasicBlock* bb = context-&gt;getNowBlock();</span><br><span class="line">   ValueSymbolTable* st = bb-&gt;getValueSymbolTable();</span><br><span class="line">   Value* v = st-&gt;lookup(value);</span><br></pre></td></tr></table></figure>
<h2 id="栈上变量空间的分配，AllocaInst语句"><a href="#栈上变量空间的分配，AllocaInst语句" class="headerlink" title="栈上变量空间的分配，AllocaInst语句"></a>栈上变量空间的分配，AllocaInst语句</h2><p>AllocaInst是LLVM的一条标准语句，负责栈上空间的分配，你无需考虑栈的增长的操作，它会自动帮你完成，并返回给你对应空间的指针。</p>
<p>千万不要认为这个语句能够动态分配堆内存，堆内存实际上是通过调用Malloc语句来分配的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%k = alloca i64</span><br></pre></td></tr></table></figure>
<p>以上语句，会让k的类型变为你分配类型的指针。</p>
<p>这个语句的C++接口非常的好用，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllocaInst *alloc = new AllocaInst(t, var_name, context-&gt;getNowBlock());</span><br></pre></td></tr></table></figure></p>
<p>t对应分配的类型，var_name对应语句返回的那个变量名（上面的‘k’），最后一个参数当然是插入的basicblock。</p>
<p>这时，返回的语句，就代表k这个指针了。</p>
<h2 id="变量的存储"><a href="#变量的存储" class="headerlink" title="变量的存储"></a>变量的存储</h2><p>LLVM中，变量的存储，都需要知道要存储地址的指针，注意，一定是指针，而不是值。</p>
<p>原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StoreInst (Value *Val, Value *Ptr, bool isVolatile, BasicBlock *InsertAtEnd)</span><br></pre></td></tr></table></figure></p>
<p>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new StoreInst(value2, value1, false, context-&gt;getNowBlock());</span><br></pre></td></tr></table></figure></p>
<p>这个value1，就是目标的存储指针，而value2则是要放入的值。false表示不是易变的，这个参数相当与C语言中的volatile关键字，主要是防止这个变量在重复读取时的编译器优化。因为一般的编译器优化，都会将一个变量在没有改变情况下的多次读取，认为取到同一个值，虽然这在多线程和硬中断的环境下并不成立。</p>
<h2 id="变量的读取"><a href="#变量的读取" class="headerlink" title="变量的读取"></a>变量的读取</h2><p>变量的读取，就用Load语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadInst (Value *Ptr, const Twine &amp;NameStr, bool isVolatile, unsigned Align, BasicBlock *InsertAtEnd)</span><br></pre></td></tr></table></figure></p>
<p>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new LoadInst(v, &quot;&quot;, false, bb);</span><br></pre></td></tr></table></figure></p>
<p>我们这里暂时没有考虑内存对齐的问题，当然，一般在Clang中，都是4字节对齐的。我们注意到，其实Load语句也是从指针中取值的，返回的则是一个值类型。</p>
<h2 id="打造一个赋值语句"><a href="#打造一个赋值语句" class="headerlink" title="打造一个赋值语句"></a>打造一个赋值语句</h2><p>赋值语句其实是一个挺尴尬的语句，左边要赋值的，应该是一个指针地址，而右边的部分，则应该是一个获取到的值。而之前我们的运算，函数调用等等，绝大部分都是依赖值类型的。</p>
<p>我们先要为变量实现一个值的获取，这部分因为很通用，我们放到IDNode节点的代码生成中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Value* IDNode::codeGen(CodeGenContext* context) &#123;</span><br><span class="line">    BasicBlock* bb = context-&gt;getNowBlock();</span><br><span class="line">    ValueSymbolTable* st = bb-&gt;getValueSymbolTable();</span><br><span class="line">    Value* v = st-&gt;lookup(value);</span><br><span class="line">    if (v == NULL || v-&gt;hasName() == false) &#123;</span><br><span class="line">        errs() &lt;&lt; &quot;undeclared variable &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    Value* load = new LoadInst(v, &quot;&quot;, false, bb);</span><br><span class="line">    return load;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>value是我们类的成员变量，记录的是变量名。</p>
<p>然而赋值语句有时还会要求获取到的是指针，不是值，现在我们要为赋值语句实现一个符号指针的获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Value* IDNode::codeGen(CodeGenContext* context) &#123;</span><br><span class="line">    BasicBlock* bb = context-&gt;getNowBlock();</span><br><span class="line">    ValueSymbolTable* st = bb-&gt;getValueSymbolTable();</span><br><span class="line">    Value* v = st-&gt;lookup(value);</span><br><span class="line">    if (v == NULL || v-&gt;hasName() == false) &#123;</span><br><span class="line">        errs() &lt;&lt; &quot;undeclared variable &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    if (context-&gt;isSave()) return v; // 我们在上下文类中记录了一个变量，看当前状态是存还是取</span><br><span class="line">    Value* load = new LoadInst(v, &quot;&quot;, false, bb);</span><br><span class="line">    return load;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么我们在调用时，只需要这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static Value* opt2_macro(CodeGenContext* context, Node* node) &#123;</span><br><span class="line">truestd::string opt = node-&gt;getStr();</span><br><span class="line"></span><br><span class="line">trueNode* op1 = (node = node-&gt;getNext());</span><br><span class="line">trueif (node == NULL) return NULL;</span><br><span class="line">trueNode* op2 = (node = node-&gt;getNext());</span><br><span class="line">trueif (node == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">trueif (opt == &quot;=&quot;) &#123;</span><br><span class="line">truetruecontext-&gt;setIsSave(true); // 这两句设置的目前是为下面的节点解析时,返回指针而不是load后的值</span><br><span class="line">truetrueValue* ans1 = op1-&gt;codeGen(context);</span><br><span class="line">truetruecontext-&gt;setIsSave(false);</span><br><span class="line">truetrueValue* ans2 = op2-&gt;codeGen(context);</span><br><span class="line">truetruereturn new StoreInst(ans2, ans1, false, context-&gt;getNowBlock());</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们这里也可以单独实现一个函数来处理这个功能，但由于两个函数功能太像，所以也不怎么想添加一个类似的函数了。<br>这个部分暂时先这样处理一下，待整体结构完善后，应该有更好的实现方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译器架构的王者LLVM——（9）栈式符号表的构建]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85%E2%80%94%E2%80%94LLVM/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85LLVM%E2%80%94%E2%80%94%EF%BC%889%EF%BC%89%E6%A0%88%E5%BC%8F%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
    <id>http://sunxfancy.github.io/2016/03/28/编译器架构的王者——LLVM/编译器架构的王者LLVM——（9）栈式符号表的构建/</id>
    <published>2016-03-28T15:45:02.477Z</published>
    <updated>2015-12-06T10:53:28.496Z</updated>
    <content type="html"><![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://blog.csdn.net/xfxyy_sxfancy" target="_blank" rel="external">http://blog.csdn.net/xfxyy_sxfancy</a></p>
<h1 id="栈式符号表的构建"><a href="#栈式符号表的构建" class="headerlink" title="栈式符号表的构建"></a>栈式符号表的构建</h1><p>栈式符号表对于一款编译器，无疑是核心的组件。<br>无论你在做什么符号扫描，那么都离不开符号表，如何得知一个符号是否定义，以及它的类型，那么唯有查看符号表中的记录。<br>栈式符号表并不复杂，但思想精妙，本文，将介绍一款栈式符号表的原理及简单构建。</p>
<h2 id="源代码的例子"><a href="#源代码的例子" class="headerlink" title="源代码的例子"></a>源代码的例子</h2><p>首先我们来看一段C代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a[3] = &#123; 100, 10, 1&#125;;</span><br><span class="line"></span><br><span class="line">int work() &#123;</span><br><span class="line">trueif (a[0] == 100) &#123; // 这里的a指向的是全局符号a</span><br><span class="line">truetrueint a = 99999; // 重新定义了局部符号    下图的符号表是扫描到这里后的情况</span><br><span class="line">truetruefor (int i = 0; i&lt; 10; ++i) &#123;</span><br><span class="line">truetruetruea /= 3; // 由于局部符号优先级较高，引用局部符号</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruereturn a; // 局部符号</span><br><span class="line">true&#125;</span><br><span class="line">truereturn a[0]; // 局部符号生命周期已过，找到全局符号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是我们发现，符号表在局部声明变量后，将局部符号增加了，这和全局符号并不冲突，而是优先级不同，越靠近栈顶，越先发现</p>
<p><img src="img/9/fhb.png" alt=""></p>
<h2 id="用C-的map和stack构建符号表"><a href="#用C-的map和stack构建符号表" class="headerlink" title="用C++的map和stack构建符号表"></a>用C++的map和stack构建符号表</h2><p>如果考虑效率的话，最佳选择是用C语言构建符号表，这样操作起来会更快，但我们毕竟目前考虑开发的简便型而言，用C++的map就可以方便地实现符号表。</p>
<p>首先我们做一个局部符号表，由于其中不会有重复的符号名，所以我们只要简单的将其存放起来即可。<br>然后符号表还需要记录很多类型信息、指针信息等，我们设计一个结构体表示它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum SymbolType</span><br><span class="line">&#123;</span><br><span class="line">truevar_t, type_t, struct_t, enum_t, delegate_t, function_t</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct id &#123;</span><br><span class="line">    int        level;</span><br><span class="line">    SymbolType type;</span><br><span class="line">    void*      data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们目前是简单起见，由于还不知道都可能放哪些东西，例如数组符号，肯定要包含数组长度、维度等信息，各种变量都会包含类型信息，所以我们这里放了一个void*的指针，到时候需要的化，就强制转换一下。</p>
<p>这里其实定义一个基类，需要存储的内容去多态派生也是可以的，没做主要是因为可能存放的东西类型很多，暂时先用一个void*，这样可能方便一点。</p>
<p>于是我们的局部符号表就有了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class IDMap</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    IDMap();</span><br><span class="line">    ~IDMap();</span><br><span class="line">    id* find(string&amp; str) const; // 查找一个符号</span><br><span class="line">    void insert(string&amp; str, int level, SymbolType type, void* data); // 插入一个符号</span><br><span class="line">private:</span><br><span class="line">    map&lt;string,id*&gt; ID_map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我想查找和插入都是C++中map的基础函数，大家应该很轻松就能实现吧。</p>
<p>再弄一个栈来存储一个IDMap：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class IDTable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    IDTable();</span><br><span class="line">    id* find(string&amp; str) const;</span><br><span class="line">    void insert(string&amp; str,SymbolType type, void* data);</span><br><span class="line">    void push(); // 压栈和弹栈操作，例如在函数的解析时，需要压栈，一个函数解析完，就弹栈</span><br><span class="line">    void pop();</span><br><span class="line">    int getLevel(); // 获取当前的层级，如果为0，则说明是只有全局符号了</span><br><span class="line">private:</span><br><span class="line">    deque&lt;IDMap&gt; ID_stack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里用deque而没用stack的原因是，deque支持随机访问，而stack只能访问栈顶。</p>
<p>寻找时，就按照从栈顶到栈底的顺序依次寻找符号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">id* IDTable::find(string&amp; idname) const &#123;</span><br><span class="line">    for (auto p = ID_stack.rbegin(); p != ID_stack.rend(); ++p) &#123;</span><br><span class="line">        const IDMap&amp; imap = *p;</span><br><span class="line">        id* pid = imap.find(idname);</span><br><span class="line">        if (pid != NULL) return pid;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入时，就往栈顶，当前最新的符号表里面插入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void IDTable::insert(string&amp; str,SymbolType type, void* data) &#123;</span><br><span class="line">    IDMap&amp; imap = ID_stack.back();</span><br><span class="line">    imap.insert(str,getLevel(), type, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，一款简易的栈式符号表就构建好了。</p>
<h2 id="附1：Github参考源码"><a href="#附1：Github参考源码" class="headerlink" title="附1：Github参考源码"></a>附1：Github参考源码</h2><p><a href="https://github.com/sunxfancy/RedApple/blob/master/src/idmap.h" target="_blank" rel="external">idmap.h</a><br><a href="https://github.com/sunxfancy/RedApple/blob/master/src/idmap.cpp" target="_blank" rel="external">idmap.cpp</a><br><a href="https://github.com/sunxfancy/RedApple/blob/master/src/idtable.h" target="_blank" rel="external">idtable.h</a><br><a href="https://github.com/sunxfancy/RedApple/blob/master/src/idtable.cpp" target="_blank" rel="external">idtable.cpp</a></p>
<h2 id="附2：Graphviz的绘图源码"><a href="#附2：Graphviz的绘图源码" class="headerlink" title="附2：Graphviz的绘图源码"></a>附2：Graphviz的绘图源码</h2><p>Graphviz绘图真的非常爽，上面的数据结构图就是用它的dot画的，想了解的朋友可以参考我之前写的 <a href="http://blog.csdn.net/xfxyy_sxfancy/article/details/49641825" target="_blank" rel="external">结构化图形绘制利器Graphviz</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">digraph g &#123;</span><br><span class="line">truegraph [</span><br><span class="line">truetruerankdir = &quot;LR&quot;</span><br><span class="line">true];</span><br><span class="line">truenode [</span><br><span class="line">truetruefontsize = &quot;16&quot;</span><br><span class="line">truetrueshape = &quot;ellipse&quot;</span><br><span class="line">true];</span><br><span class="line">trueedge [</span><br><span class="line">true];</span><br><span class="line"></span><br><span class="line">true&quot;node0&quot; [</span><br><span class="line">truetruelabel = &quot;&lt;f0&gt; stack | &lt;f1&gt; | &lt;f2&gt; | ...&quot;</span><br><span class="line">truetrueshape = &quot;record&quot;	</span><br><span class="line">true];</span><br><span class="line"></span><br><span class="line">true&quot;node1&quot; [</span><br><span class="line">truetruelabel = &quot;&lt;f0&gt; 全局符号 | a | work |  | ...&quot;</span><br><span class="line">truetrueshape = &quot;record&quot;</span><br><span class="line">true]</span><br><span class="line"></span><br><span class="line">true&quot;node2&quot; [</span><br><span class="line">truetruelabel = &quot;&lt;f0&gt; 局部符号 | a |  | ...&quot;</span><br><span class="line">truetrueshape = &quot;record&quot;</span><br><span class="line">true]</span><br><span class="line"></span><br><span class="line">true&quot;node0&quot;:f1 -&gt; &quot;node1&quot;:f0 [</span><br><span class="line">truetrueid = 0</span><br><span class="line">true];</span><br><span class="line"></span><br><span class="line">true&quot;node0&quot;:f2 -&gt; &quot;node2&quot;:f0 [</span><br><span class="line">truetrueid = 1</span><br><span class="line">true];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译器架构的王者LLVM——（8）函数的调用及基本运算符]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85%E2%80%94%E2%80%94LLVM/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85LLVM%E2%80%94%E2%80%94%EF%BC%888%EF%BC%89%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%8F%8A%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://sunxfancy.github.io/2016/03/28/编译器架构的王者——LLVM/编译器架构的王者LLVM——（8）函数的调用及基本运算符/</id>
    <published>2016-03-28T15:45:02.476Z</published>
    <updated>2015-12-06T10:53:24.728Z</updated>
    <content type="html"><![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://blog.csdn.net/xfxyy_sxfancy" target="_blank" rel="external">http://blog.csdn.net/xfxyy_sxfancy</a></p>
<h1 id="函数的调用及基本运算符"><a href="#函数的调用及基本运算符" class="headerlink" title="函数的调用及基本运算符"></a>函数的调用及基本运算符</h1><p>之前我们提到了函数的定义，那么，定义好的函数如何调用才行呢？今天我们就来了解一下，函数的调用。</p>
<h2 id="函数调用的宏形式"><a href="#函数调用的宏形式" class="headerlink" title="函数调用的宏形式"></a>函数调用的宏形式</h2><p>我们去读之前对函数调用的语法树翻译形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d\n&quot;, y);</span><br></pre></td></tr></table></figure>
<p>会被翻译为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node</span><br><span class="line">             String call</span><br><span class="line">             String printf</span><br><span class="line">             String %d\n</span><br><span class="line">             ID y</span><br></pre></td></tr></table></figure>
<p>这个宏的名字是call，是个不定参数的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(call 函数名 参数表... )</span><br></pre></td></tr></table></figure></p>
<p>于是我们就需要扫描参数表，获取全部调用参数。</p>
<h2 id="调用宏的基本形式"><a href="#调用宏的基本形式" class="headerlink" title="调用宏的基本形式"></a>调用宏的基本形式</h2><p>调用宏其实很简单，就是不断循环判断有多少参数即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static Value* call_macro(CodeGenContext* context, Node* node) &#123;</span><br><span class="line">true// 参数一 函数名</span><br><span class="line">true</span><br><span class="line">true// 其余参数 要传入的参数</span><br><span class="line">truefor (Node* p = node-&gt;getNext(); p != NULL; p = p-&gt;getNext()) &#123;</span><br><span class="line">truetrue// 循环获取参数</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外我们查阅一下LLVM的文档，找到其中CallInst这个指令，LLVM的指令都派生自Instruction，可以发现构建的方法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static CallInst * Create (Value *Func, ArrayRef&lt; Value * &gt; Args, const Twine &amp;NameStr, BasicBlock *InsertAtEnd)</span><br></pre></td></tr></table></figure></p>
<p>但是我们发现，Value中要传输的是一个Function对象，如何获取呢？当然还是从符号表中获取，我们下次会讲符号表的实现，这次也和上节一样，将接口先写出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 参数一 函数名</span><br><span class="line">Value* func = context-&gt;getFunction(node);</span><br><span class="line">if (func == NULL) &#123;</span><br><span class="line">trueerrs() &lt;&lt; &quot;找不到函数的定义：&quot;;</span><br><span class="line">trueerrs() &lt;&lt; node-&gt;getStr().c_str() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">trueexit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数调用在生成时，如果这个函数还没有被扫描到，那么在生成时会报函数定义找不到的问题，这就是我们为什么要用多遍扫描。只有充分的多次扫描语法树，才能获取每个函数后面的函数定义。虽然像C语言那样强制声明也可以，但我个人不大喜欢这种风格。</p>
<p>至于参数的获取，就十分简单的，但有一点要注意，参数是递归生成的，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d&quot;, add(3, 5));</span><br></pre></td></tr></table></figure>
<p>这时，我们在获取参数时，就会发现，其中一个参数是表达式，那么我们就要先对其进行处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 其余参数 要传入的参数</span><br><span class="line">std::vector&lt;Value*&gt; args;</span><br><span class="line">for (Node* p = node-&gt;getNext(); p != NULL; p = p-&gt;getNext()) &#123;</span><br><span class="line">trueValue* v = p-&gt;codeGen(context); // 递归地生成参数</span><br><span class="line">trueif (v != NULL)</span><br><span class="line">truetrueargs.push_back(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node类下面有实现codeGen方法，其作用就是重新调用了完整的对当前节点的代码生成，方便递归调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value* Node::codeGen(CodeGenContext* context) &#123;</span><br><span class="line">truereturn context-&gt;MacroMake(this); // MacroMake是核心的代码生成接口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>于是我们递归地生成了这些代码，就可以产生一条Call语句，那么别忘记将其返回给上一层：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static Value* call_macro(CodeGenContext* context, Node* node) &#123;</span><br><span class="line">true// 参数一 函数名</span><br><span class="line">trueValue* func = context-&gt;getFunction(node);</span><br><span class="line">trueif (func == NULL) &#123;</span><br><span class="line">truetrueerrs() &lt;&lt; &quot;找不到函数的定义：&quot;;</span><br><span class="line">truetrueerrs() &lt;&lt; node-&gt;getStr().c_str() &lt;&lt; &quot;\n&quot;;</span><br><span class="line">truetrueexit(1);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 其余参数 要传入的参数</span><br><span class="line">truestd::vector&lt;Value*&gt; args;</span><br><span class="line">truefor (Node* p = node-&gt;getNext(); p != NULL; p = p-&gt;getNext()) &#123;</span><br><span class="line">truetrueValue* v = p-&gt;codeGen(context);</span><br><span class="line">truetrueif (v != NULL)</span><br><span class="line">truetruetrueargs.push_back(v);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueCallInst *call = CallInst::Create(func, args, &quot;&quot;, context-&gt;getNowBlock());</span><br><span class="line">truereturn call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单运算符计算"><a href="#简单运算符计算" class="headerlink" title="简单运算符计算"></a>简单运算符计算</h2><p>对于计算机，加减乘除这些基本运算，就是几个指令而已，但对于编译器，却也要分好几种情况讨论，因为，全部的运算符有这么多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Standard binary operators...</span><br><span class="line"> FIRST_BINARY_INST( 8)</span><br><span class="line">HANDLE_BINARY_INST( 8, Add  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST( 9, FAdd , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(10, Sub  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(11, FSub , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(12, Mul  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(13, FMul , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(14, UDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(15, SDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(16, FDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(17, URem , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(18, SRem , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(19, FRem , BinaryOperator)</span><br><span class="line"></span><br><span class="line">// Logical operators (integer operands)</span><br><span class="line">HANDLE_BINARY_INST(20, Shl  , BinaryOperator) // Shift left  (logical)</span><br><span class="line">HANDLE_BINARY_INST(21, LShr , BinaryOperator) // Shift right (logical)</span><br><span class="line">HANDLE_BINARY_INST(22, AShr , BinaryOperator) // Shift right (arithmetic)</span><br><span class="line">HANDLE_BINARY_INST(23, And  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(24, Or   , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(25, Xor  , BinaryOperator)</span><br></pre></td></tr></table></figure></p>
<p>这些定义很难找，在文档中并没有真正写出来，而是在头文件的<code>llvm/IR/Instruction.def</code>里面，这是宏定义的专属部分。<br>这些还仅仅是数值运算，还不算比较运算的部分呢。</p>
<p>当然，这和计算机体系结构有关，浮点数的运算和整数肯定是不一样的，而我们知道，右移位也分算数右移和逻辑右移。所以必然，会有大量不同的运算符。</p>
<p>创建指令则很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static BinaryOperator * Create (BinaryOps Op, Value *S1, Value *S2, const Twine &amp;Name, BasicBlock *InsertAtEnd)</span><br></pre></td></tr></table></figure></p>
<p>两个运算数，可以是常量，也可以是变量load出值后，还可以是表达式返回值，只要两个Value调用getType，符合运算规则，就可以。<br>注意，浮点数不能直接和整数运算，必须先将整形转为浮点才可以。</p>
<p>于是以下是简单的运算符操作，我只写了整数的运算操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static Value* opt2_macro(CodeGenContext* context, Node* node) &#123;</span><br><span class="line">truestd::string opt = node-&gt;getStr();</span><br><span class="line"></span><br><span class="line">trueNode* op1 = (node = node-&gt;getNext());</span><br><span class="line">trueif (node == NULL) return NULL;</span><br><span class="line">trueNode* op2 = (node = node-&gt;getNext());</span><br><span class="line">trueif (node == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">trueInstruction::BinaryOps instr;</span><br><span class="line">trueif (opt == &quot;+&quot;) &#123; instr = Instruction::Add;  goto binOper; &#125;</span><br><span class="line">trueif (opt == &quot;-&quot;) &#123; instr = Instruction::Sub;  goto binOper; &#125;</span><br><span class="line">trueif (opt == &quot;*&quot;) &#123; instr = Instruction::Mul;  goto binOper; &#125;</span><br><span class="line">trueif (opt == &quot;/&quot;) &#123; instr = Instruction::SDiv; goto binOper; &#125;</span><br><span class="line"></span><br><span class="line">true// 未知运算符</span><br><span class="line">truereturn NULL;</span><br><span class="line"></span><br><span class="line">binOper:</span><br><span class="line">truereturn BinaryOperator::Create(instr, op1-&gt;codeGen(context), </span><br><span class="line">truetrueop2-&gt;codeGen(context), &quot;&quot;, context-&gt;getNowBlock());</span><br></pre></td></tr></table></figure>
<h2 id="附：文档参考及源代码"><a href="#附：文档参考及源代码" class="headerlink" title="附：文档参考及源代码"></a>附：文档参考及源代码</h2><p><a href="http://llvm.org/doxygen/classllvm_1_1CallInst.html" target="_blank" rel="external">CallInst类参考</a><br><a href="http://llvm.org/doxygen/classllvm_1_1BinaryOperator.html" target="_blank" rel="external">BinaryOperator类参考</a><br><a href="https://github.com/sunxfancy/RedApple/blob/master/src/Macro/Functions.cpp" target="_blank" rel="external">github源码-函数调用及基本运算符</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译器架构的王者LLVM——（7）函数的翻译方法]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85%E2%80%94%E2%80%94LLVM/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85LLVM%E2%80%94%E2%80%94%EF%BC%887%EF%BC%89%E5%87%BD%E6%95%B0%E7%9A%84%E7%BF%BB%E8%AF%91%E6%96%B9%E6%B3%95/"/>
    <id>http://sunxfancy.github.io/2016/03/28/编译器架构的王者——LLVM/编译器架构的王者LLVM——（7）函数的翻译方法/</id>
    <published>2016-03-28T15:45:02.475Z</published>
    <updated>2015-12-06T10:53:21.470Z</updated>
    <content type="html"><![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://blog.csdn.net/xfxyy_sxfancy" target="_blank" rel="external">http://blog.csdn.net/xfxyy_sxfancy</a></p>
<h1 id="函数的翻译方法"><a href="#函数的翻译方法" class="headerlink" title="函数的翻译方法"></a>函数的翻译方法</h1><p>前面介绍了许多编译器架构上面的特点，如何组织语法树、如果多遍扫描语法树。今天开始，我们就要设计本编译器中最核心的部分了，如何设计一个编译时宏，再利用LLVM按顺序生成模块。</p>
<h2 id="设计宏"><a href="#设计宏" class="headerlink" title="设计宏"></a>设计宏</h2><p>我们的编译器可以说是宏驱动的，因为我们扫描每个语法节点后，都会考察当前是不是一个合法的宏，例如我们来分析一下上一章的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void hello(int k, int g) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我暂时隐藏了函数体部分，让大家先关注一下函数头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String function</span><br><span class="line">      String void</span><br><span class="line">      String hello</span><br><span class="line">      Node</span><br><span class="line">          Node</span><br><span class="line">              String set</span><br><span class="line">              String int</span><br><span class="line">              String k</span><br><span class="line"></span><br><span class="line">          Node</span><br><span class="line">              String set</span><br><span class="line">              String int</span><br><span class="line">              String g</span><br><span class="line"></span><br><span class="line">      Node</span><br><span class="line">      	......</span><br></pre></td></tr></table></figure>
<p>我们的语法树的每一层相当于是链表组织的，通过next指针都可以找到下一个元素。<br>而语法树的开头部分，是一个“function”的宏名称，这个部分就是提示我们用哪个宏函数来翻译用的。</p>
<p>接下来的节点就是： 返回类型，函数名，参数表，函数体</p>
<p>例如参数表，里面的内容很多，但我们扫描时，它们是一个整体，进行识别。</p>
<p>所以我们的宏的形式实际上就是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function 返回类型 函数名 (形参表) (函数体))</span><br></pre></td></tr></table></figure>
<p>括号括起来的部分表示是一个列表，而不是一个元素。</p>
<h2 id="宏函数的编写"><a href="#宏函数的编写" class="headerlink" title="宏函数的编写"></a>宏函数的编写</h2><p>我们之前已经定义了宏的函数形式，我们需要传入的有我们自己的上下文类和当前要处理的Node节点，返回的是LLVM的Value类型（各个语句的抽象基类）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef Value* (*CodeGenFunction)(CodeGenContext*, Node*);</span><br></pre></td></tr></table></figure>
<p>于是我们将这个函数实现出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static Value* function_macro(CodeGenContext* context, Node* node) &#123;</span><br><span class="line">true// 第一个参数, 返回类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">true// 第二个参数, 函数名</span><br><span class="line">truenode = node-&gt;getNext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">true// 第三个参数, 参数表</span><br><span class="line">trueNode* args_node = node = node-&gt;getNext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">true// 第四个参数, 代码块</span><br><span class="line">truenode = node-&gt;getNext();</span><br><span class="line"></span><br><span class="line">truereturn F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取一个字符串代表的类型，往往不是一件容易的事，尤其在存在结构体和类的情况下，这时，我们往往需要查一下符号表，检查这个字符串是否为类型，以及是什么样的类型，是基本类型、结构体，还是函数指针或者指向其他结构的指针等等。<br>获取类型，往往是LLVM中非常重要的一步。</p>
<p>我们这里先写一下查符号表的接口，不做实现，接下来的章节中，我们会介绍经典的栈式符号表的实现。</p>
<p>第二个参数是函数名，我们将其保存在临时变量中待用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static Value* function_type_macro(CodeGenContext* context, Node* node) &#123;</span><br><span class="line">true// 第一个参数, 返回类型</span><br><span class="line">trueType* ret_type = context-&gt;FindType(node);</span><br><span class="line"></span><br><span class="line">true// 第二个参数, 函数名</span><br><span class="line">truenode = node-&gt;getNext();</span><br><span class="line">truestd::string function_name = node-&gt;getStr();</span><br><span class="line"></span><br><span class="line">true// 第三个参数, 参数表</span><br><span class="line">trueNode* args_node = node = node-&gt;getNext();</span><br><span class="line"></span><br><span class="line">true// 第四个参数, 代码块</span><br><span class="line">truenode = node-&gt;getNext();</span><br><span class="line"></span><br><span class="line">truereturn F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的参数表也许是很不好实现的一部分，因为其嵌套比较复杂，不过思路还好，就是不断的去扫描节点，这样我们就可以写出如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 第三个参数, 参数表</span><br><span class="line">Node* args_node = node = node-&gt;getNext();</span><br><span class="line">std::vector&lt;Type*&gt; type_vec;   // 类型列表</span><br><span class="line">std::vector&lt;std::string&gt; arg_name; // 参数名列表</span><br><span class="line">if (args_node-&gt;getChild() != NULL) &#123;</span><br><span class="line">truefor (Node* pC = args_node-&gt;getChild(); </span><br><span class="line">truetrue pC != NULL; pC = pC-&gt;getNext() ) </span><br><span class="line">true&#123;</span><br><span class="line">truetrueNode* pSec = pC-&gt;getChild()-&gt;getNext();</span><br><span class="line">truetrueType* t = context-&gt;FindType(pSec);</span><br><span class="line">truetruetype_vec.push_back(t);</span><br><span class="line">truetruearg_name.push_back(pSec-&gt;getNext()-&gt;getStr());	</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实有了前三个参数，我们就可以构建LLVM中的函数声明了，这样是不用写函数体代码的。<br>LLVM里很多对象都有这个特点，函数可以只声明函数头，解析完函数体后再将其填回去。结构体也一样，可以先声明符号，回头再向里填入类型信息。这些特性都是方便生成声明的实现，并且在多遍扫描的实现中也会显得很灵活。</p>
<p>我们下面来声明这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 先合成一个函数</span><br><span class="line">FunctionType *FT = FunctionType::get(ret_type, type_vec, </span><br><span class="line">true/*not vararg*/false);</span><br><span class="line"></span><br><span class="line">Module* M = context-&gt;getModule();</span><br><span class="line">Function *F = Function::Create(FT, Function::ExternalLinkage, </span><br><span class="line">truefunction_name, M);</span><br></pre></td></tr></table></figure>
<p>这里，我们使用了函数类型，这也是派生自Type的其中一个类，函数类型也可以getPointerTo来获取函数指针类型。<br>另外，如果构建函数时，添加了Function::ExternalLinkage参数，就相当于C语言的extern关键字，确定这个函数要导出符号。这样，你写的函数就能够被外部链接，或者作为外部函数的声明使用。</p>
<h2 id="函数的特殊问题"><a href="#函数的特殊问题" class="headerlink" title="函数的特殊问题"></a>函数的特殊问题</h2><p>接下来我们要创建函数的代码块，但这部分代码实际上和上面的不是在同一个函数中实现的，应该说，他们不是在一趟扫描中。<br>我们知道，如果要让一个函数内的代码块能够调用在任意位置声明的函数，那么我们就必须对所有函数都先处理刚才讲过的前三个参数，这样函数的声明就有了，在之后的正式扫描中，才有了如下的代码块生成部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 第四个参数, 代码块</span><br><span class="line">node = node-&gt;getNext();</span><br><span class="line">BasicBlock* bb = context-&gt;createBlock(F); // 创建新的Block</span><br><span class="line"></span><br><span class="line">// 特殊处理参数表, 这个地方特别坑，你必须给每个函数的参数</span><br><span class="line">// 手动AllocaInst开空间，再用StoreInst存一遍才行，否则一Load就报错</span><br><span class="line">// context-&gt;MacroMake(args_node-&gt;getChild());</span><br><span class="line">if (args_node-&gt;getChild() != NULL) &#123;</span><br><span class="line">truecontext-&gt;MacroMake(args_node);</span><br><span class="line">trueint i = 0;</span><br><span class="line">truefor (auto arg = F-&gt;arg_begin(); i != arg_name.size(); ++arg, ++i) &#123;</span><br><span class="line">truetruearg-&gt;setName(arg_name[i]);</span><br><span class="line">truetrueValue* argumentValue = arg;</span><br><span class="line">truetrueValueSymbolTable* st = bb-&gt;getValueSymbolTable();</span><br><span class="line">truetrueValue* v = st-&gt;lookup(arg_name[i]);</span><br><span class="line">truetruenew StoreInst(argumentValue, v, false, bb);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line">context-&gt;MacroMake(node);</span><br><span class="line"></span><br><span class="line">// 处理块结尾</span><br><span class="line">bb = context-&gt;getNowBlock();</span><br><span class="line">if (bb-&gt;getTerminator() == NULL)</span><br><span class="line">trueReturnInst::Create(*(context-&gt;getContext()), bb);</span><br><span class="line">return F;</span><br></pre></td></tr></table></figure>
<p>这个地方问题非常多，我先保留一个悬念，在接下来代码块和变量存储与加载的讲解中，我会再次提到这个部分的特殊处理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译器架构的王者LLVM——（6）多遍翻译的宏翻译系统]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85%E2%80%94%E2%80%94LLVM/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85LLVM%E2%80%94%E2%80%94%EF%BC%886%EF%BC%89%E5%A4%9A%E9%81%8D%E7%BF%BB%E8%AF%91%E7%9A%84%E5%AE%8F%E7%BF%BB%E8%AF%91%E7%B3%BB%E7%BB%9F/"/>
    <id>http://sunxfancy.github.io/2016/03/28/编译器架构的王者——LLVM/编译器架构的王者LLVM——（6）多遍翻译的宏翻译系统/</id>
    <published>2016-03-28T15:45:02.473Z</published>
    <updated>2015-12-06T10:53:18.863Z</updated>
    <content type="html"><![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://blog.csdn.net/xfxyy_sxfancy" target="_blank" rel="external">http://blog.csdn.net/xfxyy_sxfancy</a></p>
<h1 id="多遍翻译的宏翻译系统"><a href="#多遍翻译的宏翻译系统" class="headerlink" title="多遍翻译的宏翻译系统"></a>多遍翻译的宏翻译系统</h1><p>上次我们讨论了构建语法树的基本模型，我们能够利用Lex+Bison+Node,几个组件将我们的目标语法翻译成AST语法树了，在第四章，我们也给出了RedApple这款实现型小编译器的语法结构，那么我们的准备工作基于基本完成。</p>
<p>我们在搞定了AST语法树的构建后，需要有一种机制，能够遍历整棵语法树，然后将其翻译为LLVM的一个模块，然后再输出成.bc字节码。</p>
<p>这种机制我称其为多趟宏翻译系统，因为它要多次扫描整棵语法树，每次扫描需要的部分，然后构建整个模块。我希望能实现类似Java的语法特性，无需考虑定义顺序，只要定义了，那么就能够找到该符号。这样我们就需要合理的扫描顺序。</p>
<h2 id="扫描顺序的确定"><a href="#扫描顺序的确定" class="headerlink" title="扫描顺序的确定"></a>扫描顺序的确定</h2><p>首先，我们必须先扫描出所有的类型，因为类型的声明很重要，没有类型声明，就无法构建函数。<br>其次，我们要扫描出所有的函数，为其构建函数的声明。<br>最后，我们扫描出所有的函数定义，构建每个函数的函数体。</p>
<p>这样我们是三次扫描，无需担心效率问题，因为前两次扫描都是在根节点下一层，扫描的元素非常少，所以处理起来很快。</p>
<h2 id="待扫描的AST语法树"><a href="#待扫描的AST语法树" class="headerlink" title="待扫描的AST语法树"></a>待扫描的AST语法树</h2><p>这是我们之前生成好的AST语法树，结构还算清晰吧。我们能用的遍历手段也就是上次我们实现的next指针，然后不断的去判断当前节点的数据，然后对应的代码生成出来。</p>
<p>为了能够区分每条语句的含义，我在每个列表最前，都添加了翻译宏的名称，这个设计是仿照lisp做的，宏相当于是编译器中的函数，处理元数据，然后将其翻译成对应的内容。</p>
<p>例如这段代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> g)</span> </span>&#123;</span><br><span class="line">true<span class="keyword">int</span> y = k + g;</span><br><span class="line">true<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, y);</span><br><span class="line">true<span class="keyword">if</span> (k + g &lt; <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"right\n"</span>);</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">true<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">true<span class="keyword">while</span> (a &lt; k) &#123;</span><br><span class="line">truetrue<span class="built_in">printf</span>(<span class="string">"go-%d\n"</span>, a);</span><br><span class="line">truetruea = a + <span class="number">1</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">true<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i = i+<span class="number">1</span>) &#123;</span><br><span class="line">truetrue<span class="built_in">printf</span>(<span class="string">"hello-%d\n"</span>,i);</span><br><span class="line">true&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">truehello(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">trueprint(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其AST语法树如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">Node</span><br><span class="line">    Node</span><br><span class="line">        String function</span><br><span class="line">        String void</span><br><span class="line">        String hello</span><br><span class="line">        Node</span><br><span class="line">            Node</span><br><span class="line">                String set</span><br><span class="line">                String int</span><br><span class="line">                String k</span><br><span class="line"></span><br><span class="line">            Node</span><br><span class="line">                String set</span><br><span class="line">                String int</span><br><span class="line">                String g</span><br><span class="line"></span><br><span class="line">        Node</span><br><span class="line">            Node</span><br><span class="line">                String set</span><br><span class="line">                String int</span><br><span class="line">                String y</span><br><span class="line">                Node</span><br><span class="line">                    String opt2</span><br><span class="line">                    String +</span><br><span class="line">                    ID k</span><br><span class="line">                    ID g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Node</span><br><span class="line">                String call</span><br><span class="line">                String printf</span><br><span class="line">                String %d</span><br><span class="line"></span><br><span class="line">                ID y</span><br><span class="line"></span><br><span class="line">            Node</span><br><span class="line">                String if</span><br><span class="line">                Node</span><br><span class="line">                    String opt2</span><br><span class="line">                    String &lt;</span><br><span class="line">                    Node</span><br><span class="line">                        String opt2</span><br><span class="line">                        String +</span><br><span class="line">                        ID k</span><br><span class="line">                        ID g</span><br><span class="line"></span><br><span class="line">                    Int 5</span><br><span class="line"></span><br><span class="line">                Node</span><br><span class="line">                    String call</span><br><span class="line">                    String printf</span><br><span class="line">                    String right</span><br><span class="line"></span><br><span class="line">    Node</span><br><span class="line">        String function</span><br><span class="line">        String void</span><br><span class="line">        String go</span><br><span class="line">        Node</span><br><span class="line">            Node</span><br><span class="line">                String set</span><br><span class="line">                String int</span><br><span class="line">                String k</span><br><span class="line"></span><br><span class="line">        Node</span><br><span class="line">            Node</span><br><span class="line">                String set</span><br><span class="line">                String int</span><br><span class="line">                String a</span><br><span class="line">                Int 0</span><br><span class="line"></span><br><span class="line">            Node</span><br><span class="line">                String while</span><br><span class="line">                Node</span><br><span class="line">                    String opt2</span><br><span class="line">                    String &lt;</span><br><span class="line">                    ID a</span><br><span class="line">                    ID k</span><br><span class="line"></span><br><span class="line">                Node</span><br><span class="line">                    Node</span><br><span class="line">                        String call</span><br><span class="line">                        String printf</span><br><span class="line">                        String go-%d</span><br><span class="line"></span><br><span class="line">                        ID a</span><br><span class="line"></span><br><span class="line">                    Node</span><br><span class="line">                        String opt2</span><br><span class="line">                        String =</span><br><span class="line">                        ID a</span><br><span class="line">                        Node</span><br><span class="line">                            String opt2</span><br><span class="line">                            String +</span><br><span class="line">                            ID a</span><br><span class="line">                            Int 1</span><br><span class="line"></span><br><span class="line">    Node</span><br><span class="line">        String function</span><br><span class="line">        String void</span><br><span class="line">        String print</span><br><span class="line">        Node</span><br><span class="line">            Node</span><br><span class="line">                String set</span><br><span class="line">                String int</span><br><span class="line">                String k</span><br><span class="line"></span><br><span class="line">        Node</span><br><span class="line">            Node</span><br><span class="line">                String for</span><br><span class="line">                Node</span><br><span class="line">                    String set</span><br><span class="line">                    String int</span><br><span class="line">                    String i</span><br><span class="line">                    Int 0</span><br><span class="line"></span><br><span class="line">                Node</span><br><span class="line">                    String opt2</span><br><span class="line">                    String &lt;</span><br><span class="line">                    ID i</span><br><span class="line">                    Int 10</span><br><span class="line"></span><br><span class="line">                Node</span><br><span class="line">                    String opt2</span><br><span class="line">                    String =</span><br><span class="line">                    ID i</span><br><span class="line">                    Node</span><br><span class="line">                        String opt2</span><br><span class="line">                        String +</span><br><span class="line">                        ID i</span><br><span class="line">                        Int 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                Node</span><br><span class="line">                    Node</span><br><span class="line">                        String call</span><br><span class="line">                        String printf</span><br><span class="line">                        String hello-%d</span><br><span class="line"></span><br><span class="line">                        ID i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node</span><br><span class="line">        String function</span><br><span class="line">        String void</span><br><span class="line">        String main</span><br><span class="line">        Node</span><br><span class="line">        Node</span><br><span class="line">            Node</span><br><span class="line">                String call</span><br><span class="line">                String printf</span><br><span class="line">                String hello world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Node</span><br><span class="line">                String call</span><br><span class="line">                String hello</span><br><span class="line">                Int 1</span><br><span class="line">                Int 2</span><br><span class="line"></span><br><span class="line">            Node</span><br><span class="line">                String call</span><br><span class="line">                String print</span><br><span class="line">                Int 9</span><br></pre></td></tr></table></figure></p>
<h2 id="扫描中的上下文"><a href="#扫描中的上下文" class="headerlink" title="扫描中的上下文"></a>扫描中的上下文</h2><p>由于翻译过程中，我们还需要LLVMContext变量，符号表，宏定义表等必要信息，我们还需要自己实现一个上下文类，来存储必要的信息，上下文类需要在第一遍扫描前就初始化好。</p>
<p>例如我们在翻译中，遇到了一个变量，那么该变量是临时的还是全局的呢？是什么类型，都需要我们在符号表中存储表达，另外当前翻译的语句是属于哪条宏，该怎么翻译？我们必须有一个类来保存这些信息。</p>
<p>于是我们先不谈实现，将接口写出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CodeGenContext;</span><br><span class="line"><span class="keyword">typedef</span> Value* (*CodeGenFunction)(CodeGenContext*, Node*);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _funcReg</span><br><span class="line">&#123;</span><br><span class="line">true<span class="keyword">const</span> <span class="keyword">char</span>*     name;</span><br><span class="line">trueCodeGenFunction func;</span><br><span class="line">&#125; FuncReg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> CodeGenContext</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">trueCodeGenContext(Node* node);</span><br><span class="line">true~CodeGenContext();</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 必要的初始化方法</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">PreInit</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">PreTypeInit</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">MakeBegin</span><span class="params">()</span> </span>&#123; </span><br><span class="line">truetrueMacroMake(root); </span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 这个函数是用来一条条翻译Node宏的</span></span><br><span class="line">true<span class="function">Value* <span class="title">MacroMake</span><span class="params">(Node* node)</span></span>;</span><br><span class="line">true<span class="comment">// 递归翻译该节点下的所有宏</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">MacroMakeAll</span><span class="params">(Node* node)</span></span>; </span><br><span class="line">true<span class="function">CodeGenFunction <span class="title">getMacro</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// C++注册宏</span></span><br><span class="line">true<span class="comment">// void AddMacros(const FuncReg* macro_funcs); // 为只添加不替换保留</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">AddOrReplaceMacros</span><span class="params">(<span class="keyword">const</span> FuncReg* macro_funcs)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 代码块栈的相关操作</span></span><br><span class="line">true<span class="function">BasicBlock* <span class="title">getNowBlock</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function">BasicBlock* <span class="title">createBlock</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function">BasicBlock* <span class="title">createBlock</span><span class="params">(Function* f)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 获取当前模块中已注册的函数</span></span><br><span class="line">true<span class="function">Function* <span class="title">getFunction</span><span class="params">(Node* node)</span></span>;</span><br><span class="line">true<span class="function">Function* <span class="title">getFunction</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">nowFunction</span><span class="params">(Function* _nowFunc)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">setModule</span><span class="params">(Module* pM)</span> </span>&#123; M = pM; &#125;</span><br><span class="line">true<span class="function">Module* <span class="title">getModule</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> M; &#125;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">setContext</span><span class="params">(LLVMContext* pC)</span> </span>&#123; Context = pC; &#125;</span><br><span class="line">true<span class="function">LLVMContext* <span class="title">getContext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Context; &#125;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 类型的定义和查找</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">DefType</span><span class="params">(<span class="built_in">string</span> name, Type* t)</span></span>;</span><br><span class="line">true<span class="function">Type* <span class="title">FindType</span><span class="params">(<span class="built_in">string</span>&amp; name)</span></span>;</span><br><span class="line">true<span class="function">Type* <span class="title">FindType</span><span class="params">(Node*)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">SaveMacros</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">RecoverMacros</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="keyword">bool</span> <span class="title">isSave</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _save; &#125;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">setIsSave</span><span class="params">(<span class="keyword">bool</span> save)</span> </span>&#123; _save = save; &#125;</span><br><span class="line"></span><br><span class="line">true<span class="function">id* <span class="title">FindST</span><span class="params">(Node* node)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="function">id* <span class="title">FindST</span><span class="params">(<span class="built_in">string</span>&amp; str)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">truetrue<span class="keyword">return</span> st-&gt;find(str);</span><br><span class="line">true&#125;</span><br><span class="line">trueIDTable* st;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">true<span class="comment">// 语法树根节点</span></span><br><span class="line">trueNode* root;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 当前的LLVM Module</span></span><br><span class="line">trueModule* M;</span><br><span class="line">trueLLVMContext* Context;</span><br><span class="line">trueFunction* nowFunc;</span><br><span class="line">trueBasicBlock* nowBlock;</span><br><span class="line">true</span><br><span class="line">true<span class="comment">// 这是用来查找是否有该宏定义的</span></span><br><span class="line">true<span class="built_in">map</span>&lt;<span class="built_in">string</span>, CodeGenFunction&gt; macro_map;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 这个栈是用来临时保存上面的查询表的</span></span><br><span class="line">true<span class="built_in">stack</span>&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, CodeGenFunction&gt; &gt; macro_save_stack;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">setNormalType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 用来记录当前是读取还是存入状态</span></span><br><span class="line">true<span class="keyword">bool</span> _save;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="宏的注册"><a href="#宏的注册" class="headerlink" title="宏的注册"></a>宏的注册</h2><p>宏是内部的非常重要的函数，本身是一个C函数指针，宏有唯一的名字，通过map表，去查找该宏对应的函数，然后调用其对当前的语法节点进行解析。</p>
<p>宏函数的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef Value* (*CodeGenFunction)(CodeGenContext*, Node*);</span><br></pre></td></tr></table></figure></p>
<p>注册我是仿照lua的方式设计的，将函数指针组织成数组，然后初始化进入结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">extern const FuncReg macro_funcs[] = &#123;</span><br><span class="line">true&#123;&quot;function&quot;, function_macro&#125;,</span><br><span class="line">true&#123;&quot;struct&quot;,   struct_macro&#125;,</span><br><span class="line">true&#123;&quot;set&quot;,      set_macro&#125;,</span><br><span class="line">true&#123;&quot;call&quot;,     call_macro&#125;,</span><br><span class="line">true&#123;&quot;opt2&quot;,     opt2_macro&#125;,</span><br><span class="line">true&#123;&quot;for&quot;,      for_macro&#125;,</span><br><span class="line">true&#123;&quot;while&quot;,    while_macro&#125;,</span><br><span class="line">true&#123;&quot;if&quot;,       if_macro&#125;,</span><br><span class="line">true&#123;&quot;return&quot;,   return_macro&#125;,</span><br><span class="line">true&#123;&quot;new&quot;,      new_macro&#125;,</span><br><span class="line">true&#123;NULL, NULL&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样写是为了方便我们一次就导入一批函数进入我们的系统。函数指针我还是习惯使用C指针，一般避免使用C++的成员指针，那样太复杂，而且不容易和其他模块链接，因为C++是没有标准ABI的，但C语言有。</p>
<h2 id="实现扫描的引导"><a href="#实现扫描的引导" class="headerlink" title="实现扫描的引导"></a>实现扫描的引导</h2><p>扫描其实很简单了，如果当前节点是个字符串，而且在宏定义中能够找到，那么我们就调用这条宏来处理，否则如果是列表的化，就对每一条分别递归处理。</p>
<p>宏的查找我直接使用了stl模版库中的map和string，非常的方便。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Value* CodeGenContext::MacroMake(Node* node) &#123;</span><br><span class="line">true<span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">if</span> (node-&gt;isStringNode()) &#123;</span><br><span class="line">truetrueStringNode* str_node = (StringNode*)node;</span><br><span class="line">truetrueCodeGenFunction func = getMacro(str_node-&gt;getStr());</span><br><span class="line">truetrue<span class="keyword">if</span> (func != <span class="literal">NULL</span>) &#123;</span><br><span class="line">truetruetrue<span class="keyword">return</span> func(<span class="keyword">this</span>, node-&gt;getNext());</span><br><span class="line">truetrue&#125; </span><br><span class="line">truetrue<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">true&#125; </span><br><span class="line">true<span class="keyword">if</span> (node-&gt;getChild() != <span class="literal">NULL</span> &amp;&amp; node-&gt;getChild()-&gt;isStringNode())</span><br><span class="line">truetrue<span class="keyword">return</span> MacroMake(node-&gt;getChild());</span><br><span class="line">trueValue* ans;</span><br><span class="line">true<span class="keyword">for</span> (Node* p = node-&gt;getChild(); p != <span class="literal">NULL</span>; p = p-&gt;getNext()) </span><br><span class="line">truetrueans = MacroMake(p);</span><br><span class="line">true<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CodeGenFunction CodeGenContext::getMacro(<span class="built_in">string</span>&amp; str) &#123;</span><br><span class="line">true<span class="keyword">auto</span> func = macro_map.find(str);</span><br><span class="line">true<span class="keyword">if</span> (func != macro_map.end()) <span class="keyword">return</span> func-&gt;second;</span><br><span class="line">true<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译器架构的王者LLVM——（5）语法树模型的基本结构]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85%E2%80%94%E2%80%94LLVM/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85LLVM%E2%80%94%E2%80%94%EF%BC%885%EF%BC%89%E8%AF%AD%E6%B3%95%E6%A0%91%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <id>http://sunxfancy.github.io/2016/03/28/编译器架构的王者——LLVM/编译器架构的王者LLVM——（5）语法树模型的基本结构/</id>
    <published>2016-03-28T15:45:02.472Z</published>
    <updated>2015-12-06T10:53:12.328Z</updated>
    <content type="html"><![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://blog.csdn.net/xfxyy_sxfancy" target="_blank" rel="external">http://blog.csdn.net/xfxyy_sxfancy</a></p>
<h1 id="语法树模型的基本结构"><a href="#语法树模型的基本结构" class="headerlink" title="语法树模型的基本结构"></a>语法树模型的基本结构</h1><p>上次我们看了Lex和Yacc的翻译文件，可能一些朋友并不了解其中的执行部分，而且，对这个抽象语法树是怎么构建起来的还不清楚。今天我们就再详细介绍一下如果方便的构建一棵抽象语法树（AST）</p>
<h2 id="Node节点链接的左孩子，右兄弟二叉树"><a href="#Node节点链接的左孩子，右兄弟二叉树" class="headerlink" title="Node节点链接的左孩子，右兄弟二叉树"></a>Node节点链接的左孩子，右兄弟二叉树</h2><p>AST语法树，由于是一棵多叉树，直接表示不大好弄，所以我们采用计算机树中的一个经典转换，将多叉树转换为左孩子右兄弟的二叉树。</p>
<p><img src="img/3/zhyx.jpg" alt=""></p>
<p>其实思路很简单，每一层其实就是一个链表，将兄弟节点串起来，这样就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">trueNode();</span><br><span class="line">trueNode(Node* n);</span><br><span class="line">true~Node();</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 构建列表部分</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">addChildren</span><span class="params">(Node* n)</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">addBrother</span> <span class="params">(Node* n)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="keyword">static</span> Node* <span class="title">make_list</span><span class="params">(<span class="keyword">int</span> num, ...)</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">static</span> Node* <span class="title">getList</span><span class="params">(Node* node)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="function">Node* <span class="title">getNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> next; &#125;</span><br><span class="line">true<span class="function">Node* <span class="title">getChild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> child; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">trueNode* next;</span><br><span class="line">trueNode* child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>于是我们构建一个Node类，这就是上次我们脚本中看到的那个节点类。是不是很简单呢？<br>另外我们在写个make_list，方便我们构造一个链表，至于怎么写，我们一会儿再谈。</p>
<h2 id="类型支持"><a href="#类型支持" class="headerlink" title="类型支持"></a>类型支持</h2><p>我们发现，我们的语法树还不能保存任何数据，我们写AST，是为了在每个节点上存储数据的，有字符串、字符、整数、浮点数、标识符等等。</p>
<p>而且不但有这个要求，更重要的是语法树能够方便的构造LLVM语句，所以方便的一个设计就是利用多态，虽然效率或内存占用不像用union那么实在，但确实比较方便。</p>
<p>于是我们建立了一堆类，分别从Node派生，当然Node也需要添加一些功能来判断当前的节点类型。</p>
<p>Node.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> NodeType <span class="comment">// 类型枚举</span></span><br><span class="line">&#123;</span><br><span class="line">true<span class="keyword">node_t</span> = <span class="number">0</span>, <span class="keyword">int_node_t</span>, <span class="keyword">float_node_t</span>, <span class="keyword">char_node_t</span>, <span class="keyword">id_node_t</span>, <span class="keyword">string_node_t</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> CodeGenContext;</span><br><span class="line"><span class="keyword">class</span> Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">trueNode();</span><br><span class="line">trueNode(Node* n); <span class="comment">// 直接将n作为孩子加入这个节点下</span></span><br><span class="line">true~Node();</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 构建列表部分</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">addChildren</span><span class="params">(Node* n)</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">addBrother</span> <span class="params">(Node* n)</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">bool</span> <span class="title">isSingle</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">static</span> Node* <span class="title">make_list</span><span class="params">(<span class="keyword">int</span> num, ...)</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">static</span> Node* <span class="title">getList</span><span class="params">(Node* node)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> k)</span></span>; <span class="comment">// 打印当前节点</span></span><br><span class="line">true<span class="function">Node* <span class="title">getNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> next; &#125;</span><br><span class="line">true<span class="function">Node* <span class="title">getChild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> child; &#125;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> Value* <span class="title">codeGen</span><span class="params">(CodeGenContext* context)</span></span>;  LLVM的代码生成</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 这里负责获取或设置当前节点的LLVM类型, 未知类型返回NULL</span></span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> Type* <span class="title">getLLVMType</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">setLLVMType</span><span class="params">(Type* t)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 如果是含有字符串的节点，则返回所含字符串，否则将报错</span></span><br><span class="line">true<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getStr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 类型相关</span></span><br><span class="line">true<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getTypeName</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> NodeType <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">bool</span> <span class="title">isNode</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">bool</span> <span class="title">isIntNode</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">bool</span> <span class="title">isFloatNode</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">bool</span> <span class="title">isIDNode</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">bool</span> <span class="title">isStringNode</span><span class="params">()</span></span>;</span><br><span class="line">true<span class="function"><span class="keyword">bool</span> <span class="title">isCharNode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printSelf</span><span class="params">()</span></span>; <span class="comment">// 打印自己的名字</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">trueType* llvm_type;</span><br><span class="line">trueNode* next;</span><br><span class="line">trueNode* child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>IDNode.h 是我们的标识符类，就继承自Node，其他类型同理，我就不一一列举，详细代码请参考 <a href="https://github.com/sunxfancy/RedApple" target="_blank" rel="external">github上的源码</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"Node.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> IDNode: <span class="keyword">public</span> Node &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">trueIDNode(<span class="keyword">const</span> <span class="keyword">char</span>* _value)&#123;</span><br><span class="line">truetrue<span class="keyword">this</span>-&gt;value = _value;</span><br><span class="line">true&#125;</span><br><span class="line">trueIDNode(<span class="keyword">char</span> _value)&#123;</span><br><span class="line">truetrue<span class="keyword">this</span>-&gt;value = _value;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getStr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> Value* <span class="title">codeGen</span><span class="params">(CodeGenContext* context)</span></span>; </span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> NodeType <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">true<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printSelf</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">true<span class="built_in">string</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="AST构建中的一个问题"><a href="#AST构建中的一个问题" class="headerlink" title="AST构建中的一个问题"></a>AST构建中的一个问题</h2><p>语法树构建时，有一个特别的问题，主要是因为这里有个地方设计的不大好，我没有单独做一个List类型，来存储孩子元素，而是将其直接打包到Node中了。那么当前正等待构建的节点，是一个元素，还是一个元素列表就很难判断。于是我制作了一个isSingle函数来判断当前元素是不是单独的元素，方法就是检测其Next指针是否为空即可。如果是单一元素，构建列表时，可以将其直接插入到当前序列的末尾，如果不是，则新建一个Node节点，然后将其孩子指针指向待插入元素。</p>
<p>于是我们的make_list和getList函数就是这样写出来的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node* Node::make_list(<span class="keyword">int</span> num, ...) &#123;</span><br><span class="line">trueva_list argp; Node* para = <span class="literal">NULL</span>;  </span><br><span class="line">trueNode* ans = <span class="literal">NULL</span>;  </span><br><span class="line">trueva_start( argp, num );    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;    </span><br><span class="line">        para = va_arg( argp, Node* );  </span><br><span class="line">        <span class="keyword">if</span> (!para-&gt;isSingle()) para = <span class="keyword">new</span> Node(para);</span><br><span class="line">        <span class="keyword">if</span> ( ans == <span class="literal">NULL</span> )    </span><br><span class="line">        	ans = para;</span><br><span class="line">        <span class="keyword">else</span> ans-&gt;addBrother(para);</span><br><span class="line">    &#125;    </span><br><span class="line">    va_end( argp );</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* Node::getList(Node* node) &#123;</span><br><span class="line">true<span class="keyword">if</span> (!node-&gt;isSingle()) <span class="keyword">return</span> <span class="keyword">new</span> Node(node);</span><br><span class="line">true<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基本的LLVM语句生成"><a href="#基本的LLVM语句生成" class="headerlink" title="基本的LLVM语句生成"></a>基本的LLVM语句生成</h2><p>我们构建这么多类的目的是用其生成LLVM语句的，那么我们就先来生成几个简单的语句</p>
<p>首先要介绍的是LLVM类型系统的使用，因为LLVM的每条语句都是带有类型的，LLVM语句可以转换成Value型指针，那么我们用如下的方法就可以获取到当前的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type* t = value-&gt;getType();</span><br></pre></td></tr></table></figure>
<p>Type类型也很容易使用，例如获取其指针就可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PointerType* ptr_type = t-&gt;getPointerTo();</span><br></pre></td></tr></table></figure></p>
<p>Type类型中还有很多静态函数可供生成基本类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 获取基本类型</span><br><span class="line">static Type * 	getVoidTy (LLVMContext &amp;C) </span><br><span class="line">static Type * 	getFloatTy (LLVMContext &amp;C) </span><br><span class="line">static Type * 	getDoubleTy (LLVMContext &amp;C)</span><br><span class="line">static Type * 	getMetadataTy (LLVMContext &amp;C)</span><br><span class="line"></span><br><span class="line">// 获取不同长度整形类型</span><br><span class="line">static IntegerType * 	getInt8Ty (LLVMContext &amp;C)</span><br><span class="line">static IntegerType * 	getInt16Ty (LLVMContext &amp;C)</span><br><span class="line">static IntegerType * 	getInt32Ty (LLVMContext &amp;C)</span><br><span class="line">static IntegerType * 	getInt64Ty (LLVMContext &amp;C)</span><br><span class="line"></span><br><span class="line">// 获取指向不同类型的指针类型</span><br><span class="line">static PointerType * 	getFloatPtrTy (LLVMContext &amp;C, unsigned AS=0)</span><br><span class="line">static PointerType * 	getDoublePtrTy (LLVMContext &amp;C, unsigned AS=0)</span><br><span class="line">static PointerType * 	getInt8PtrTy (LLVMContext &amp;C, unsigned AS=0)</span><br><span class="line">static PointerType * 	getInt16PtrTy (LLVMContext &amp;C, unsigned AS=0)</span><br><span class="line">static PointerType * 	getInt32PtrTy (LLVMContext &amp;C, unsigned AS=0)</span><br><span class="line">static PointerType * 	getInt64PtrTy (LLVMContext &amp;C, unsigned AS=0)</span><br></pre></td></tr></table></figure></p>
<p>我们刚才AST语法树中的基本类型，其实都是语法中的常量（除了IDNode)，那么这些都应该是生成常量类型<br>常量类型的基类是Constant，而常用的一般是ConstantInt、ConstantFP和ConstantExpr</p>
<p>下面我们就直接写出整形、全局字符串、浮点数对应的LLVM代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Value* IntNode::codeGen(CodeGenContext* context) &#123;</span><br><span class="line">    Type* t = Type::getInt64Ty(*(context-&gt;getContext()));</span><br><span class="line">    setLLVMType(t);</span><br><span class="line">true<span class="keyword">return</span> ConstantInt::get(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value* FloatNode::codeGen(CodeGenContext* context) &#123;</span><br><span class="line">    Type* t = Type::getFloatTy(*(context-&gt;getContext()));</span><br><span class="line">    setLLVMType(t);</span><br><span class="line">true<span class="keyword">return</span> ConstantFP::get(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value* StringNode::codeGen(CodeGenContext* context) &#123;</span><br><span class="line">    Module* M = context-&gt;getModule();</span><br><span class="line">    LLVMContext&amp; ctx = M-&gt;getContext(); <span class="comment">// 千万别用Global Context</span></span><br><span class="line">    Constant* strConstant = ConstantDataArray::getString(ctx, value);</span><br><span class="line">    Type* t = strConstant-&gt;getType();</span><br><span class="line">    setLLVMType(t);</span><br><span class="line">    GlobalVariable* GVStr = <span class="keyword">new</span> GlobalVariable(*M, t, <span class="literal">true</span>,</span><br><span class="line">                            GlobalValue::InternalLinkage, strConstant, <span class="string">""</span>);</span><br><span class="line">    Constant* zero = Constant::getNullValue(IntegerType::getInt32Ty(ctx));</span><br><span class="line">    Constant* indices[] = &#123;zero, zero&#125;;</span><br><span class="line">    Constant* strVal = ConstantExpr::getGetElementPtr(GVStr, indices, <span class="literal">true</span>);</span><br><span class="line">true<span class="keyword">return</span> strVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最复杂的应该就属常量字符串了，首先，常量字符串要用ConstantDataArray::getString类型，然而，往往函数却不接收一个字符串类型的变量，你需要像C语言一样，将它的首地址作为参数传进去，记得我们之前写过的printf函数的定义么？第一个参数就是一个char*指针。</p>
<p>所以我们这里用一条语句，ConstantExpr::getGetElementPtr，对其取地址，indices是一个数组，第一个值是假设指针是个数组，取数组的第几位的地址，第二个值是假设指针指向的是一个结构体，取结构体中第几条元素的地址。</p>
<p>这里我们都传常量0就可以了。另外一个需要注意的是，这里取地址的常量0好像不能用int64类型，大概是数据范围太大怕越界吧，一般int32长的数组也够用了。之前我没注意，用int64，总出莫名其妙的问题。</p>
<h2 id="附：-Node类的完整实现"><a href="#附：-Node类的完整实现" class="headerlink" title="附： Node类的完整实现"></a>附： Node类的完整实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">* @Author: sxf</span><br><span class="line">* @Date:   2015-09-22 19:21:40</span><br><span class="line">* @Last Modified by:   sxf</span><br><span class="line">* @Last Modified time: 2015-11-01 21:05:14</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &quot;Node.h&quot;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;nodes.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void Node::init() &#123;</span><br><span class="line">truellvm_type = NULL;</span><br><span class="line">truenext = child = NULL; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node::Node() &#123;</span><br><span class="line">trueinit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node::Node(Node* n) &#123;</span><br><span class="line">trueinit();</span><br><span class="line">trueaddChildren(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node::~Node() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Node::addChildren(Node* n) &#123;</span><br><span class="line">trueif (child == NULL) &#123;</span><br><span class="line">truetruechild = n;</span><br><span class="line">true&#125; else &#123;</span><br><span class="line">truetruechild-&gt;addBrother(n);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Node::addBrother (Node* n) &#123;</span><br><span class="line">trueNode* p = this;</span><br><span class="line">truewhile (p-&gt;next != NULL) &#123;</span><br><span class="line">truetruep = p-&gt;next;</span><br><span class="line">true&#125;</span><br><span class="line">truep-&gt;next = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Node::print(int k) &#123;</span><br><span class="line">truefor (int i = 0; i &lt; k; ++i)</span><br><span class="line">truetrueprintf(&quot;    &quot;);</span><br><span class="line">trueprintSelf();</span><br><span class="line">trueprintf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">trueNode* p = child; int t = 0;</span><br><span class="line">truewhile (p != NULL) &#123;</span><br><span class="line">truetruep-&gt;print(k+1);</span><br><span class="line">truetruep = p-&gt;next;</span><br><span class="line">truetrue++t;</span><br><span class="line">true&#125;</span><br><span class="line">trueif (t &gt;= 3) printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Node::printSelf() &#123;</span><br><span class="line">trueprintf(&quot;Node&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NodeType Node::getType() &#123;</span><br><span class="line">truereturn node_t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Node::isSingle() &#123;</span><br><span class="line">truereturn next == NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* Node::make_list(int num, ...) &#123;</span><br><span class="line">trueva_list argp; Node* para = NULL;  </span><br><span class="line">trueNode* ans = NULL;  </span><br><span class="line">trueva_start( argp, num );    </span><br><span class="line">    for (int i = 0; i &lt; num; ++i) &#123;    </span><br><span class="line">        para = va_arg( argp, Node* );  </span><br><span class="line">        if (!para-&gt;isSingle()) para = new Node(para);</span><br><span class="line">        if ( ans == NULL )    </span><br><span class="line">        	ans = para;</span><br><span class="line">        else ans-&gt;addBrother(para);</span><br><span class="line">    &#125;    </span><br><span class="line">    va_end( argp );</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* Node::getList(Node* node) &#123;</span><br><span class="line">trueif (!node-&gt;isSingle()) return new Node(node);</span><br><span class="line">truereturn node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Type* Node::getLLVMType() &#123;</span><br><span class="line">truereturn llvm_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  Node::setLLVMType(Type* t) &#123;</span><br><span class="line">truellvm_type = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Node::isNode() &#123;</span><br><span class="line">truereturn getType() == node_t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Node::isIntNode() &#123;</span><br><span class="line">truereturn getType() == int_node_t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Node::isFloatNode() &#123;</span><br><span class="line">truereturn getType() == float_node_t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Node::isIDNode() &#123;</span><br><span class="line">truereturn getType() == id_node_t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Node::isStringNode() &#123;</span><br><span class="line">truereturn getType() == string_node_t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Node::isCharNode() &#123;</span><br><span class="line">truereturn getType() == char_node_t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string Node::getTypeName() &#123;</span><br><span class="line">trueswitch (getType()) &#123;</span><br><span class="line">truetruecase node_t: return &quot;Node&quot;;</span><br><span class="line">truetruecase int_node_t: return &quot;IntNode&quot;;</span><br><span class="line">truetruecase string_node_t: return &quot;StringNode&quot;;</span><br><span class="line">truetruecase id_node_t: return &quot;IDNode&quot;;</span><br><span class="line">truetruecase char_node_t: return &quot;CharNode&quot;;</span><br><span class="line">truetruecase float_node_t: return &quot;FloatNode&quot;;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string&amp; Node::getStr() &#123;</span><br><span class="line">trueif (this-&gt;isStringNode()) &#123;</span><br><span class="line">truetrueStringNode* string_this = (StringNode*)this;</span><br><span class="line">truetruereturn string_this-&gt;getStr();</span><br><span class="line">true&#125; </span><br><span class="line">trueif (this-&gt;isIDNode()) &#123;</span><br><span class="line">truetrueIDNode* string_this = (IDNode*)this;</span><br><span class="line">truetruereturn string_this-&gt;getStr();</span><br><span class="line">true&#125; </span><br><span class="line">truestd::cerr &lt;&lt; &quot;getStr() - 获取字符串错误, 该类型不正确：&quot; &lt;&lt; getTypeName() &lt;&lt; std::endl;</span><br><span class="line">trueexit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译器架构的王者LLVM——（4）简单的词法和语法分析]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85%E2%80%94%E2%80%94LLVM/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85LLVM%E2%80%94%E2%80%94%EF%BC%884%EF%BC%89%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%8D%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://sunxfancy.github.io/2016/03/28/编译器架构的王者——LLVM/编译器架构的王者LLVM——（4）简单的词法和语法分析/</id>
    <published>2016-03-28T15:45:02.470Z</published>
    <updated>2015-12-06T10:53:09.561Z</updated>
    <content type="html"><![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://blog.csdn.net/xfxyy_sxfancy" target="_blank" rel="external">http://blog.csdn.net/xfxyy_sxfancy</a></p>
<h2 id="简单的词法和语法分析"><a href="#简单的词法和语法分析" class="headerlink" title="简单的词法和语法分析"></a>简单的词法和语法分析</h2><p>Lex和Yacc真是太好用了，非常方便我们构建一门语言的分析程序。</p>
<p>如果你对Lex和Yacc不了解的话，建议先看下我之前写的两篇文章，分别介绍了Lex和Yacc的用法。</p>
<p>Lex识别C风格字符串和注释<br><a href="http://blog.csdn.net/xfxyy_sxfancy/article/details/45024573" target="_blank" rel="external">http://blog.csdn.net/xfxyy_sxfancy/article/details/45024573</a></p>
<p>创造新语言（2）——用Lex&amp;Yacc构建简单的分析程序<br><a href="http://blog.csdn.net/xfxyy_sxfancy/article/details/45046465" target="_blank" rel="external">http://blog.csdn.net/xfxyy_sxfancy/article/details/45046465</a></p>
<h3 id="FLex创建一门语言的词法分析程序"><a href="#FLex创建一门语言的词法分析程序" class="headerlink" title="FLex创建一门语言的词法分析程序"></a>FLex创建一门语言的词法分析程序</h3><p>我们创建的是一门编程语言，那么词法分析程序就不能像做实验一样那么草率，必须考虑周全，一般一门语言的词法分析程序大概需要囊括如下的几个方面：</p>
<p>识别关键字、识别标识符、识别基本常量（数字、浮点数、字符串、字符）、识别注释、识别运算符</p>
<p>这些都是非常重要的，而且是一门语言语法中必不可少的部分。</p>
<p>于是RedApple的词法分析部分，我就设计成了这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &quot;Model/nodes.h&quot;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &quot;redapple_parser.hpp&quot;</span><br><span class="line">#include &quot;StringEscape.h&quot;</span><br><span class="line"></span><br><span class="line">#define SAVE_TOKEN     yylval.str = maketoken(yytext, yyleng)</span><br><span class="line">#define SAVE_STRING    yylval.str = makestring(yytext, yyleng, 2)</span><br><span class="line">#define SAVE_STRING_NC yylval.str = makestring(yytext, yyleng, 3)</span><br><span class="line">extern &quot;C&quot; int yywrap() &#123; return 1; &#125;</span><br><span class="line">char* maketoken(const char* data, int len);</span><br><span class="line">char* makestring(const char* data, int len, int s);</span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%option yylineno</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&quot;/*&quot;([^\*]|(\*)*[^\*/])*(\*)*&quot;*/&quot; ; /* 就是这种注释 */ </span><br><span class="line"></span><br><span class="line">#[^\n]*\n               ; /* 井号注释 */ </span><br><span class="line">&quot;//&quot;[^\n]*\n            ; /* 双线注释 */ </span><br><span class="line"></span><br><span class="line">[ \t\v\n\f]             ; /* 过滤空白字符 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;==&quot;                    return CEQ;</span><br><span class="line">&quot;&lt;=&quot;                    return CLE;</span><br><span class="line">&quot;&gt;=&quot;                    return CGE;</span><br><span class="line">&quot;!=&quot;                    return CNE;</span><br><span class="line"></span><br><span class="line">&quot;&lt;&quot;                     return &apos;&lt;&apos;;</span><br><span class="line">&quot;=&quot;                     return &apos;=&apos;;</span><br><span class="line">&quot;&gt;&quot;                     return &apos;&gt;&apos;;</span><br><span class="line">&quot;(&quot;                     return &apos;(&apos;;</span><br><span class="line">&quot;)&quot;                     return &apos;)&apos;;</span><br><span class="line">&quot;[&quot;                     return &apos;[&apos;;</span><br><span class="line">&quot;]&quot;                     return &apos;]&apos;;</span><br><span class="line">&quot;&#123;&quot;                     return &apos;&#123;&apos;;</span><br><span class="line">&quot;&#125;&quot;                     return &apos;&#125;&apos;;</span><br><span class="line">&quot;.&quot;                     return &apos;.&apos;;</span><br><span class="line">&quot;,&quot;                     return &apos;,&apos;;</span><br><span class="line">&quot;:&quot;                     return &apos;:&apos;;</span><br><span class="line">&quot;;&quot;                     return &apos;;&apos;;</span><br><span class="line">&quot;+&quot;                     return &apos;+&apos;;</span><br><span class="line">&quot;-&quot;                     return &apos;-&apos;;</span><br><span class="line">&quot;*&quot;                     return &apos;*&apos;;</span><br><span class="line">&quot;/&quot;                     return &apos;/&apos;;</span><br><span class="line">&quot;%&quot;                     return &apos;%&apos;;</span><br><span class="line">&quot;^&quot;                     return &apos;^&apos;;</span><br><span class="line">&quot;&amp;&quot;                     return &apos;&amp;&apos;;</span><br><span class="line">&quot;|&quot;                     return &apos;|&apos;;</span><br><span class="line">&quot;~&quot;                     return &apos;~&apos;;</span><br><span class="line"></span><br><span class="line">    /* 宏运算符 */</span><br><span class="line">&quot;@&quot;                     return &apos;@&apos;;</span><br><span class="line">&quot;,@&quot;                    return MBK;</span><br><span class="line"></span><br><span class="line">    /* 下面声明要用到的关键字 */</span><br><span class="line"></span><br><span class="line">    /* 控制流 */</span><br><span class="line">&quot;if&quot;                    return IF;</span><br><span class="line">&quot;else&quot;                  return ELSE;</span><br><span class="line">&quot;while&quot;                 return WHILE;</span><br><span class="line">&quot;do&quot;                    return DO;</span><br><span class="line">&quot;goto&quot;                  return GOTO;</span><br><span class="line">&quot;for&quot;                   return FOR;</span><br><span class="line">&quot;foreach&quot;               return FOREACH;</span><br><span class="line"></span><br><span class="line">    /* 退出控制 */</span><br><span class="line">&quot;break&quot;|&quot;continue&quot;|&quot;exit&quot;   SAVE_TOKEN; return KWS_EXIT;</span><br><span class="line"></span><br><span class="line">&quot;return&quot;                return RETURN;</span><br><span class="line"></span><br><span class="line">    /* 特殊运算符 */</span><br><span class="line">&quot;new&quot;                   return NEW;</span><br><span class="line">&quot;this&quot;                  return THIS;</span><br><span class="line">    </span><br><span class="line">    /* 特殊定义 */</span><br><span class="line">&quot;delegate&quot;              return DELEGATE;</span><br><span class="line">&quot;def&quot;                   return DEF;</span><br><span class="line">&quot;define&quot;                return DEFINE;</span><br><span class="line">&quot;import&quot;                return IMPORT;</span><br><span class="line">&quot;using&quot;                 return USING;</span><br><span class="line">&quot;namespace&quot;             return NAMESPACE;</span><br><span class="line"></span><br><span class="line">&quot;try&quot;|&quot;catch&quot;|&quot;finally&quot;|&quot;throw&quot;  SAVE_TOKEN; return KWS_ERROR; /* 异常控制 */</span><br><span class="line"></span><br><span class="line">&quot;null&quot;|&quot;true&quot;|&quot;false&quot;               SAVE_TOKEN; return KWS_TSZ; /* 特殊值 */</span><br><span class="line"></span><br><span class="line">&quot;struct&quot;|&quot;enum&quot;|&quot;union&quot;|&quot;module&quot;|&quot;interface&quot;|&quot;class&quot;     SAVE_TOKEN; return KWS_STRUCT; /* 结构声明 */</span><br><span class="line"></span><br><span class="line">&quot;public&quot;|&quot;private&quot;|&quot;protected&quot;  SAVE_TOKEN; return KWS_FWKZ; /* 访问控制 */</span><br><span class="line"></span><br><span class="line">&quot;const&quot;|&quot;static&quot;|&quot;extern&quot;|&quot;virtual&quot;|&quot;abstract&quot;|&quot;in&quot;|&quot;out&quot;        SAVE_TOKEN; return KWS_FUNC_XS; /* 函数修饰符 */</span><br><span class="line"></span><br><span class="line">&quot;void&quot;|&quot;double&quot;|&quot;int&quot;|&quot;float&quot;|&quot;char&quot;|&quot;bool&quot;|&quot;var&quot;|&quot;auto&quot;  SAVE_TOKEN; return KWS_TYPE; /* 基本类型 */</span><br><span class="line"></span><br><span class="line">[a-zA-Z_][a-zA-Z0-9_]*  SAVE_TOKEN; return ID; /* 标识符 */</span><br><span class="line"></span><br><span class="line">[0-9]*\.[0-9]*          SAVE_TOKEN; return DOUBLE;</span><br><span class="line">[0-9]+                  SAVE_TOKEN; return INTEGER;</span><br><span class="line"></span><br><span class="line">\&quot;(\\.|[^\\&quot;])*\&quot;       SAVE_STRING; return STRING; /* 字符串 */</span><br><span class="line">@\&quot;(\\.|[^\\&quot;])*\&quot;      SAVE_STRING_NC; return STRING; /* 无转义字符串 */</span><br><span class="line">\&apos;(\\.|.)\&apos;             SAVE_STRING; return CHAR;   /* 字符 */</span><br><span class="line"></span><br><span class="line">.                       printf(&quot;Unknown Token!\n&quot;); yyterminate();</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char* maketoken(const char* data, int len) &#123;</span><br><span class="line">    char* str = new char[len+1];</span><br><span class="line">    strncpy(str, data, len);</span><br><span class="line">    str[len] = 0;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char* makestring(const char* data, int len, int s) &#123;</span><br><span class="line">    char* str = new char[len-s+1];</span><br><span class="line">    strncpy(str, data+s-1, len-s);</span><br><span class="line">    str[len-s] = 0;</span><br><span class="line">    if (s == 3) return str;</span><br><span class="line">    printf(&quot;source: %s\n&quot;,str);</span><br><span class="line">    char* ans = CharEscape(str);</span><br><span class="line">    printf(&quot;escape: %s\n&quot;,ans);</span><br><span class="line">    delete[] str; </span><br><span class="line">    return ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来非常的长，但主要多的就是枚举了大量的关键字和运算符，当然，这个你在开发一门语言的前期，不用面面俱到，可以选自己用到的先写，不足的再日后补充。</p>
<p>要注意，这里最难的应该就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/*&quot;([^\*]|(\*)*[^\*/])*(\*)*&quot;*/&quot; ; /* 就是这种注释 */</span><br></pre></td></tr></table></figure></p>
<p>乍看起来，非常恐怖的正则式，但其实就是在枚举多种可能情况，来保障注释范围的正确性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/*&quot;   (  [^\*]   |   (\*)* [^\*/]   )*   (\*)*    &quot;*/&quot; ; /* 就是这种注释 */</span><br></pre></td></tr></table></figure></p>
<h3 id="用Bison创建通用的语法分析程序"><a href="#用Bison创建通用的语法分析程序" class="headerlink" title="用Bison创建通用的语法分析程序"></a>用Bison创建通用的语法分析程序</h3><p>这里我编写的是类C语言的语法，要注意的是，很多情况会造成规约-规约冲突和移入-规约冲突。这里我简要介绍一个bison的工作原理。</p>
<p>这种算法在编译原理中，被称为LALR(1)分析法，是自底向上规约的算法之一，而且又会向前看一个token，Bison中的每一行，被称为一个产生式（或BNF范式）</p>
<p>例如下面这行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def_module_statement : KWS_STRUCT ID &apos;&#123;&apos; def_statements &apos;&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>左边的是要规约的节点， 冒号右边是描述这个语法节点是用哪些节点产生的。<br>这是一个结构体定义的语法描述，KWS_STRUCT是终结符，来自Lex里的元素，看了上面的Lex描述，你应该能找到它的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;struct&quot;|&quot;enum&quot;|&quot;union&quot;|&quot;module&quot;|&quot;interface&quot;|&quot;class&quot;     SAVE_TOKEN; return KWS_STRUCT; /* 结构声明 */</span><br></pre></td></tr></table></figure></p>
<p>其实就是可能的一些关键字。而def_statements是另外的语法节点，由其他定义得来。</p>
<p>规约-规约冲突，是说，在当前产生式结束后，后面跟的元素还确定的情况下，能够规约到两个不同的语法节点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def_module_statement : KWS_STRUCT ID &apos;&#123;&apos; def_statements &apos;&#125;&apos; ;</span><br><span class="line">def_class_statement : KWS_STRUCT ID &apos;&#123;&apos; def_statements &apos;&#125;&apos; ;</span><br><span class="line"></span><br><span class="line">statement : def_module_statement &apos;;&apos; </span><br><span class="line">truetrue  | def_class_statement &apos;;&apos; </span><br><span class="line">truetrue  ;</span><br></pre></td></tr></table></figure>
<p>以上文法便会产生规约-规约冲突，这是严重的定义错误，必须加以避免。<br>注意，我为了体现这个语法的错误，特意加上了上下文环境，不是说一样的语法定义会产生规约规约冲突，而是说后面可能跟的终结符都一样时，（在这里是’;’）才会产生规约规约冲突，所以避免这种问题也简单，就是把相似的语法节点合并在一起就可以了。</p>
<p>说道移入-规约冲突，就要谈起if-else的摇摆问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if_state : IF &apos;(&apos; expr &apos;)&apos; statement </span><br><span class="line">         | IF &apos;(&apos; expr &apos;)&apos; statement ELSE statement </span><br><span class="line">         ;</span><br><span class="line"></span><br><span class="line">statement : if_state</span><br><span class="line">truetrue  | ...</span><br><span class="line">truetrue  ;</span><br></pre></td></tr></table></figure>
<p>正如这个定义一样，在 if的前半部识别完成后，下一个元素是ELSE终结符，此时可以规约，可以移入<br>说规约合法的理由是，if_state也是statement，而if第二条statement后面就是ELSE。<br>根据算法，这里规约是合理的，而移入同样是合理的。</p>
<p>为了避免这种冲突，一般Bison会优先选择移入，这样ELSE会和最近的IF匹配。<br>所以说，移入-规约冲突在你清楚的知道是哪的问题的时候，可以不加处理。但未期望的移入-规约冲突有可能让你的分析器不正确工作，这点还需要注意。</p>
<p>下面是我的Bison配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &quot;Model/nodes.h&quot;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define YYERROR_VERBOSE 1</span><br><span class="line"></span><br><span class="line">Node *programBlock; /* the top level root node of our final AST */</span><br><span class="line"></span><br><span class="line">extern int yylex();</span><br><span class="line">extern int yylineno;</span><br><span class="line">extern char* yytext;</span><br><span class="line">extern int yyleng;</span><br><span class="line"></span><br><span class="line">void yyerror(const char *s);</span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/* Represents the many different ways we can access our data */</span><br><span class="line"></span><br><span class="line">%union &#123;</span><br><span class="line">    Node *nodes;</span><br><span class="line">    char *str;</span><br><span class="line">    int token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">/* Define our terminal symbols (tokens). This should</span><br><span class="line"></span><br><span class="line">   match our tokens.l lex file. We also define the node type</span><br><span class="line"></span><br><span class="line">   they represent.</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">%token &lt;str&gt; ID INTEGER DOUBLE</span><br><span class="line">%token &lt;token&gt; CEQ CNE CGE CLE MBK</span><br><span class="line">%token &lt;token&gt; &apos;&lt;&apos; &apos;&gt;&apos; &apos;=&apos; &apos;+&apos; &apos;-&apos; &apos;*&apos; &apos;/&apos; &apos;%&apos; &apos;^&apos; &apos;&amp;&apos; &apos;|&apos; &apos;~&apos; &apos;@&apos;</span><br><span class="line">%token &lt;str&gt; STRING CHAR</span><br><span class="line">%token &lt;token&gt; IF ELSE WHILE DO GOTO FOR FOREACH  </span><br><span class="line">%token &lt;token&gt; DELEGATE DEF DEFINE IMPORT USING NAMESPACE</span><br><span class="line">%token &lt;token&gt; RETURN NEW THIS </span><br><span class="line">%token &lt;str&gt; KWS_EXIT KWS_ERROR KWS_TSZ KWS_STRUCT KWS_FWKZ KWS_FUNC_XS KWS_TYPE</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">   Define the type of node our nonterminal symbols represent.</span><br><span class="line">   The types refer to the %union declaration above. Ex: when</span><br><span class="line">   we call an ident (defined by union type ident) we are really</span><br><span class="line">   calling an (NIdentifier*). It makes the compiler happy.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">%type &lt;nodes&gt; program</span><br><span class="line">%type &lt;nodes&gt; def_module_statement</span><br><span class="line">%type &lt;nodes&gt; def_module_statements</span><br><span class="line">%type &lt;nodes&gt; def_statement</span><br><span class="line">%type &lt;nodes&gt; def_statements</span><br><span class="line">%type &lt;nodes&gt; for_state</span><br><span class="line">%type &lt;nodes&gt; if_state</span><br><span class="line">%type &lt;nodes&gt; while_state</span><br><span class="line">%type &lt;nodes&gt; statement</span><br><span class="line">%type &lt;nodes&gt; statements</span><br><span class="line">%type &lt;nodes&gt; block</span><br><span class="line">%type &lt;nodes&gt; var_def</span><br><span class="line">%type &lt;nodes&gt; func_def</span><br><span class="line">%type &lt;nodes&gt; func_def_args</span><br><span class="line">%type &lt;nodes&gt; func_def_xs </span><br><span class="line">%type &lt;nodes&gt; numeric</span><br><span class="line">%type &lt;nodes&gt; expr</span><br><span class="line">%type &lt;nodes&gt; call_arg </span><br><span class="line">%type &lt;nodes&gt; call_args </span><br><span class="line">%type &lt;nodes&gt; return_state</span><br><span class="line"></span><br><span class="line">//%type &lt;token&gt; operator 这个设计容易引起规约冲突，舍弃</span><br><span class="line">/* Operator precedence for mathematical operators */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%left &apos;~&apos;</span><br><span class="line">%left &apos;&amp;&apos; &apos;|&apos;</span><br><span class="line">%left CEQ CNE CLE CGE &apos;&lt;&apos; &apos;&gt;&apos; &apos;=&apos;</span><br><span class="line">%left &apos;+&apos; &apos;-&apos;</span><br><span class="line">%left &apos;*&apos; &apos;/&apos; &apos;%&apos; &apos;^&apos;</span><br><span class="line">%left &apos;.&apos;</span><br><span class="line">%left MBK &apos;@&apos;</span><br><span class="line"></span><br><span class="line">%start program</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">program : def_statements &#123; programBlock = Node::getList($1); &#125;</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">def_module_statement : KWS_STRUCT ID &apos;&#123;&apos; def_statements &apos;&#125;&apos; &#123; $$ = Node::make_list(3, StringNode::Create($1), StringNode::Create($2), $4); &#125;</span><br><span class="line">                     | KWS_STRUCT ID &apos;;&apos; &#123; $$ = Node::make_list(3, StringNode::Create($1), StringNode::Create($2), Node::Create()); &#125;</span><br><span class="line">                     ;</span><br><span class="line"></span><br><span class="line">def_module_statements  : def_module_statement &#123; $$ = Node::getList($1); &#125;</span><br><span class="line">                       | def_module_statements def_module_statement &#123; $$ = $1; $$-&gt;addBrother(Node::getList($2)); &#125;</span><br><span class="line">                       ;</span><br><span class="line"></span><br><span class="line">func_def_xs : KWS_FUNC_XS &#123; $$ = StringNode::Create($1); &#125;</span><br><span class="line">            | func_def_xs KWS_FUNC_XS &#123;$$ = $1; $$-&gt;addBrother(StringNode::Create($2)); &#125;</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">def_statement : var_def &apos;;&apos; &#123; $$ = $1; &#125;</span><br><span class="line">              | func_def </span><br><span class="line">              | def_module_statement </span><br><span class="line">              | func_def_xs func_def &#123; $$ = $2; $2-&gt;addBrother(Node::getList($1)); &#125; </span><br><span class="line">              ;</span><br><span class="line"></span><br><span class="line">def_statements : def_statement &#123; $$ = Node::getList($1); &#125;</span><br><span class="line">               | def_statements def_statement &#123; $$ = $1; $$-&gt;addBrother(Node::getList($2)); &#125;</span><br><span class="line">               ;</span><br><span class="line"></span><br><span class="line">statements : statement &#123; $$ = Node::getList($1); &#125;</span><br><span class="line">           | statements statement &#123; $$ = $1; $$-&gt;addBrother(Node::getList($2)); &#125;</span><br><span class="line">           ;</span><br><span class="line"></span><br><span class="line">statement : def_statement </span><br><span class="line">          | expr &apos;;&apos; &#123; $$ = $1; &#125; </span><br><span class="line">          | block </span><br><span class="line">          | if_state</span><br><span class="line">          | while_state</span><br><span class="line">          | for_state</span><br><span class="line">          | return_state</span><br><span class="line">          ;</span><br><span class="line"></span><br><span class="line">if_state : IF &apos;(&apos; expr &apos;)&apos; statement &#123; $$ = Node::make_list(3, StringNode::Create(&quot;if&quot;), $3, $5); &#125;</span><br><span class="line">         | IF &apos;(&apos; expr &apos;)&apos; statement ELSE statement &#123; $$ = Node::make_list(4, StringNode::Create(&quot;if&quot;), $3, $5, $7); &#125;</span><br><span class="line">         ;</span><br><span class="line"></span><br><span class="line">while_state : WHILE &apos;(&apos; expr &apos;)&apos; statement &#123; $$ = Node::make_list(3, StringNode::Create(&quot;while&quot;), $3, $5); &#125;</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">for_state : FOR &apos;(&apos; expr &apos;;&apos; expr &apos;;&apos; expr &apos;)&apos; statement &#123; $$ = Node::make_list(5, StringNode::Create(&quot;for&quot;), $3, $5, $7, $9); &#125;</span><br><span class="line">          | FOR &apos;(&apos; var_def &apos;;&apos; expr &apos;;&apos; expr &apos;)&apos; statement &#123; $$ = Node::make_list(5, StringNode::Create(&quot;for&quot;), Node::Create($3), $5, $7, $9); &#125;</span><br><span class="line">          ;</span><br><span class="line"></span><br><span class="line">return_state : RETURN &apos;;&apos; &#123; $$ = StringNode::Create(&quot;return&quot;); &#125;</span><br><span class="line">             | RETURN expr &apos;;&apos; &#123; $$ = StringNode::Create(&quot;return&quot;); $$-&gt;addBrother($2); &#125;              </span><br><span class="line"></span><br><span class="line">block : &apos;&#123;&apos; statements &apos;&#125;&apos; &#123; $$ = Node::Create($2); &#125;</span><br><span class="line">      | &apos;&#123;&apos; &apos;&#125;&apos; &#123; $$ = Node::Create(); &#125;</span><br><span class="line">      ; </span><br><span class="line"></span><br><span class="line">var_def : KWS_TYPE ID &#123; $$ = Node::make_list(3, StringNode::Create(&quot;set&quot;), StringNode::Create($1), StringNode::Create($2)); &#125;</span><br><span class="line">        | ID ID &#123; $$ = Node::make_list(3, StringNode::Create(&quot;set&quot;), StringNode::Create($1), StringNode::Create($2)); &#125;</span><br><span class="line">        | KWS_TYPE ID &apos;=&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;set&quot;), StringNode::Create($1), StringNode::Create($2), $4); &#125;</span><br><span class="line">        | ID ID &apos;=&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;set&quot;), StringNode::Create($1), StringNode::Create($2), $4); &#125;</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">func_def : ID ID &apos;(&apos; func_def_args &apos;)&apos; block</span><br><span class="line">            &#123; $$ = Node::make_list(5, StringNode::Create(&quot;function&quot;), StringNode::Create($1), StringNode::Create($2), $4, $6); &#125;</span><br><span class="line">         | KWS_TYPE ID &apos;(&apos; func_def_args &apos;)&apos; block</span><br><span class="line">            &#123; $$ = Node::make_list(5, StringNode::Create(&quot;function&quot;), StringNode::Create($1), StringNode::Create($2), $4, $6); &#125;</span><br><span class="line">         | ID ID &apos;(&apos; func_def_args &apos;)&apos; &apos;;&apos;</span><br><span class="line">            &#123; $$ = Node::make_list(5, StringNode::Create(&quot;function&quot;), StringNode::Create($1), StringNode::Create($2), $4); &#125;</span><br><span class="line">         | KWS_TYPE ID &apos;(&apos; func_def_args &apos;)&apos; &apos;;&apos;</span><br><span class="line">            &#123; $$ = Node::make_list(5, StringNode::Create(&quot;function&quot;), StringNode::Create($1), StringNode::Create($2), $4); &#125;</span><br><span class="line">         ;</span><br><span class="line"></span><br><span class="line">func_def_args : var_def &#123; $$ = Node::Create(Node::Create($1)); &#125;</span><br><span class="line">              | func_def_args &apos;,&apos; var_def &#123; $$ = $1; $$-&gt;addChildren(Node::Create($3)); &#125;</span><br><span class="line">              | %empty  &#123; $$ = Node::Create(); &#125;</span><br><span class="line">              ;</span><br><span class="line"></span><br><span class="line">numeric : INTEGER &#123; $$ = IntNode::Create($1); &#125;</span><br><span class="line">        | DOUBLE &#123; $$ = FloatNode::Create($1); &#125;</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">expr : expr &apos;=&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;=&quot;), $1, $3); &#125;</span><br><span class="line">     | ID &apos;(&apos; call_args &apos;)&apos; &#123; $$ = Node::make_list(2, StringNode::Create(&quot;call&quot;), StringNode::Create($1)); $$-&gt;addBrother($3); &#125;</span><br><span class="line">     | ID &#123; $$ = IDNode::Create($1); &#125;</span><br><span class="line">     | numeric &#123; $$ = $1; &#125;</span><br><span class="line">     | STRING &#123; $$ = StringNode::Create($1); &#125;</span><br><span class="line">     | KWS_TSZ </span><br><span class="line">     | NEW ID &apos;(&apos; call_args &apos;)&apos; &#123; $$ = Node::make_list(3, StringNode::Create(&quot;new&quot;), StringNode::Create($2), $4); &#125;</span><br><span class="line">     | expr CEQ expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;==&quot;), $1, $3); &#125;</span><br><span class="line">     | expr CNE expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;!=&quot;), $1, $3); &#125;</span><br><span class="line">     | expr CLE expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;&lt;=&quot;), $1, $3); &#125;</span><br><span class="line">     | expr CGE expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;&gt;=&quot;), $1, $3); &#125;</span><br><span class="line">     | expr &apos;&lt;&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;&lt;&quot;), $1, $3); &#125;</span><br><span class="line">     | expr &apos;&gt;&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;&gt;&quot;), $1, $3); &#125;</span><br><span class="line">     | expr &apos;+&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;+&quot;), $1, $3); &#125;</span><br><span class="line">     | expr &apos;-&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;-&quot;), $1, $3); &#125;</span><br><span class="line">     | expr &apos;*&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;*&quot;), $1, $3); &#125;</span><br><span class="line">     | expr &apos;/&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;/&quot;), $1, $3); &#125;</span><br><span class="line">     | expr &apos;%&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;%&quot;), $1, $3); &#125;</span><br><span class="line">     | expr &apos;^&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;^&quot;), $1, $3); &#125;</span><br><span class="line">     | expr &apos;&amp;&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;&amp;&quot;), $1, $3); &#125;</span><br><span class="line">     | expr &apos;|&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;|&quot;), $1, $3); &#125;</span><br><span class="line">     | expr &apos;.&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt2&quot;), StringNode::Create(&quot;.&quot;), $1, $3); &#125;</span><br><span class="line">     | &apos;~&apos; expr &#123; $$ = Node::make_list(4, StringNode::Create(&quot;opt1&quot;), StringNode::Create(&quot;~&quot;), $2); &#125;</span><br><span class="line">     | &apos;(&apos; expr &apos;)&apos;  /* ( expr ) */  &#123; $$ = $2; &#125;</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">call_arg  :  expr &#123; $$ = $1;  &#125;</span><br><span class="line">          |  ID &apos;:&apos; expr &#123; $$ = Node::make_list(3, StringNode::Create(&quot;:&quot;), $1, $3); &#125;</span><br><span class="line">          ;</span><br><span class="line"></span><br><span class="line">call_args : %empty &#123; $$ = Node::Create(); &#125;</span><br><span class="line">          | call_arg &#123; $$ = Node::getList($1); &#125;</span><br><span class="line">          | call_args &apos;,&apos; call_arg  &#123; $$ = $1; $$-&gt;addBrother(Node::getList($3)); &#125;</span><br><span class="line">          ;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">void yyerror(const char* s)&#123;</span><br><span class="line">    fprintf(stderr, &quot;%s \n&quot;, s);    </span><br><span class="line">    fprintf(stderr, &quot;line %d: &quot;, yylineno);</span><br><span class="line">    fprintf(stderr, &quot;text %s \n&quot;, yytext);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译器架构的王者LLVM——（3）用代码生成代码]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85%E2%80%94%E2%80%94LLVM/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85LLVM%E2%80%94%E2%80%94%EF%BC%883%EF%BC%89%E7%94%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/"/>
    <id>http://sunxfancy.github.io/2016/03/28/编译器架构的王者——LLVM/编译器架构的王者LLVM——（3）用代码生成代码/</id>
    <published>2016-03-28T15:45:02.469Z</published>
    <updated>2015-12-06T10:53:06.267Z</updated>
    <content type="html"><![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://blog.csdn.net/xfxyy_sxfancy" target="_blank" rel="external">http://blog.csdn.net/xfxyy_sxfancy</a></p>
<h2 id="用代码生成代码"><a href="#用代码生成代码" class="headerlink" title="用代码生成代码"></a>用代码生成代码</h2><p>LLVM的开发思路很简单，就是用C++代码去不断生成llvm字节码。</p>
<h3 id="RedApple语言示例"><a href="#RedApple语言示例" class="headerlink" title="RedApple语言示例"></a>RedApple语言示例</h3><p>这是我花了两周多的时间制作的一门实验型语言，主要是想验证一个编译器的设计思路，宏翻译系统。<br>它的架构和一般的编译器很不一样，首先，编译器前端会先将语法转换为很通用的AST语法树节点，一般的编译器，往往是直接在这些节点上进行语义分析，然后进行代码生成。<br>这次我采用了类似lisp的表示方法，将源文件转换为语法树，然后遍历整棵语法树，根据上面标注的宏提示，去按照各个宏的规则进行翻译工作。</p>
<p>整个编译器1500行左右的代码，非常的小巧，不过功能也比较有限，而且好多地方还不完善，主要支持的就是函数的定义，结构体的定义，函数调用，结构体访问，分配内存，基本逻辑控制语句这些基本的特性。</p>
<p>大家可以作为学习llvm的一个示例吧。<br>Github地址：<a href="https://github.com/sunxfancy/RedApple" target="_blank" rel="external">https://github.com/sunxfancy/RedApple</a></p>
<p>同样，非常精品的示例还推荐大家看以下两位网友写的：</p>
<p>构建Toy编译器：基于Flex、Bison和LLVM<br><a href="http://lesliezhu.github.io/public/write-your-toy-compiler.html" target="_blank" rel="external">http://lesliezhu.github.io/public/write-your-toy-compiler.html</a></p>
<p>用LLVM来开发自己的编译器系列<br><a href="http://my.oschina.net/linlifeng/blog/97457" target="_blank" rel="external">http://my.oschina.net/linlifeng/blog/97457</a></p>
<p>当然，这些示例不是说要大家一下都看懂，那么也就没有教程的意义了，下面我会继续介绍各个关键的LLVM平台API以及相关工具链。大家可以将以上三个项目和LLVM官网example中的作为参考，在实践中加以印证。</p>
<h3 id="工具链简介"><a href="#工具链简介" class="headerlink" title="工具链简介"></a>工具链简介</h3><table>
<thead>
<tr>
<th>工具</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>clang -emit-llvm</td>
<td>指令，可以生成.bc的字节码文件</td>
</tr>
<tr>
<td>lli</td>
<td>llvm解释器，直接执行.bc字节码文件</td>
</tr>
<tr>
<td>llc</td>
<td>llvm编译器，将.bc编译成.o</td>
</tr>
</tbody>
</table>
<p>以上三个最常用，其他小工具备用</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>llvm-as</td>
<td>汇编器</td>
</tr>
<tr>
<td>llvm-dis</td>
<td>反汇编器</td>
</tr>
<tr>
<td>llvm-ar</td>
<td>打包器</td>
</tr>
<tr>
<td>llvm-link</td>
<td>字节码链接器</td>
</tr>
</tbody>
</table>
<p>唉，太多了，好多我也木有用过，还有需要的请查看官方文档：<br><a href="http://llvm.org/docs/CommandGuide/index.html" target="_blank" rel="external">http://llvm.org/docs/CommandGuide/index.html</a></p>
<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><table>
<thead>
<tr>
<th>LLVM类</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>LLVMContext</td>
<td>上下文类，基本是最核心的保存上下文符号的类</td>
</tr>
<tr>
<td>Module</td>
<td>模块类，一般一个文件是一个模块，里面有函数列表和全局变量表</td>
</tr>
<tr>
<td>Function</td>
<td>函数类，函数类，生成出来就是一个C函数</td>
</tr>
<tr>
<td>Constant</td>
<td>常量类，各种常量的定义，都是从这里派生出来的</td>
</tr>
<tr>
<td>Value</td>
<td>各值类型的基类，几乎所以的函数、常量、变量、表达式，都可以转换成Value型</td>
</tr>
<tr>
<td>Type</td>
<td>类型类，表示各种内部类型或用户类型，每一个Value都有个getType方法来获取其类型。</td>
</tr>
<tr>
<td>BasicBlock</td>
<td>基本块，一般是表示一个标签，注意这个块不是嵌套形式的结构，而是每个块结尾可以用指令跳转 到其他块，类似C语言中的标签的功能</td>
</tr>
</tbody>
</table>
<h3 id="尝试先来生成个小函数"><a href="#尝试先来生成个小函数" class="headerlink" title="尝试先来生成个小函数"></a>尝试先来生成个小函数</h3><p>就拿printf开练吧，这个函数第一有用，第二简单，第三只要声明不要内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_printf</span><span class="params">(llvm::Module *module)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;llvm::Type*&gt; printf_arg_types; <span class="comment">// 这里是参数表</span></span><br><span class="line">    printf_arg_types.push_back(llvm::Type::getInt8PtrTy(module-&gt;getContext()));</span><br><span class="line"></span><br><span class="line">    llvm::FunctionType* printf_type =</span><br><span class="line">        llvm::FunctionType::get(</span><br><span class="line">            llvm::Type::getInt32Ty(module-&gt;getContext()), printf_arg_types, <span class="literal">true</span>); </span><br><span class="line">            <span class="comment">// 这里的true表示后面接不定参数</span></span><br><span class="line"></span><br><span class="line">    llvm::Function *func = llvm::Function::Create(</span><br><span class="line">                printf_type, llvm::Function::ExternalLinkage,</span><br><span class="line">                llvm::Twine(<span class="string">"printf"</span>),</span><br><span class="line">                module</span><br><span class="line">           );</span><br><span class="line">    func-&gt;setCallingConv(llvm::CallingConv::C); <span class="comment">// 一定注意调用方式的正确性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么样，是不是也很简单？</p>
<h3 id="编写主函数和调试上下文"><a href="#编写主函数和调试上下文" class="headerlink" title="编写主函数和调试上下文"></a>编写主函数和调试上下文</h3><p>下面我们来编写一个主函数，来测试一下我们的函数是否正确，这里，也是LLVM最核心的启动和调试流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">trueInitializeNativeTarget();</span><br><span class="line">    LLVMContext Context;</span><br><span class="line">    Module* M = new Module(&quot;main&quot;, Context);</span><br><span class="line"></span><br><span class="line">    register_printf(M);</span><br><span class="line"></span><br><span class="line">    // 校验问题, 这个函数需要一个输出流来打印错误信息</span><br><span class="line">trueif (verifyModule(*M, &amp;errs())) &#123;</span><br><span class="line">truetrueerrs() &lt;&lt; &quot;构建LLVM字节码出错!\n&quot;;</span><br><span class="line">truetrueexit(1);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true// 输出llvm字节码</span><br><span class="line">trueouts() &lt;&lt; &quot;LLVM module:\n\n&quot; &lt;&lt; *M;</span><br><span class="line">    outs() &lt;&lt; &quot;\n\n&quot;;</span><br><span class="line">    outs().flush();</span><br><span class="line"></span><br><span class="line">    // 输出二进制BitCode到.bc文件</span><br><span class="line">truestd::error_code ErrInfo;</span><br><span class="line">trueraw_ostream *out = new raw_fd_ostream(&quot;a.bc&quot;, ErrInfo, sys::fs::F_None);</span><br><span class="line">trueWriteBitcodeToFile(M, *out);</span><br><span class="line">trueout-&gt;flush(); delete out;</span><br><span class="line"></span><br><span class="line">true// 关闭LLVM释放内存</span><br><span class="line">truellvm_shutdown();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：<br><img src="./img/3/done.png" alt=""></p>
<p>对了，我们好像没有提该引用哪些头文件，请见附录</p>
<h3 id="附：完整示例"><a href="#附：完整示例" class="headerlink" title="附：完整示例"></a>附：完整示例</h3><p>只是头文件有点长，具体功能有的我也记不清了，一般我是习惯性把一片粘过去 →_→</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* </span><br><span class="line">* @Author: sxf</span><br><span class="line">* @Date:   2015-11-06 20:37:15</span><br><span class="line">* @Last Modified by:   sxf</span><br><span class="line">* @Last Modified time: 2015-11-06 20:46:43</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/Verifier.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/ExecutionEngine/GenericValue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/ExecutionEngine/Interpreter.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/Constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/DerivedTypes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/Instructions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/LLVMContext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/Module.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/IRBuilder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/Support/ManagedStatic.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/Support/TargetSelect.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/Support/raw_ostream.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/Bitcode/ReaderWriter.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/Support/FileSystem.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/ValueSymbolTable.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_printf</span><span class="params">(llvm::Module *module)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;llvm::Type*&gt; printf_arg_types;</span><br><span class="line">    printf_arg_types.push_back(llvm::Type::getInt8PtrTy(module-&gt;getContext()));</span><br><span class="line"></span><br><span class="line">    llvm::FunctionType* printf_type =</span><br><span class="line">        llvm::FunctionType::get(</span><br><span class="line">            llvm::Type::getInt32Ty(module-&gt;getContext()), printf_arg_types, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    llvm::Function *func = llvm::Function::Create(</span><br><span class="line">                printf_type, llvm::Function::ExternalLinkage,</span><br><span class="line">                llvm::Twine(<span class="string">"printf"</span>),</span><br><span class="line">                module</span><br><span class="line">           );</span><br><span class="line">    func-&gt;setCallingConv(llvm::CallingConv::C);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">trueInitializeNativeTarget();</span><br><span class="line">    LLVMContext Context;</span><br><span class="line">    Module* M = <span class="keyword">new</span> Module(<span class="string">"main"</span>, Context);</span><br><span class="line"></span><br><span class="line">    register_printf(M);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验问题, 这个函数需要一个输出流来打印错误信息</span></span><br><span class="line">true<span class="keyword">if</span> (verifyModule(*M, &amp;errs())) &#123;</span><br><span class="line">truetrueerrs() &lt;&lt; <span class="string">"构建LLVM字节码出错!\n"</span>;</span><br><span class="line">truetrue<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 输出llvm字节码</span></span><br><span class="line">trueouts() &lt;&lt; <span class="string">"LLVM module:\n\n"</span> &lt;&lt; *M;</span><br><span class="line">    outs() &lt;&lt; <span class="string">"\n\n"</span>;</span><br><span class="line">    outs().flush();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出二进制BitCode到.bc文件</span></span><br><span class="line">true<span class="built_in">std</span>::error_code ErrInfo;</span><br><span class="line">trueraw_ostream *out = <span class="keyword">new</span> raw_fd_ostream(<span class="string">"a.bc"</span>, ErrInfo, sys::fs::F_None);</span><br><span class="line">trueWriteBitcodeToFile(M, *out);</span><br><span class="line">trueout-&gt;flush(); <span class="keyword">delete</span> out;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 关闭LLVM释放内存</span></span><br><span class="line">truellvm_shutdown();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译器架构的王者LLVM——（2）开发LLVM项目]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85%E2%80%94%E2%80%94LLVM/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85LLVM%E2%80%94%E2%80%94%EF%BC%882%EF%BC%89%E5%BC%80%E5%8F%91LLVM%E9%A1%B9%E7%9B%AE/"/>
    <id>http://sunxfancy.github.io/2016/03/28/编译器架构的王者——LLVM/编译器架构的王者LLVM——（2）开发LLVM项目/</id>
    <published>2016-03-28T15:45:02.468Z</published>
    <updated>2015-12-06T10:53:03.013Z</updated>
    <content type="html"><![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<h2 id="开发LLVM项目"><a href="#开发LLVM项目" class="headerlink" title="开发LLVM项目"></a>开发LLVM项目</h2><p>介绍了LLVM这么多，那么我们能用LLVM做一款自己的编程语言么？答案是，有点难度，但不是不可行。只要你熟悉C++编程，而且有足够的热情，那么就没有什么能阻止你了。</p>
<p>下面我就来介绍一下，LLVM项目的基本方法。<br>需要的东西： LLVM平台库，文档，CMAKE，C++编译器</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>首先我的系统是Ubuntu14.04，我就介绍Ubuntu下的配置方法了，用Windows的朋友就不好意思了。<br>安装llvm-3.6及其开发包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install llvm-3.6*</span><br></pre></td></tr></table></figure>
<p>一般是推荐将文档和示例都下载下来的，因为比较这些对应版本的参考很重要，很多网上的代码，都是特定版本有效，后来就有API变更的情况。<br>所以大家一定注意版本问题，我开发的时候，源里面的版本最高就3.6，我也不追求什么最新版本，新特性什么的，所以声明一下，本系列教程的LLVM版本均为3.6版，文档参考也为3.6版。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install clang cmake</span><br></pre></td></tr></table></figure>
<p>clang编译器，我个人感觉比gcc好用许多倍，而且这个编译器就是用llvm作为后端，能够帮助我们编译一些C代码到LLVM中间码，方便我们有个正确的中间码参考。</p>
<h3 id="CMAKE管理项目"><a href="#CMAKE管理项目" class="headerlink" title="CMAKE管理项目"></a>CMAKE管理项目</h3><p>CMake作为C++项目管理的利器，也是非常好用的一个工具，这样我们就不用自己很烦的写Makefile了，</p>
<p>下面是一个CMake示例，同时还带有FLex和Bison的配置：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(RedApple)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(LLVM_TARGETS_TO_BUILD X86)</span><br><span class="line"><span class="keyword">set</span>(LLVM_BUILD_RUNTIME <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(LLVM_BUILD_TOOLS <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(LLVM REQUIRED CONFIG)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"Found LLVM $&#123;LLVM_PACKAGE_VERSION&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"Using LLVMConfig.cmake in: $&#123;LLVM_DIR&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(BISON)</span><br><span class="line"><span class="keyword">find_package</span>(FLEX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_COMPILER_ENV_VAR <span class="string">"clang++"</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS <span class="string">"-std=c++11"</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS_DEBUG   <span class="string">"-g"</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS_MINSIZEREL  <span class="string">"-Os -DNDEBUG"</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS_RELEASE  <span class="string">"-O4 -DNDEBUG"</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS_RELWITHDEBINFO <span class="string">"-O2 -g"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;LLVM_DEFINITIONS&#125;</span>)</span><br><span class="line"></span><br><span class="line">FLEX_TARGET(MyScanner <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/redapple_lex.l</span><br><span class="line">                      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/redapple_lex.cpp COMPILE_FLAGS -w)</span><br><span class="line">BISON_TARGET(MyParser <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/redapple_parser.y</span><br><span class="line">                      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/redapple_parser.cpp)</span><br><span class="line">ADD_FLEX_BISON_DEPENDENCY(MyScanner MyParser)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(Debug Release build <span class="keyword">include</span> src src/Model src/Utils)</span><br><span class="line"></span><br><span class="line">file(GLOB_RECURSE source_files  <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp</span><br><span class="line">                                <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/Model/*.cpp</span><br><span class="line">                                <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/<span class="keyword">Macro</span>/*.cpp</span><br><span class="line">                                <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/Utils/*.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(redapple <span class="variable">$&#123;source_files&#125;</span> </span><br><span class="line">                        <span class="variable">$&#123;BISON_MyParser_OUTPUTS&#125;</span> </span><br><span class="line">                        <span class="variable">$&#123;FLEX_MyScanner_OUTPUTS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS redapple RUNTIME DESTINATION bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find the libraries that correspond to the LLVM components</span></span><br><span class="line"><span class="comment"># that we wish to use</span></span><br><span class="line">llvm_map_components_to_libnames(llvm_libs </span><br><span class="line">    support core irreader executionengine interpreter </span><br><span class="line">    mc mcjit bitwriter x86codegen target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Link against LLVM libraries</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(redapple <span class="variable">$&#123;llvm_libs&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>Ubuntu的默认安装，有时LLVM会出bug，cmake找不到许多配置文件，我仔细查看了它的CMake配置，发现有一行脚本路径写错了：<br>/usr/share/llvm-3.6/cmake/ 是llvm的cmake配置路径</p>
<p>其中的LLVMConfig.cmake第48行，它原来的路径是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(LLVM_CMAKE_DIR &quot;/usr/share/llvm-3.6/share/llvm/cmake&quot;)</span><br></pre></td></tr></table></figure>
<p>应该改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(LLVM_CMAKE_DIR &quot;/usr/share/llvm-3.6/cmake&quot;)</span><br></pre></td></tr></table></figure>
<p>Ubuntu下的llvm文档和示例都在如下目录：<br>/usr/share/doc/llvm-3.6-doc<br>/usr/share/doc/llvm-3.6-examples</p>
<p>我们将example下的HowToUseJIT复制到工作目录中，测试编译一下，懒得找的可以粘我后面附录给的内容。<br>然后再用简单修改后的CMake测试编译一下。</p>
<p>项目结构是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HowToUseJIT -- src</span><br><span class="line">                + --- HowToUseJIT.cpp</span><br><span class="line">        +  --- CMakeLists.txt</span><br><span class="line">        +  --- build</span><br></pre></td></tr></table></figure></p>
<p>在项目根目录执行如下指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p>
<p>如果编译通过了，那么恭喜你，你已经会构建LLVM项目了</p>
<h3 id="附：-CMakeLists-txt-和-HowToUseJIT-cpp"><a href="#附：-CMakeLists-txt-和-HowToUseJIT-cpp" class="headerlink" title="附： CMakeLists.txt 和 HowToUseJIT.cpp"></a>附： CMakeLists.txt 和 HowToUseJIT.cpp</h3><p>CMakeLists.txt<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(llvm_test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(LLVM_TARGETS_TO_BUILD X86)</span><br><span class="line"><span class="keyword">set</span>(LLVM_BUILD_RUNTIME <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(LLVM_BUILD_TOOLS <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(LLVM REQUIRED CONFIG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"Found LLVM $&#123;LLVM_PACKAGE_VERSION&#125;"</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"Using LLVMConfig.cmake in: $&#123;LLVM_DIR&#125;"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_COMPILER_ENV_VAR <span class="string">"clang++"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS <span class="string">"-std=c++11"</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS_DEBUG   <span class="string">"-g"</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS_MINSIZEREL  <span class="string">"-Os -DNDEBUG"</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS_RELEASE  <span class="string">"-O4 -DNDEBUG"</span>)</span><br><span class="line"><span class="keyword">SET</span> (CMAKE_CXX_FLAGS_RELWITHDEBINFO <span class="string">"-O2 -g"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;LLVM_DEFINITIONS&#125;</span>)</span><br><span class="line"></span><br><span class="line">file(GLOB_RECURSE source_files <span class="string">"$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp"</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(llvm_test <span class="variable">$&#123;source_files&#125;</span>)</span><br><span class="line"><span class="keyword">install</span>(TARGETS llvm_test RUNTIME DESTINATION bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find the libraries that correspond to the LLVM components</span></span><br><span class="line"><span class="comment"># that we wish to use</span></span><br><span class="line">llvm_map_components_to_libnames(llvm_libs </span><br><span class="line">    Core</span><br><span class="line">    ExecutionEngine</span><br><span class="line">    Interpreter</span><br><span class="line">    MC</span><br><span class="line">    Support</span><br><span class="line">    nativecodegen)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Link against LLVM libraries</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(llvm_test <span class="variable">$&#123;llvm_libs&#125;</span>)</span><br></pre></td></tr></table></figure></p>
<p>HowToUseJIT.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===-- examples/HowToUseJIT/HowToUseJIT.cpp - An example use of the JIT --===//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                     The LLVM Compiler Infrastructure</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file is distributed under the University of Illinois Open Source</span></span><br><span class="line"><span class="comment">// License. See LICENSE.TXT for details.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This small program provides an example of how to quickly build a small</span></span><br><span class="line"><span class="comment">//  module with two functions and execute it with the JIT.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Goal:</span></span><br><span class="line"><span class="comment">//  The goal of this snippet is to create in the memory</span></span><br><span class="line"><span class="comment">//  the LLVM module consisting of two functions as follow: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// int add1(int x) &#123;</span></span><br><span class="line"><span class="comment">//   return x+1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// int foo() &#123;</span></span><br><span class="line"><span class="comment">//   return add1(10);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// then compile the module via JIT, then execute the `foo'</span></span><br><span class="line"><span class="comment">// function and return result to a driver, i.e. to a "host program".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Some remarks and questions:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - could we invoke some code using noname functions too?</span></span><br><span class="line"><span class="comment">//   e.g. evaluate "foo()+foo()" without fears to introduce</span></span><br><span class="line"><span class="comment">//   conflict of temporary function name with some real</span></span><br><span class="line"><span class="comment">//   existing function name?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/ExecutionEngine/GenericValue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/ExecutionEngine/Interpreter.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/Constants.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/DerivedTypes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/IRBuilder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/Instructions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/LLVMContext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/IR/Module.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/Support/ManagedStatic.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/Support/TargetSelect.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"llvm/Support/raw_ostream.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  InitializeNativeTarget();</span><br><span class="line"></span><br><span class="line">  LLVMContext Context;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Create some module to put our function into it.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Module&gt; Owner = make_unique&lt;Module&gt;(<span class="string">"test"</span>, Context);</span><br><span class="line">  Module *M = Owner.get();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the add1 function entry and insert this entry into module M.  The</span></span><br><span class="line">  <span class="comment">// function will have a return type of "int" and take an argument of "int".</span></span><br><span class="line">  <span class="comment">// The '0' terminates the list of argument types.</span></span><br><span class="line">  Function *Add1F =</span><br><span class="line">    cast&lt;Function&gt;(M-&gt;getOrInsertFunction(<span class="string">"add1"</span>, Type::getInt32Ty(Context),</span><br><span class="line">                                          Type::getInt32Ty(Context),</span><br><span class="line">                                          (Type *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add a basic block to the function. As before, it automatically inserts</span></span><br><span class="line">  <span class="comment">// because of the last argument.</span></span><br><span class="line">  BasicBlock *BB = BasicBlock::Create(Context, <span class="string">"EntryBlock"</span>, Add1F);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a basic block builder with default parameters.  The builder will</span></span><br><span class="line">  <span class="comment">// automatically append instructions to the basic block `BB'.</span></span><br><span class="line">  IRBuilder&lt;&gt; builder(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get pointers to the constant `1'.</span></span><br><span class="line">  Value *One = builder.getInt32(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get pointers to the integer argument of the add1 function...</span></span><br><span class="line">  assert(Add1F-&gt;arg_begin() != Add1F-&gt;arg_end()); <span class="comment">// Make sure there's an arg</span></span><br><span class="line">  Argument *ArgX = Add1F-&gt;arg_begin();  <span class="comment">// Get the arg</span></span><br><span class="line">  ArgX-&gt;setName(<span class="string">"AnArg"</span>);            <span class="comment">// Give it a nice symbolic name for fun.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the add instruction, inserting it into the end of BB.</span></span><br><span class="line">  Value *Add = builder.CreateAdd(One, ArgX);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the return instruction and add it to the basic block</span></span><br><span class="line">  builder.CreateRet(Add);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now, function add1 is ready.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now we're going to create function `foo', which returns an int and takes no</span></span><br><span class="line">  <span class="comment">// arguments.</span></span><br><span class="line">  Function *FooF =</span><br><span class="line">    cast&lt;Function&gt;(M-&gt;getOrInsertFunction(<span class="string">"foo"</span>, Type::getInt32Ty(Context),</span><br><span class="line">                                          (Type *)<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add a basic block to the FooF function.</span></span><br><span class="line">  BB = BasicBlock::Create(Context, <span class="string">"EntryBlock"</span>, FooF);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the basic block builder to attach itself to the new basic block</span></span><br><span class="line">  builder.SetInsertPoint(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get pointer to the constant `10'.</span></span><br><span class="line">  Value *Ten = builder.getInt32(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pass Ten to the call to Add1F</span></span><br><span class="line">  CallInst *Add1CallRes = builder.CreateCall(Add1F, Ten);</span><br><span class="line">  Add1CallRes-&gt;setTailCall(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the return instruction and add it to the basic block.</span></span><br><span class="line">  builder.CreateRet(Add1CallRes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now we create the JIT.</span></span><br><span class="line">  ExecutionEngine* EE = EngineBuilder(<span class="built_in">std</span>::move(Owner)).create();</span><br><span class="line"></span><br><span class="line">  outs() &lt;&lt; <span class="string">"We just constructed this LLVM module:\n\n"</span> &lt;&lt; *M;</span><br><span class="line">  outs() &lt;&lt; <span class="string">"\n\nRunning foo: "</span>;</span><br><span class="line">  outs().flush();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call the `foo' function with no arguments:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;GenericValue&gt; noargs;</span><br><span class="line">  GenericValue gv = EE-&gt;runFunction(FooF, noargs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Import result of execution:</span></span><br><span class="line">  outs() &lt;&lt; <span class="string">"Result: "</span> &lt;&lt; gv.IntVal &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">delete</span> EE;</span><br><span class="line">  llvm_shutdown();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<h2 id="开发LLVM项目"><a href="#开发LLVM项目" class="headerl]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译器架构的王者LLVM——（1）现代编译器架构]]></title>
    <link href="http://sunxfancy.github.io/2016/03/28/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85%E2%80%94%E2%80%94LLVM/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85LLVM%E2%80%94%E2%80%94%EF%BC%881%EF%BC%89%E7%8E%B0%E4%BB%A3%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84/"/>
    <id>http://sunxfancy.github.io/2016/03/28/编译器架构的王者——LLVM/编译器架构的王者LLVM——（1）现代编译器架构/</id>
    <published>2016-03-28T15:45:02.466Z</published>
    <updated>2015-12-06T10:53:00.444Z</updated>
    <content type="html"><![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<h2 id="现代编译器架构"><a href="#现代编译器架构" class="headerlink" title="现代编译器架构"></a>现代编译器架构</h2><p>编译器技术，作为计算机科学的皇后，从诞生起，就不断推进着计算机科学的发展，编译器的发展史，简直就是计算机发展史的缩影，而编译器的架构也逐句变得更加优雅，独立性更强。</p>
<p>但说到编译器的架构，可能还留存着编译原理课程的印象，5个经典流程：<br>词法分析 -&gt; 语法分析 -&gt; 语义分析 -&gt; 中间代码优化 -&gt; 目标代码生成</p>
<p>一般，我们会将编译器分为一个前端，一个后端，前端负责处理源代码，后端负责生成目标代码。<br>但软件工程，就是在不断的抽象和分层，分层解决问题是重要的特点，分层能够增加层之间的独立性，更好的完成任务。</p>
<h3 id="LLVM中间代码优化"><a href="#LLVM中间代码优化" class="headerlink" title="LLVM中间代码优化"></a>LLVM中间代码优化</h3><p>LLVM的一大特色就是，有着独立的、完善的、严格约束的中间代码表示。这种中间代码，就是LLVM的字节码，是LLVM抽象的精髓，前端生成这种中间代码，后端自动进行各类优化分析，让用LLVM开发的编译器，都能用上最先见的后端优化技术。</p>
<p><img src="http://www.aosabook.org/images/llvm/SimpleCompiler.png" alt=""></p>
<p>LLVM另外一大特色就是自带JIT，要知道，这可是在原来很难想象的技术，一个编译器要想实现JIT，是需要进行大量努力的，即时翻译代码，还要兼顾效率和编译时间，可不是一件简单的事情。<br>但如果你用上了LLVM，JIT只是其中的副产品，直接就可以使用的。</p>
<p>LLVM将中间代码优化这个流程做到了极致，LLVM工具链，不但可以生成所支持的各个后端平台的代码，更可以方便的将各语言的前端编译后的模块链接到一起，你可以方便的在你的语言中调用C函数。</p>
<p><img src="http://www.aosabook.org/images/llvm/RetargetableCompiler.png" alt=""></p>
<h3 id="可读的中间代码"><a href="#可读的中间代码" class="headerlink" title="可读的中间代码"></a>可读的中间代码</h3><p>LLVM中间代码是非常易读的，而且拥有很多高级结构，例如类型和结构体、元数据等，使用起来非常方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; Declare the string constant as a global constant.</span><br><span class="line">@.str = private unnamed_addr constant [13 x i8] c&quot;hello world\0A\00&quot;</span><br><span class="line"></span><br><span class="line">; External declaration of the puts function</span><br><span class="line">declare i32 @puts(i8* nocapture) nounwind</span><br><span class="line"></span><br><span class="line">; Definition of main function</span><br><span class="line">define i32 @main() &#123;   ; i32()*</span><br><span class="line">  ; Convert [13 x i8]* to i8  *...</span><br><span class="line">  %cast210 = getelementptr [13 x i8], [13 x i8]* @.str, i64 0, i64 0</span><br><span class="line"></span><br><span class="line">  ; Call puts function to write out the string to stdout.</span><br><span class="line">  call i32 @puts(i8* %cast210)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Named metadata</span><br><span class="line">!0 = !&#123;i32 42, null, !&quot;string&quot;&#125;</span><br><span class="line">!foo = !&#123;!0&#125;</span><br></pre></td></tr></table></figure>
<p>这是一段HelloWorld的LLVM字节码，我们发现很清晰，而且几乎所有的位置都有注明类型，这也是在强调，LLVM是强类型的，每个变量和临时值，都要有明确的类型定义。</p>
<p>下面是结构体的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%mytype = type &#123; %mytype*, i32 &#125;</span><br></pre></td></tr></table></figure></p>
<p>非常遗憾的是，这个结构体的定义只有类型序列信息，没有对应子成员的名称，这是让编译器前端自行保存和查表，来记录这些信息。</p>
<p>C函数的调用非常方便，只需要简单的声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">declare i32 @printf(i8* noalias nocapture, ...)</span><br><span class="line">declare i32 @atoi(i8 zeroext)</span><br></pre></td></tr></table></figure></p>
<p>你可以将源码用LLVM编译成.bc，然后用llc编译成.o，再拿Clang链接上各个库就可以了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<h2 id="现代编译器架构"><a href="#现代编译器架构" class="headerlin]]>
    </summary>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://sunxfancy.github.io/2016/03/28/%E7%BC%96%E8%AF%91%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%8B%E8%80%85%E2%80%94%E2%80%94LLVM/LLVM%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E5%A3%B0%E6%98%8E%E6%8F%92%E5%85%A5/"/>
    <id>http://sunxfancy.github.io/2016/03/28/编译器架构的王者——LLVM/LLVM函数的调用时声明插入/</id>
    <published>2016-03-28T15:45:02.444Z</published>
    <updated>2015-11-14T11:38:04.957Z</updated>
    <content type="html"><![CDATA[<p>LLVM函数的调用时声明插入</p>
<p>如果调用一个未声明的函数，我们知道肯定是不正确的，但符号表中，可能预先存有该函数的    FunctionType，这时即使未扫描到该函数，我们也可以用Module中的getOrInsertFunction方法，获取或插入一个函数。</p>
<p>Constant <em> Module::getOrInsertFunction (<br>    StringRef         Name,<br>    FunctionType </em>     T,<br>    AttributeSet     AttributeList<br>)</p>
<p>其行为是这样的：</p>
<ol>
<li>如果不存在，创建一个原型</li>
<li>存在，但是一个static的局部函数，那么创建一个新的全局函数替换之</li>
<li>存在，而且类型正确，返回当前函数</li>
<li>存在，类型不匹配，那么会在外层包一个constantexpr cast的语句，转换到正确的类型上</li>
</ol>
<p>是不是很方便呢？<br>这样应该可以减少一次函数的声明遍历。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>LLVM函数的调用时声明插入</p>
<p>如果调用一个未声明的函数，我们知道肯定是不正确的，但符号表中，可能预先存有该函数的    FunctionType，这时即使未扫描到该函数，我们也可以用Module中的getOrInsertFunction方法，获取或插入一个函数]]>
    </summary>
    
  </entry>
  
</feed>
