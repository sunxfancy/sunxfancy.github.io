<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>西风广场</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="横笛笑看今古事，立剑醉谈定江山">
<meta property="og:type" content="website">
<meta property="og:title" content="西风广场">
<meta property="og:url" content="http://sunxfancy.github.io/index.html">
<meta property="og:site_name" content="西风广场">
<meta property="og:description" content="横笛笑看今古事，立剑醉谈定江山">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="西风广场">
<meta name="twitter:description" content="横笛笑看今古事，立剑醉谈定江山">
  
    <link rel="alternative" href="/atom.xml" title="西风广场" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/sxf.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">西风逍遥游</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/sunxfancy" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:sunxfancy@gmail.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/sun-xiao-fan-3" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/16-04/" style="font-size: 10px;">16.04</a> <a href="/tags/Html/" style="font-size: 10px;">Html</a> <a href="/tags/LLVM/" style="font-size: 10px;">LLVM</a> <a href="/tags/Sphinx/" style="font-size: 10px;">Sphinx</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/Xenial/" style="font-size: 10px;">Xenial</a> <a href="/tags/Xerus/" style="font-size: 10px;">Xerus</a> <a href="/tags/中文文档/" style="font-size: 10px;">中文文档</a> <a href="/tags/发布/" style="font-size: 10px;">发布</a> <a href="/tags/并行/" style="font-size: 10px;">并行</a> <a href="/tags/文法/" style="font-size: 10px;">文法</a> <a href="/tags/解析/" style="font-size: 10px;">解析</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.vvliebe.com/">vvliebe的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">西风逍遥游，一只热爱生活的技术粉</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">西风逍遥游</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/sxf.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">西风逍遥游</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/sunxfancy" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:sunxfancy@gmail.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/sun-xiao-fan-3" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-2016/并行Html解析算法的分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/22/2016/并行Html解析算法的分析/" class="article-date">
  	<time datetime="2016-04-22T14:22:00.000Z" itemprop="datePublished">2016-04-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/22/2016/并行Html解析算法的分析/">并行Html解析算法的分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>并行Html解析作为一个研究性课题来说，十分具有挑战性。因为html特有的上下文关联特性，使得它很难被一般的自动机解析，即使是支持大部分编程语言的下推自动机，也很难描述。</p>
<p>本文，就从html的特点分析入手，解释html语法的特点，和将其并行化的一些思考。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Html/">Html</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并行/">并行</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/文法/">文法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/解析/">解析</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/04/22/2016/并行Html解析算法的分析/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-2016/Hello Ubuntu &#39;Xenial Xerus&#39; " class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/21/2016/Hello Ubuntu 'Xenial Xerus' /" class="article-date">
  	<time datetime="2016-04-21T20:11:00.000Z" itemprop="datePublished">2016-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/21/2016/Hello Ubuntu 'Xenial Xerus' /">Hello Ubuntu &#39;Xenial Xerus&#39; </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天，Canonical发布了Ubuntu 16.04 LTS ‘Xenial Xerus’，作为一个长期支持版，确实很让人期待。</p>
<p>Ubuntu 16.04提供了很多激动人心的新功能。</p>
<p>例如新的内核升级到Linux4.4，大量的软件版本更新，而且Ubuntu 16.04将会是最后一个支持32位架构的Ubuntu系统，日后将会是64位的时代。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/16-04/">16.04</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/">Ubuntu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Xenial/">Xenial</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Xerus/">Xerus</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/发布/">发布</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/04/21/2016/Hello Ubuntu 'Xenial Xerus' /#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-编译器架构的王者——LLVM/LLVM函数的调用时声明插入" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/21/编译器架构的王者——LLVM/LLVM函数的调用时声明插入/" class="article-date">
  	<time datetime="2016-04-21T14:22:22.930Z" itemprop="datePublished">2016-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>LLVM函数的调用时声明插入</p>
<p>如果调用一个未声明的函数，我们知道肯定是不正确的，但符号表中，可能预先存有该函数的    FunctionType，这时即使未扫描到该函数，我们也可以用Module中的getOrInsertFunction方法，获取或插入一个函数。</p>
<p>Constant <em> Module::getOrInsertFunction (<br>    StringRef         Name,<br>    FunctionType </em>     T,<br>    AttributeSet     AttributeList<br>)</p>
<p>其行为是这样的：</p>
<ol>
<li>如果不存在，创建一个原型</li>
<li>存在，但是一个static的局部函数，那么创建一个新的全局函数替换之</li>
<li>存在，而且类型正确，返回当前函数</li>
<li>存在，类型不匹配，那么会在外层包一个constantexpr cast的语句，转换到正确的类型上</li>
</ol>
<p>是不是很方便呢？<br>这样应该可以减少一次函数的声明遍历。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（2）——C语言也能实现面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/21/C和C++的面向对象专题/C和C++的面向对象专题（2）——C语言也能实现面向对象/" class="article-date">
  	<time datetime="2016-04-21T14:22:22.930Z" itemprop="datePublished">2016-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/21/C和C++的面向对象专题/C和C++的面向对象专题（2）——C语言也能实现面向对象/">C和C++的面向对象专题（2）——C语言也能实现面向对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="二、C语言也能实现面向对象"><a href="#二、C语言也能实现面向对象" class="headerlink" title="二、C语言也能实现面向对象"></a>二、C语言也能实现面向对象</h2><p>今天要为大家介绍C语言的面向对象设计方法，正如题记上面所说，面向对象是一种思想，而并非是一种语言，我们将会介绍C语言实现的面向对象开发方式。</p>
<h3 id="简单实用的C语言面向对象设计思路"><a href="#简单实用的C语言面向对象设计思路" class="headerlink" title="简单实用的C语言面向对象设计思路"></a>简单实用的C语言面向对象设计思路</h3><p>众所周知，C++中的面向对象十分方便，但在C中，并没有类，但我们可以通过C的结构体来实现，然后，手动将this指针传入<br>目前这个方法，应该是C语言设计中，简便易用的方式，而且能较好的体现面向对象的设计思路，然而遗憾的是，没有继承和多态。</p>
<p>例如，我们这样一个C++类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> test &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    test(<span class="keyword">char</span>* str, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;str = str;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);	</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">char</span>* str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么我们可以这样转换为一个C类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test.h */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _test &#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">char</span>* str;</span><br><span class="line">&#125; test;</span><br><span class="line"></span><br><span class="line"><span class="function">test* <span class="title">TestCreate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowMessage</span><span class="params">(test*)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test.c */</span></span><br><span class="line"></span><br><span class="line"><span class="function">test* <span class="title">TestCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    return (test*) <span class="built_in">malloc</span>(sizeof(test));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowMessage</span><span class="params">(test* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; t-&gt;k; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, t-&gt;str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实思路也很清晰，思路简单易懂，实现也很清新明快，在各类C工程中使用极为广泛。</p>
<h3 id="复杂的基于GObject的面向对象程序设计"><a href="#复杂的基于GObject的面向对象程序设计" class="headerlink" title="复杂的基于GObject的面向对象程序设计"></a>复杂的基于GObject的面向对象程序设计</h3><p>如果你希望学习C语言的GUI程序设计，那么，必定要学习的就是GObject的类实现方式。<br>GObject相当于从C层面上模拟了一个C++的类对象模型，实现当然相对复杂的多。</p>
<p>下面我们来实际看一下一个GTK的窗口类，这是GTK+-3.0的一段样例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* appwin.h */</span><br><span class="line">#ifndef APPWIN_H</span><br><span class="line">#define APPWIN_H</span><br><span class="line"></span><br><span class="line">#include &quot;app.h&quot;</span><br><span class="line">#include &lt;gtk/gtk.h&gt;</span><br><span class="line"></span><br><span class="line">/* 该类的类型定义以及类型转换宏 */</span><br><span class="line">#define APP_WINDOW_TYPE (app_window_get_type())</span><br><span class="line">#define APP_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), APP_WINDOW_TYPE, AppWindow))</span><br><span class="line"></span><br><span class="line">/* 该类分成两部分，一部分是成员，一部分是类本身 */</span><br><span class="line">typedef struct _AppWindow      AppWindow;</span><br><span class="line">typedef struct _AppWindowClass AppWindowClass;</span><br><span class="line"></span><br><span class="line">GType      app_window_get_type (void);</span><br><span class="line">AppWindow* app_window_new      (App *app);</span><br><span class="line">void       app_window_open     (AppWindow *win, GFile *file);</span><br><span class="line"></span><br><span class="line">#endif // APPWIN_H</span><br></pre></td></tr></table></figure>
<p>而其真实的定义是在.c文件中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _AppWindow</span><br><span class="line">&#123;</span><br><span class="line">    GtkApplicationWindow parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _AppWindowClass</span><br><span class="line">&#123;</span><br><span class="line">    GtkApplicationWindowClass parent_class;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _AppWindowPrivate AppWindowPrivate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _AppWindowPrivate</span><br><span class="line">&#123;</span><br><span class="line">    GSettings *settings;</span><br><span class="line">    GtkWidget *<span class="built_in">stack</span>;</span><br><span class="line">    GtkWidget *search;</span><br><span class="line">    GtkWidget *searchbar;</span><br><span class="line">    GtkWidget *searchentry;</span><br><span class="line">    GtkWidget *gears;</span><br><span class="line">    GtkWidget *sidebar;</span><br><span class="line">    GtkWidget *words;</span><br><span class="line">    GtkWidget *lines;</span><br><span class="line">    GtkWidget *lines_label;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">G_DEFINE_TYPE_WITH_PRIVATE(AppWindow, app_window, GTK_TYPE_APPLICATION_WINDOW);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后面有具体的实现方法，这里就不一一列举 */</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现，这种定义方式比C++中的其实更有优势，封装的更加彻底。为何这样说呢？首先，我们的声明文件十分的简洁，如果公开方法不修改的话，那么将其余内容如何改动，都不会影响我们的外部接口。</p>
<p>其次，由于需要显示的向GObject注册，那么动态进行类注册就成为可能，这样的设计优势表现在哪里呢？多语言的互通性就很好了，因为很多动态语言，是支持类的动态加载以及反射加载的。</p>
<p>另外，vala语言就是基于GObject类型的，他是一门新兴的编译时语言，但其也有很多动态语言的特性，用其开发gtk程序，比C具有明显的优势。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（3）——C++中的不优雅特性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/21/C和C++的面向对象专题/C和C++的面向对象专题（3）——C++中的不优雅特性/" class="article-date">
  	<time datetime="2016-04-21T14:22:22.930Z" itemprop="datePublished">2016-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/21/C和C++的面向对象专题/C和C++的面向对象专题（3）——C++中的不优雅特性/">C和C++的面向对象专题（3）——C++中的不优雅特性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="三、C-中的不优雅特性"><a href="#三、C-中的不优雅特性" class="headerlink" title="三、C++中的不优雅特性"></a>三、C++中的不优雅特性</h2><p>今天来说一说C++中不优雅的一些问题，C++虽然是面向对象的设计语言，但也有很多缺陷和弊病，我们将会讨论如何通过良好的设计解决这些问题。</p>
<h3 id="C-编译缓慢"><a href="#C-编译缓慢" class="headerlink" title="C++编译缓慢"></a>C++编译缓慢</h3><p>C++编译慢已经成为了业界共识，一个大型C++项目甚至要用专用的服务器编译好久才能完成，Java和.net作为大型开发平台， 却也没发现编译如此缓慢的问题，那么究竟是什么，导致了C++编译难的问题呢？</p>
<h3 id="模板的纠结"><a href="#模板的纠结" class="headerlink" title="模板的纠结"></a>模板的纠结</h3><p>C++中模板有个很神奇的问题，就是实现和声明都必须被使用者引用，这段模板代码才有效，也就是说，模板是在编译时展开的代码生成机制。</p>
<p>我们不妨做个实验，这是类的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class CObject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CObject(T k) &#123;obj = k;&#125;</span><br><span class="line">    ~CObject() &#123;&#125;</span><br><span class="line">    T getObj();</span><br><span class="line">private:</span><br><span class="line">    T obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面是类的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;CObject.h&quot;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T CObject&lt;T&gt;::getObj()&#123;</span><br><span class="line">    return this-&gt;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主函数中调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;CObject.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    CObject&lt;int&gt; Obj(10);</span><br><span class="line">    int k = Obj.getObj();</span><br><span class="line">    printf(&quot;%d\n&quot;, k);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一切看起来是那么的顺利，但是！我的电脑给我显示如下错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scanning dependencies of target template_test</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/template_test.dir/src/CObject.cpp.o</span><br><span class="line">[100%] Building CXX object CMakeFiles/template_test.dir/src/main.cpp.o</span><br><span class="line">Linking CXX executable template_test</span><br><span class="line">CMakeFiles/template_test.dir/src/main.cpp.o：在函数‘main’中：</span><br><span class="line">main.cpp:(.text+0x22)：对‘CObject&lt;int&gt;::getObj()’未定义的引用</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make[2]: *** [template_test] 错误 1</span><br><span class="line">make[1]: *** [CMakeFiles/template_test.dir/all] 错误 2</span><br><span class="line">make: *** [all] 错误 2</span><br></pre></td></tr></table></figure></p>
<p>链接器告诉我，我们找不到一个叫做‘CObject<int>::getObj()’的函数，恩？为何，我们不是将类实现链接进来了么？</int></p>
<p>如果你这样想就错了，上网查找解决方案，得到的回复居然是这样：<br><code>#include &quot;CObject.h&quot;</code> =&gt; <code>#include &quot;CObject.cpp&quot;</code></p>
<p>omg，那我还不如把两个文件写成一个hpp来的方便呢，其实C++也是推荐你这样做的，理由就是——模板是编译时，在用到的时候进行代码展开得到的<br>如果不这样做，链接器是不会找到对应的代码的。</p>
<p>那么也找到了很多大型工程如boost库，为何编译缓慢的直接原因，大量的模板展开消耗了巨大的资源，而且模板展开是很不利于代码复用的，同样的算法，换一种类型，必须全部编译，生成新的代码，并且这类模板生成的代码，不能提前编译成二进制库，这样的结果就是，项目哪里改动一点，好多文件重复编译，造成编译十分缓慢。</p>
<h3 id="封装的问题"><a href="#封装的问题" class="headerlink" title="封装的问题"></a>封装的问题</h3><p>C++的类并没有很好的将代码封起来，这和上次讲到的GObject对比可以发现，C++的私有变量是一同放置在类的声明中，而我们知道，一个类的声明，是会被很多其他类引用的。<br>那么，思考我们的C++编译过程，很多类都引用了一个.h文件，那么这个.h文件一旦发生更改，那么所有引用这个文件的cpp文件都将被触发重复编译，而我们在实现一个类时，对类的成员函数小修小补是很平常的，但由于封装的不彻底，那么我们的项目又将被反复编译，带来编译的速度缓慢。</p>
<p>而且，如果是库的话，那么私有成员的更新甚至还会影响用户使用，非常麻烦。<br>例如下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">public:</span><br><span class="line">    Test();</span><br><span class="line">    ~Test();</span><br><span class="line"></span><br><span class="line">    void Show();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::string message;</span><br><span class="line">    int pointer;</span><br><span class="line">    void formatMessage(std::string&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>很明显，一般的C++类，私有成员都会比公开成员多，那么私有成员修改一点，哪怕只是一不小心多了个空格，都会带来这个文件的更新，触发makefile的重编译，带来了低效率。</p>
<h3 id="缺乏反射机制"><a href="#缺乏反射机制" class="headerlink" title="缺乏反射机制"></a>缺乏反射机制</h3><p>最新的C++11，引入了众多的新特性，包括好用的auto关键字以及模板元编程特性等，但这些，还是不能弥补反射机制缺失带来的影响。反射是对象串行化、GUI界面事件响应和根据数据动态调用代码等技术的核心，缺乏反射机制，会使得C++很多地方十分的不便。</p>
<p>很多大型软件，如firefox，在实现中，往往搭建了反射框架，供系统使用。但由于C++本身语法的问题，缺乏反射依旧会使得类书写变得困难。</p>
<h3 id="跨平台困难"><a href="#跨平台困难" class="headerlink" title="跨平台困难"></a>跨平台困难</h3><p>C++的跨平台性真的不好，甚至很多编译器上都会出现匪夷所思的问题，例如在不同平台上，基本类型的大小会随CPU字长而变化，如果有跨平台需求的软件，最好使用跨平台定义的类型。<br>C++的结构体中数据往往有内存对齐的问题，有些编译器还能通过编译器指令对其设置，这些问题最好还是能避开就避开。</p>
<p>跨平台时，还应小心异常处理的代码，因为有些版本的C++编译器对抛出的异常规格并不很遵守规范。<br>另外，不同平台的宽字符集也是大问题，往往并不能轻松统一，另外MinGW里貌似就没有宽字符- -</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（4）——解决封装，避免接口" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/21/C和C++的面向对象专题/C和C++的面向对象专题（4）——解决封装，避免接口/" class="article-date">
  	<time datetime="2016-04-21T14:22:22.930Z" itemprop="datePublished">2016-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/21/C和C++的面向对象专题/C和C++的面向对象专题（4）——解决封装，避免接口/">C和C++的面向对象专题（4）——解决封装，避免接口</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="四、解决封装，避免接口"><a href="#四、解决封装，避免接口" class="headerlink" title="四、解决封装，避免接口"></a>四、解决封装，避免接口</h2><p>恩，今天我们来讨论，如何通过设计，解决C++中的不优雅特性，改进项目的结构，改善编译速度。</p>
<p>上次我们提到，如果一个类的封装不好，容易导致种种不便，那么如何设计能够避免这种现象呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">public:</span><br><span class="line">    void print() &#123;</span><br><span class="line">        printf(&quot;Hello\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void print2() &#123;</span><br><span class="line">        printf(&quot;K : %d\n&quot;, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="简要的改进，将函数的实现移动到类cpp实现文件中"><a href="#简要的改进，将函数的实现移动到类cpp实现文件中" class="headerlink" title="简要的改进，将函数的实现移动到类cpp实现文件中"></a>简要的改进，将函数的实现移动到类cpp实现文件中</h3><p>最简单的想法就是将实现和声明分开，这也是C++提倡的，这样虽然文件会增多，但编译速度和代码的清晰度会提升。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* test.h */</span><br><span class="line">class test &#123;</span><br><span class="line">public:</span><br><span class="line">    void print();</span><br><span class="line">    void print2();</span><br><span class="line">private:</span><br><span class="line">    int k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* test.cpp */</span><br><span class="line">#include &quot;test.h&quot;</span><br><span class="line">void test::print() &#123;</span><br><span class="line">    printf(&quot;Hello\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test::print2() &#123;</span><br><span class="line">    printf(&quot;K : %d\n&quot;, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显的，这样我们改动cpp文件中，.h文件不会受到影响，但假若我的private方法增加了，那么还是需要改动.h文件，进而会影响所有引用我的部分，为了避免这种情况出现，有什么好设计方法么？</p>
<h3 id="使用接口降低代码耦合"><a href="#使用接口降低代码耦合" class="headerlink" title="使用接口降低代码耦合"></a>使用接口降低代码耦合</h3><p>一种标准的设计模式是使用接口，这在很多库的设计时也被经常采用，核心思想是通过多态调用的方式，避免内部方法的暴露。</p>
<p>接口一般就是C++的多态类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* Itest.h */</span><br><span class="line">class Itest &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void print() = 0;</span><br><span class="line">    virtual void print2() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern ITest* createItest(); // 类似工厂的方式为你构建类</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Itest.cpp */</span><br><span class="line">#include &quot;test.h&quot;</span><br><span class="line"></span><br><span class="line">ITest* createItest() &#123;</span><br><span class="line">    return new test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让test从这个接口继承出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* test.h */</span><br><span class="line">class test : public Itest &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void print();</span><br><span class="line">    virtual void print2();</span><br><span class="line">private:</span><br><span class="line">    int k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样的好处当然十分明显了，将类转成接口的形式，就能方便的修改下面的实现类，无论实现类如何改动，都在模块范围内，接口不变。<br>但这样做的坏处也很明显，如果C++大量使用这样的方式实现内部封装，那么很多情况下效率比较低，而且代码复杂度就上来了，需要添加很多的接口类。</p>
<h3 id="轻便的成员类封装"><a href="#轻便的成员类封装" class="headerlink" title="轻便的成员类封装"></a>轻便的成员类封装</h3><p>下面介绍一种简单的方式来实现类封装性的提升，首先还是看这个test类，我们将其提示为test2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* test2.h */</span><br><span class="line">class test2 &#123;</span><br><span class="line">public:</span><br><span class="line">    void print();</span><br><span class="line">    void print2();</span><br><span class="line">private:</span><br><span class="line">    int k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里的k实际上并不需要写在这里，我们需要的是将private的部分整体的封装成一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* test2.h */</span><br><span class="line">class test2_private;</span><br><span class="line"></span><br><span class="line">class test2 &#123;</span><br><span class="line">public:</span><br><span class="line">    test2();</span><br><span class="line">    test2(int);</span><br><span class="line">    ~test2();</span><br><span class="line"></span><br><span class="line">    void print();</span><br><span class="line">    void print2();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    test2_private* that;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* test2.cpp */</span><br><span class="line">#include &quot;test2.h&quot;</span><br><span class="line"></span><br><span class="line">class test2_private &#123;</span><br><span class="line">public:</span><br><span class="line">    int k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test2::test2() &#123;</span><br><span class="line">    that = new test2_private();</span><br><span class="line">    that-&gt;k = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test2::test2(int k) &#123;</span><br><span class="line">    that = new test2_private();</span><br><span class="line">    that-&gt;k = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2::~test2() &#123;</span><br><span class="line">    delete that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我们发现，这种封装可以很有效的解决类的接口不便的问题，而由于只使用了类指针，所以我们并不需要前向声明这个私有类，于是这个类可以方便的被修改，从而避免了接口和多态调用的问题。</p>
<p>这种设计还有一个用途，假若你有另外的代码生成器生成的代码，需要和已有的类嵌入使用，那么推荐使用这种方式，Qt中就是这样做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MAINWINDOW_H</span><br><span class="line">#define MAINWINDOW_H</span><br><span class="line"></span><br><span class="line">#include &lt;QMainWindow&gt;</span><br><span class="line"></span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class MainWindow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainWindow : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit MainWindow(QWidget *parent = 0);</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // MAINWINDOW_H</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &quot;ui_mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(new Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现这里有一个神奇的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespace Ui &#123;</span><br><span class="line">class MainWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实这只是另外一个类，和本类并不同名，Ui::MainWindow是qt设计器帮忙生成的类，用来标注UI界面生成的一些代码，为了让代码很好的和我们自己的类统一起来，他们用了这种方式。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（5）——合理使用模板，避免代码冗余" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/21/C和C++的面向对象专题/C和C++的面向对象专题（5）——合理使用模板，避免代码冗余/" class="article-date">
  	<time datetime="2016-04-21T14:22:22.930Z" itemprop="datePublished">2016-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/21/C和C++的面向对象专题/C和C++的面向对象专题（5）——合理使用模板，避免代码冗余/">C和C++的面向对象专题（5）——合理使用模板，避免代码冗余</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="五、合理使用模板，避免代码冗余"><a href="#五、合理使用模板，避免代码冗余" class="headerlink" title="五、合理使用模板，避免代码冗余"></a>五、合理使用模板，避免代码冗余</h2><p>下面我们来讨论一下，如何解决模板的不易封装的问题。</p>
<p>我们提供这样一种思路，对于链表一类的通用类型，我们尽量采取强制类型转换的方式，尽量避免模板的滥用。</p>
<p>同样，我们应该避免对结构体的直接存储，尽量使用类似java的指针传递方式来传递对象。</p>
<p>我们首先来写一个单类型的list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ifndef LIST_C_H</span><br><span class="line">#define LIST_C_H</span><br><span class="line"></span><br><span class="line">class list_c_private;</span><br><span class="line">struct list_c_node;</span><br><span class="line"></span><br><span class="line">class list_c &#123;</span><br><span class="line">public:</span><br><span class="line">    list_c();</span><br><span class="line">    ~list_c();</span><br><span class="line"></span><br><span class="line">    void insert(void*);</span><br><span class="line">    int size();</span><br><span class="line">    void* get(int);</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    list_c_private* priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // LIST_C_H</span><br></pre></td></tr></table></figure>
<p>这里我们使用了上面讲到的封装方式，降低了类间的耦合度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;list_c.h&quot;</span><br><span class="line"></span><br><span class="line">class list_c_private</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int size;</span><br><span class="line">    list_c_node* head;</span><br><span class="line">&#125;;	</span><br><span class="line"></span><br><span class="line">struct list_c_node</span><br><span class="line">&#123;</span><br><span class="line">    void* data;</span><br><span class="line">    list_c_node* next;</span><br><span class="line"></span><br><span class="line">    list_c_node() &#123;</span><br><span class="line">        data = next = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_c::list_c() &#123;</span><br><span class="line">    priv = new list_c_private();</span><br><span class="line">    priv-&gt;head = new list_c_node();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list_c::~list_c() &#123;</span><br><span class="line">    delete priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void list_c::insert(void* data) &#123;</span><br><span class="line">    list_c_node* p;</span><br><span class="line">    for (p = priv-&gt;head; p-&gt;next != nullptr; p = p-&gt;next) &#123;&#125;</span><br><span class="line">    p-&gt;next = new list_c_node();</span><br><span class="line">    p-&gt;next-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int list_c::size() &#123;</span><br><span class="line">    return priv-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* list_c::get(int k) &#123;</span><br><span class="line">    int t; list_c_node* p;</span><br><span class="line">    for (p = priv-&gt;head-&gt;next, t = 0; p != nullptr &amp;&amp; t != k ; p = p-&gt;next, ++t) &#123;&#125;</span><br><span class="line">    return p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的链表，只是作为示例使用，写了插入和获取的两个方法。</p>
<p>而为了通用性支持，我们写一个模板，进行类型的强制转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#ifndef LIST</span><br><span class="line">#define LIST</span><br><span class="line"></span><br><span class="line">#include &quot;list_c.h&quot;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class list &#123;</span><br><span class="line">public:</span><br><span class="line">    list() &#123; clist = new list_c(); &#125;</span><br><span class="line">    ~list() &#123; delete clist; &#125;</span><br><span class="line"></span><br><span class="line">    void insert(T data) &#123;</span><br><span class="line">        clist-&gt;insert((void*)data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size() &#123; return clist-&gt;size(); &#125;</span><br><span class="line"></span><br><span class="line">    T get(int k) &#123;</span><br><span class="line">        return (T)clist-&gt;get(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    list_c* clist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // LIST</span><br></pre></td></tr></table></figure>
<p>这样，带来的好处有，首先能够将模板封装操作，其次，能够在封装类中，动态的调整内部实例。<br>对于一个传入的类型，你可以判断一下，是否适合当前的模板，如果不适合，可以在其中动态的报错。</p>
<p>最后是模板的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;list&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    list&lt;long&gt; testlist;</span><br><span class="line">    testlist.insert(10);</span><br><span class="line">    testlist.insert(20);</span><br><span class="line"></span><br><span class="line">    long k = testlist.get(1);</span><br><span class="line">    printf(&quot;%d\n&quot;, k);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（6）——C++也能反射" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/21/C和C++的面向对象专题/C和C++的面向对象专题（6）——C++也能反射/" class="article-date">
  	<time datetime="2016-04-21T14:22:22.930Z" itemprop="datePublished">2016-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/21/C和C++的面向对象专题/C和C++的面向对象专题（6）——C++也能反射/">C和C++的面向对象专题（6）——C++也能反射</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="六、C-也能反射"><a href="#六、C-也能反射" class="headerlink" title="六、C++也能反射"></a>六、C++也能反射</h2><p>今天我们来探讨C++的反射问题，缺乏反射机制一直是C++的大问题，很多系统的设计时，需要根据外部资源文件的定义，动态的调用内部的函数和接口，如果没有反射，将很难将外部的数据，转换为内部的方法。</p>
<p>Java和.net的反射机制很容易实现，由于其动态语言的特性，在编译时就存储了大量的<strong>元数据</strong>，而在动态装载时，也是根据这些元数据载入的模块。由于C++缺乏这些信息，往往并不能很好的动态装载和链接。操作系统为了实现C和C++的动态装载功能，特意设计了动态链接库，将符号表保存在动态库中，运行时重定位代码，然后进行链接操作。而这是操作系统实现的，并不能很好的被用在用户工程中，所以我们有必要自己构建一套<strong>元数据</strong>集合，保存反射所需的内容。</p>
<h3 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h3><p>反射的核心就是根据字符串名字，创建对应的类或者调用对应类的方法，为此，我们使用C++中的map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, meta_class*&gt;</span><br></pre></td></tr></table></figure>
<p>meta_class 是保存一个类中的关键元数据用的类，可以支持反射构造，反射调用函数等功能。</p>
<p>meta_func 是保存一个方法的关键信息类，但由于方法有不定的参数和返回类型，我们使用模板的方式，将一个抽象存储的成员函数指针，转换为我们确定类型的成员函数指针，然后再去调用，达到动态调用的目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename R, typename... Args&gt;</span><br><span class="line">R Call(T* that, Args... args) &#123;</span><br><span class="line">    R (T::*mp)();</span><br><span class="line">    mp = *((R (T::**)())func_pointer);</span><br><span class="line">    return (that-&gt;*mp)(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的代码十分混乱，如果你没学过C的函数指针的话，建议先去补习一下函数指针的定义和用法。</p>
<p>这里涉及到的是成员函数指针的传递，一会儿将会详细讲解如何传递任意一个函数指针。</p>
<h3 id="反射类对象"><a href="#反射类对象" class="headerlink" title="反射类对象"></a>反射类对象</h3><p>首先，我们肯定要为类对象建立meta_class的模型，但每个meta_class，应该都能够构建本类的对象，为了实现这一特点，我们想到了模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class MetaClass : public IMetaClass &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void* CreateObject() &#123;</span><br><span class="line">        return new T();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了让每个类都能有统一的创建方法，我们将使用IMetaClass接口进行多态调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class IMetaClass &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void* CreateObject() = 0;</span><br><span class="line"></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    T* Create() &#123;</span><br><span class="line">        return (T*) CreateObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void AddFunc(const std::string s, MetaFunc* c) &#123; func_map[s] = c; &#125;</span><br><span class="line">    MetaFunc* GetFunc(const std::string s) &#123;</span><br><span class="line">        if (func_map.find(s) != func_map.end()) return func_map[s];</span><br><span class="line">        else return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::map&lt;const std::string, MetaFunc*&gt; func_map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们在接口类中编写了方法和成员函数，我觉得这是C++的优势，不像Java，为了安全性，而取消了这么简单好用的功能。</p>
<p>接口统一实现相同的类对象构建方式，避免了在实现类中反复编写的困难。</p>
<p>这样，我们只要在每个类的定义时，向我们的类注册器注册该MetaClass对象就可以了</p>
<p>但问题是，如何才能在类定义时编写代码呢？我们的C和C++可是只能在函数中调用代码，不能像脚本一样随时随地执行。</p>
<h3 id="利用全局对象的构造函数执行代码"><a href="#利用全局对象的构造函数执行代码" class="headerlink" title="利用全局对象的构造函数执行代码"></a>利用全局对象的构造函数执行代码</h3><p>我们发现，C++有一个很有趣的特性，有些代码是可以在main函数执行前就执行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    test() &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;,&quot;Hello Ctor!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test show_message();</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;Main function run!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，哦？好像不大对，貌似我们的对象并没有启动，这有可能是被编译器优化掉了。。。= =！<br>控制台的显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sxf@sxf-PC:~/data/workspace/C++/OObyCpp/testCppRunCode$ ./main</span><br><span class="line">Main function run!</span><br></pre></td></tr></table></figure></p>
<p>稍加改动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    test(const char* msg) &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test show_message(&quot;Hello Ctor!&quot;);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;Main function run!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好的，我们发现构造函数运行在了main函数之前，也就是我们的类型定义的构造期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sxf@sxf-PC:~/data/workspace/C++/OObyCpp/testCppRunCode$ ./main</span><br><span class="line">Hello Ctor!</span><br><span class="line">Main function run!</span><br></pre></td></tr></table></figure></p>
<p>具体想详细了解C++的运行环境的细节，推荐看一本英文的开源书：<br>【How to Make a Computer Operating System】<br>这本书讲解如何利用C++开发了一个小型操作系统，而在C++运行时的导入过程中，就介绍了C++全局对象构造函数的运行过程，可以清楚的看出，C++的主函数在汇编层的调用流程是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    push ebx</span><br><span class="line">     </span><br><span class="line">static_ctors_loop: 					; 全局构造函数初始化</span><br><span class="line">   mov ebx, start_ctors</span><br><span class="line">   jmp .test</span><br><span class="line">.body:</span><br><span class="line">   call [ebx]</span><br><span class="line">   add ebx,4</span><br><span class="line">.test:</span><br><span class="line">   cmp ebx, end_ctors</span><br><span class="line">   jb .body</span><br><span class="line"> </span><br><span class="line">   call kmain  						; 调用主函数</span><br><span class="line"> </span><br><span class="line">static_dtors_loop:					; 全局对象的析构函数调用</span><br><span class="line">   mov ebx, start_dtors</span><br><span class="line">   jmp .test</span><br><span class="line">.body:</span><br><span class="line">   call [ebx]</span><br><span class="line">   add ebx,4</span><br><span class="line">.test:</span><br><span class="line">   cmp ebx, end_dtors</span><br><span class="line">   jb .body</span><br></pre></td></tr></table></figure>
<p>于是我们可以这样编写一个类，专门用来注册一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class reflector_class &#123;</span><br><span class="line">public:</span><br><span class="line">    reflector_class(const char* name, IMetaClass* meta_class) &#123;</span><br><span class="line">        ClassRegister::Add(name, meta_class);</span><br><span class="line">        printf(&quot;define class: %s\n&quot;, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类的对象在构造时，会去调用ClassRegister类中的静态方法，向其中添加类名和类元数据</p>
<h3 id="利用宏定义处理类的注册"><a href="#利用宏定义处理类的注册" class="headerlink" title="利用宏定义处理类的注册"></a>利用宏定义处理类的注册</h3><p>我们希望每个类对象能够方便的找到自己的meta_class，最简单的方式就是将其添加为自己的成员，为何不用继承机制呢？首先继承较为复杂，并且父类也同样可能拥有meta_class, 我们希望每个类型都能方便的找到meta_class，那么可以建一条Reflectible宏，让大家写在class中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef Reflectible</span><br><span class="line">#define Reflectible \</span><br><span class="line">public:\</span><br><span class="line">    static IMetaClass* meta_class;\</span><br><span class="line">private:</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>为了避免放置在最上面时，影响下面成员的private的默认定义，所以写成这样。</p>
<p>我们在写一个宏，让用户添加到类的cpp文件中，真正定义该meta_class对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef ReflectClass</span><br><span class="line">#define ReflectClass(class_name) \</span><br><span class="line">    IMetaClass* class_name :: meta_class = new MetaClass&lt; class_name &gt;(); \</span><br><span class="line">    reflector_class class_name##reflector_class( #class_name , class_name::meta_class)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>这里我们用到了两个宏技巧：</p>
<pre><code>## 表示将两个符号连接在一起，由于词法分析中，宏是按照词的顺序分隔的，如果直接连接，往往会造成符号分析不清。
#something 表示将该内容展开成字符串的形式 =&gt; &quot;something data&quot;，所以我们可以很方便的用这个宏将宏符号转为字符串传入到函数中。
</code></pre><h3 id="反射成员函数"><a href="#反射成员函数" class="headerlink" title="反射成员函数"></a>反射成员函数</h3><p>首先编写一个能调用成员函数的模板类，根据我们的反射原理，将一个函数指针转换为成员函数的指针：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MetaFunc &#123;</span><br><span class="line">public:</span><br><span class="line">    MetaFunc(void* p) &#123; func_pointer = p; &#125;</span><br><span class="line">    void setFuncPointer(void* p) &#123; func_pointer = p; &#125;</span><br><span class="line">    template &lt;typename T, typename R, typename... Args&gt;</span><br><span class="line">    R Call(T* that, Args... args) &#123;</span><br><span class="line">        R (T::*mp)();</span><br><span class="line">        mp = *((R (T::**)())func_pointer);</span><br><span class="line">        return (that-&gt;*mp)(args...);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void* func_pointer;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我在这里使用了C++11的新特性，可变参数的模板，这样可以更方便的接受目标参数<br>如果我们直接对成员函数取地址，返回的是一个return_type (ClassName::<em>)(args)这样的成员函数指针。<br>注意，成员函数指针不能直接被传递，成员函数指针由于包含了很多其他数据信息，并不能被被强制类型转换成void</em>,一个显而易见的例子是，成员函数指针，往往比较大，最大的指针甚至可以达到20byte。</p>
<p>为了能够传递函数指针，我们可以将成员函数指针赋值给一个该成员函数指针类型的对象，然后再对这个指针对象取地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto p = &amp;test::print;</span><br><span class="line">&amp;p  //这个地址可以被轻松传递</span><br></pre></td></tr></table></figure>
<p>这个地址是一个指针的指针<code>return_type (ClassName::**)(args)</code><br>于是就有了我们前面代码中，强制类型转换的方法</p>
<h3 id="利用C语言的可变参数函数来定义函数"><a href="#利用C语言的可变参数函数来定义函数" class="headerlink" title="利用C语言的可变参数函数来定义函数"></a>利用C语言的可变参数函数来定义函数</h3><p>我们目前要将地址传递过来，但是我们并不知道每个类中有多少个函数，所以我们要使用C语言的宏，对可变参数进行处理。</p>
<p>下面将reflector_class进行一下修改，支持多个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class reflector_class &#123;</span><br><span class="line">public:</span><br><span class="line">    reflector_class(const char* name, IMetaClass* meta_class, ...) &#123;</span><br><span class="line">        ClassRegister::Add(name, meta_class);</span><br><span class="line">        printf(&quot;define class: %s\n&quot;, name);</span><br><span class="line"></span><br><span class="line">        va_list ap;</span><br><span class="line">        va_start(ap, meta_class);  </span><br><span class="line">        for (int arg = va_arg(ap, int); arg != -1; arg = va_arg(ap, int) ) </span><br><span class="line">        &#123;</span><br><span class="line">            std::string name(va_arg(ap, const char*));  </span><br><span class="line">            void* p = va_arg(ap, void*);</span><br><span class="line">            if (arg == 0) &#123;</span><br><span class="line">                printf(&quot;\tdefine func: %s\n&quot;, name.c_str());</span><br><span class="line">                MetaFunc* f = new MetaFunc(p);</span><br><span class="line">                meta_class-&gt;AddFunc(name, f);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                printf(&quot;\tdefine prop: %s\n&quot;, name.c_str());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        va_end(ap);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<pre><code>va_list ap; 可变参数列表

va_start(ap, meta_class);  这里的第二个参数，是当前函数的最后一个固定参数位置

void* p = va_arg(ap, void*); 可以用来获得一个固定类型的参数
</code></pre><p>使用过后释放资源：</p>
<pre><code>va_end(ap);  
</code></pre><p>为了支持函数和属性两种声明，我们定义如下宏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#ifndef DefReflectFunc</span><br><span class="line">#define DefReflectFunc(class_name, func_name) \</span><br><span class="line">    auto func_name##_function_pointer = &amp;class_name::func_name</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef ReflectClass</span><br><span class="line">#define ReflectClass(class_name) \</span><br><span class="line">    IMetaClass* class_name :: meta_class = new MetaClass&lt; class_name &gt;(); \</span><br><span class="line">    reflector_class class_name##reflector_class( #class_name , class_name::meta_class ,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef ReflectFunc</span><br><span class="line">#define ReflectFunc(func_name) \</span><br><span class="line">    0, #func_name, _F(func_name##_function_pointer) ,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef ReflectProp</span><br><span class="line">#define ReflectProp(prop_names) \</span><br><span class="line">    1, #prop_names, _F(prop_names) ,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef _F</span><br><span class="line">#define _F(x) reinterpret_cast&lt;void*&gt;(&amp;x)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef End</span><br><span class="line">#define End -1 )</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>这样我们在cpp中使用这些宏时只需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DefReflectFunc(test2,print2);</span><br><span class="line">ReflectClass(test2)</span><br><span class="line">    ReflectFunc(print2)</span><br><span class="line">End;</span><br></pre></td></tr></table></figure></p>
<h3 id="类的全局注册难题"><a href="#类的全局注册难题" class="headerlink" title="类的全局注册难题"></a>类的全局注册难题</h3><p>好的，关键的部分已经都清楚了，但目前我们还欠缺一个很重要的类，就是类的全局注册器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ClassRegister</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static std::map&lt;const std::string, IMetaClass*&gt; class_map;</span><br><span class="line">    static void Add(const std::string s, IMetaClass* k) &#123;</span><br><span class="line">        class_map[s] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这个类有一个严重的漏洞，会造成程序崩溃，我们在接下来的章节中，将会介绍这个尴尬的问题的发生原因。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/21/hello-world/" class="article-date">
  	<time datetime="2016-04-21T14:22:22.930Z" itemprop="datePublished">2016-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/21/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（7）——单例模式解决静态成员对象和全局对象的构造顺序难题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/21/C和C++的面向对象专题/C和C++的面向对象专题（7）——单例模式解决静态成员对象和全局对象的构造顺序难题/" class="article-date">
  	<time datetime="2016-04-21T14:22:22.930Z" itemprop="datePublished">2016-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/21/C和C++的面向对象专题/C和C++的面向对象专题（7）——单例模式解决静态成员对象和全局对象的构造顺序难题/">C和C++的面向对象专题（7）——单例模式解决静态成员对象和全局对象的构造顺序难题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="七、单例模式解决静态成员对象和全局对象的构造顺序难题"><a href="#七、单例模式解决静态成员对象和全局对象的构造顺序难题" class="headerlink" title="七、单例模式解决静态成员对象和全局对象的构造顺序难题"></a>七、单例模式解决静态成员对象和全局对象的构造顺序难题</h2><p>上回书说道，我们的程序有一个隐藏的漏洞，如果ClassRegister这个类所在的.o文件，如果在所有.o文件中是第一个被链接的的，那么就不会出问题。<br>这么说太抽象了，让我们画个图表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassRegister.o</span><br><span class="line">--------------------</span><br><span class="line">Meta.o</span><br><span class="line">--------------------</span><br><span class="line">Main.o</span><br></pre></td></tr></table></figure>
<p>这样的结构，也就是链接顺序要这样指定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main ClassRegister.o Meta.o Main.o</span><br></pre></td></tr></table></figure></p>
<p>就不会出问题，但如果调换一下顺序就可能出问题。</p>
<p>思考一下原因，ClassRegister中的map对象，是一个全局对象，而我们注册类的时候，也使用了全局对象的构造函数，两个谁先执行呢？这个就不得而知了，C++并未说明两个谁先谁后，而一般链接器，都是从前往后链接代码，而构造函数的执行顺序，也往往和链接时的顺序有关。</p>
<p>但这样实现就很不好，我们的系统居然要靠链接器的顺序才能正确编译执行，太不可靠了，万一用户没注意到这一点，直接编译链接，就会出现未知的错误。</p>
<p>那么如何避免这种情况呢？</p>
<h3 id="C-的单例模式"><a href="#C-的单例模式" class="headerlink" title="C++的单例模式"></a>C++的单例模式</h3><p>C++中有一种极好的设计模式很适合这种情况，那就是用单例，单例模式也很容易理解，核心就是推迟构造，如果没有使用时，就不会被构造，被用到时，对象就会构造，并且仅一次，最常见的写法就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CSingleton  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    CSingleton()   //构造函数是私有的  </span><br><span class="line">    &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    static CSingleton *m_pInstance;  </span><br><span class="line">public:  </span><br><span class="line">    static CSingleton * GetInstance()  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(m_pInstance == NULL)  //判断是否第一次调用  </span><br><span class="line">            m_pInstance = new CSingleton();  </span><br><span class="line">        return m_pInstance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，我们这里并没有考虑多线程，因为多线程时单例模式一般要加锁来保障不会多次构造引发冲突。</p>
<p>于是经过简要修改，就能用单例模式设计一个类注册器了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ClassRegister</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    ClassRegister() &#123; printf(&quot;register\n&quot;); &#125;  //构造函数是私有的   </span><br><span class="line">    std::map&lt;const std::string, IMetaClass*&gt; class_map;</span><br><span class="line">public:</span><br><span class="line">    static ClassRegister * GetInstance() &#123;  </span><br><span class="line">        static ClassRegister instance;   //局部静态变量  </span><br><span class="line">        return &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Add(const std::string s, IMetaClass* k) &#123;</span><br><span class="line">        GetInstance()-&gt;class_map[s] = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static IMetaClass* Get(const std::string s) &#123;</span><br><span class="line">        std::map&lt;const std::string, IMetaClass*&gt;&amp; m =  GetInstance()-&gt;class_map;</span><br><span class="line">        if (m.find(s) != m.end()) return m[s];</span><br><span class="line">        else return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个类注册器简单实用，采用的设计方式和指针的模式稍有不同，这里用到了局部静态变量的概念。<br>局部静态变量能够改变对象的生存周期，这样就能很好的符合我们的要求。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 西风逍遥游
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>