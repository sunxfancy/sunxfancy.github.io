<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>西风广场</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="横笛笑看今古事，立剑醉谈定江山">
<meta property="og:type" content="website">
<meta property="og:title" content="西风广场">
<meta property="og:url" content="http://sunxfancy.github.io/index.html">
<meta property="og:site_name" content="西风广场">
<meta property="og:description" content="横笛笑看今古事，立剑醉谈定江山">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="西风广场">
<meta name="twitter:description" content="横笛笑看今古事，立剑醉谈定江山">
  
    <link rel="alternative" href="/atom.xml" title="西风广场" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/sxf.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">西风逍遥游</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/sunxfancy" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:sunxfancy@gmail.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/sun-xiao-fan-3" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.vvliebe.com/">vvliebe的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">西风逍遥游，一只热爱生活的技术粉</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">西风逍遥游</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/sxf.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">西风逍遥游</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/sunxfancy" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:sunxfancy@gmail.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/sun-xiao-fan-3" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（8）——更为高级的预处理器PHP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（8）——更为高级的预处理器PHP/" class="article-date">
  	<time datetime="2016-03-28T15:45:02.491Z" itemprop="datePublished">2016-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（8）——更为高级的预处理器PHP/">C和C++的面向对象专题（8）——更为高级的预处理器PHP</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="八、更为高级的预处理器PHP"><a href="#八、更为高级的预处理器PHP" class="headerlink" title="八、更为高级的预处理器PHP"></a>八、更为高级的预处理器PHP</h2><p>C++的宏在某些情况下非常难用，例如将代码展开成为这样：</p>
<p>Macro( A, B, C, D )</p>
<p>=&gt;</p>
<p>func(“A”, A);<br>func(“B”, B);<br>func(“C”, C);<br>func(“D”, D);</p>
<p>test(A);<br>test(B);<br>test(C);<br>test(D);</p>
<p>这对于宏来说，太困难了，为了能实现复杂的宏展开，我们希望用更高级的预处理器来实现该功能。</p>
<p>我们这里使用PHP进行代码的预处理工作，将PHP代码当做C++的宏使用。<br>当然，你也可以用python做代码生成工作，但由于php是内嵌式的，处理起来可能更方便一些，当然，其他语言配上模板也是可以的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.php */</span></span><br><span class="line">&lt;?php $return_m = <span class="string">"return a + b;"</span> ?&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">true&lt;?php echo $return_m; ?&gt; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="built_in">cout</span> &lt;&lt; func(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">true<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用如下指令生成C++代码：</p>
<pre><code>php main.php &gt; main.cpp
</code></pre><p>好的，下面就和正常的项目编译一样了，你甚至可以将php的命令写入到makefile中，自动化生成</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（9）——Gtkmm的最佳实践" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（9）——Gtkmm的最佳实践/" class="article-date">
  	<time datetime="2016-03-28T15:45:02.490Z" itemprop="datePublished">2016-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（9）——Gtkmm的最佳实践/">C和C++的面向对象专题（9）——Gtkmm的最佳实践</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="九、Gtkmm的最佳实践"><a href="#九、Gtkmm的最佳实践" class="headerlink" title="九、Gtkmm的最佳实践"></a>九、Gtkmm的最佳实践</h2><p>在跨平台的gui开发中，Qt一直是非常受欢迎的GUI开发框架，但Qt一个是依赖反射，需要特殊的预处理步骤，一个是库太过庞大，这就造成了一些不便的地方。今天介绍给大家的是Gtk库的C++绑定，Gtkmm，一个方便的跨平台GUI开发框架。</p>
<p>由于是C++的封装，GTK不再那么的难以使用，变得简洁优雅，而且效率非常高，编译也较QT快许多。<br>虽然C也能编写，而且我们之前也介绍过了GObject的使用。但比较其实现起来较为繁琐，代码行数较C++多一些，而且每个成员函数都要手动传入this指针，较为不便。</p>
<p>现在C++如果合理的封装和按照之前的设计思想进行设计，结构十分紧凑，而且书写非常方便，非常易用。</p>
<h3 id="Gtkmm版的2048程序设计"><a href="#Gtkmm版的2048程序设计" class="headerlink" title="Gtkmm版的2048程序设计"></a>Gtkmm版的2048程序设计</h3><p>为了更好的实践，我们举一个简单的2048小游戏的程序作为实例。大家会发现，合理的设计，能够使代码既清晰明了，又方便维护，可靠性很高。<br>我们简要的进行一下程序设计，这里我们不是要学会2048如何制作，而是要体会程序设计中的思想，以及设计中的美感和艺术感。</p>
<p>首先，2048作为一个简单的小游戏，广受大家喜欢，原理很简单，在一个4×4的数组中，让数字不断向各个方向合并，每次进行后，随机位置创建新数字。</p>
<p>程序界面，一个窗口，上面一行标签书写当前得分，下面一个绘图界面，自由绘图，画上4×4个的矩阵，上面书写内容。</p>
<p>程序结构设计，按照一般程序架构设计，可以用MVC的结构，一个界面类，负责显示，一个控制类，负责游戏逻辑，一个模型类，负责数据的存储与管理。</p>
<p>但由于数据的管理太过简单，就放弃了模型类，直接使用一个4×4的矩阵就完成任务。</p>
<h3 id="程序实践"><a href="#程序实践" class="headerlink" title="程序实践"></a>程序实践</h3><p>由于Gtkmm的良好封装，我们并不需要太多复杂的处理，首先是Main文件引导程序的启动，所有gtk程序集合都是这样引导。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">* @Author: sxf</span><br><span class="line">* @Date:   2015-05-07 12:22:40</span><br><span class="line">* @Last Modified by:   sxf</span><br><span class="line">* @Last Modified time: 2015-05-20 21:58:16</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtkmm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"game.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">trueGlib::RefPtr&lt;Gtk::Application&gt; app = Gtk::Application::create(argc, argv, <span class="string">"org.abs.gtk2048"</span>);</span><br><span class="line"></span><br><span class="line">trueGame game;</span><br><span class="line">true<span class="comment">//Shows the window and returns when it is closed.</span></span><br><span class="line">true<span class="keyword">return</span> app-&gt;run(game);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Game类作为最核心的窗口类，也是游戏的主要控制类，并不需要暴露什么方法给外部成员使用，所以它的定义很简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">* @Author: sxf</span><br><span class="line">* @Date:   2015-05-19 11:20:42</span><br><span class="line">* @Last Modified by:   sxf</span><br><span class="line">* @Last Modified time: 2015-05-20 21:58:35</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GAME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GAME_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtkmm/window.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Game_private;</span><br><span class="line"><span class="keyword">class</span> Game : <span class="keyword">public</span> Gtk::Window</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">trueGame();</span><br><span class="line">true<span class="keyword">virtual</span> ~Game();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">trueGame_private* priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GAME_H</span></span></span><br></pre></td></tr></table></figure></p>
<p>这种写法，就是在前几章提到的增强代码封装性的方法，通过一个priv指针，解决了C++封装不完善的问题。</p>
<p>这样还有一个很大的好处就是，由于priv指针的书写较为繁琐，如果在public方法中，反复的通过priv指针调用函数，就会显得无比麻烦，但这正提醒你，你的写法有问题，因为一般的方法，要尽可能写成内部的private的，这样你在不自觉的时刻，就形成了最大化private方法，最小化接口的设计习惯，这对于提升程序的内聚性，很有意义。</p>
<p>于是我们的Game类的内部定义就变得十分复杂，但这就使得代码内聚性更高，暴露给外层的接口就更简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Game_private</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">trueGame_private(Game* game);</span><br><span class="line">true~Game_private();</span><br><span class="line">true</span><br><span class="line"> 	Game* game;</span><br><span class="line">trueMyArea m_area;		// 渲染类</span><br><span class="line">trueGtk::Box m_box;		// 布局控件</span><br><span class="line">trueGtk::Label m_score;	// 得分标签</span><br><span class="line">trueint score;			// 得分具体数字</span><br><span class="line">trueconst static int fx[4][2];</span><br><span class="line"></span><br><span class="line">trueint data[4][4];		// 数据模型</span><br><span class="line"></span><br><span class="line">truebool combine(int i, int j, int k); 	// 将一个位置的数字向下合并</span><br><span class="line"></span><br><span class="line">truebool randomNew();	// 随机创建新数字</span><br><span class="line"></span><br><span class="line">truevoid cleanData();	// 删除全部数字，用来开局初始化</span><br><span class="line"></span><br><span class="line">truevoid gameWin();		// 显示用户胜利</span><br><span class="line"></span><br><span class="line">truevoid gameOver();	// 显示游戏结束</span><br><span class="line"></span><br><span class="line">truevoid gameRun(int k);	// 游戏控制循环</span><br><span class="line"></span><br><span class="line">truebool on_key_press_event(GdkEventKey* event); // 监听键盘事件响应</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我不喜欢比脸还长的函数，但这里的函数设计的还是不是那么尽如人意，虽然如此，这里也是本着简单易懂的方式设计的。</p>
<p>这里的combine方法设计的很特殊，因为合并时，还有可能出现游戏胜利的情况，所以里面包含了判断胜利的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool combine(int i, int j, int k) &#123;</span><br><span class="line">trueint ni = i; int nj = j;</span><br><span class="line">trueni += fx[k][0];	// fx是方向数组</span><br><span class="line">truenj += fx[k][1];</span><br><span class="line">trueint obji = i, objj = j;</span><br><span class="line">truewhile ( 0 &lt;= ni &amp;&amp; ni &lt; 4 &amp;&amp;</span><br><span class="line">truetruetrue0 &lt;= nj &amp;&amp; nj &lt; 4 )		</span><br><span class="line">true// 防止越界，我这里比较贪便宜，很多人处理越界是通过在数组外增加一个特殊值的外边框来处理的</span><br><span class="line">true&#123;</span><br><span class="line">truetrueif (data[ni][nj] == 0) &#123;</span><br><span class="line">truetruetrueobji = ni; objj = nj;</span><br><span class="line">truetrue&#125; else &#123;</span><br><span class="line">truetruetrueif (data[ni][nj] == data[i][j]) &#123;</span><br><span class="line">truetruetruetruescore += (1 &lt;&lt; data[ni][nj]);	// 处理得分</span><br><span class="line">truetruetruetrue++data[ni][nj];</span><br><span class="line">truetruetruetruedata[i][j] = 0;</span><br><span class="line">truetruetruetrueif (data[ni][nj] == 12) return true; // 处理胜利条件</span><br><span class="line">truetruetruetruereturn false;</span><br><span class="line">truetruetrue&#125; else break;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrueni += fx[k][0];</span><br><span class="line">truetruenj += fx[k][1];</span><br><span class="line">true&#125;</span><br><span class="line">trueif (!(obji == i &amp;&amp; objj == j)) &#123;	// 未能合并的情况</span><br><span class="line">truetruedata[obji][objj] = data[i][j];</span><br><span class="line">truetruedata[i][j] = 0;</span><br><span class="line">true&#125;</span><br><span class="line">truereturn false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数设计的很健壮，考虑了许多边界条件，这么做是在模拟物体碰撞时，碰撞面不断挤压的情况。例如下面的情况：<br>1 1 2 4<br>0 0 0 0<br>0 0 0 0<br>0 0 0 0<br>向左合并，能够一次就被合成为8，但这也是和外层的合并顺序控制是分不开的<br>在游戏主循环控制时，是这样处理的，对于不同的方向，循环顺序是不一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void gameRun(int k) &#123;</span><br><span class="line">truetruebool winflag = false;</span><br><span class="line">truetrueswitch (k) &#123;</span><br><span class="line">truetruetruecase 0 : </span><br><span class="line">truetruetruetruefor (int i = 0; i &lt; 4; ++i)</span><br><span class="line">truetruetruetruetruefor (int j = 0; j &lt; 4; ++j)</span><br><span class="line">truetruetruetruetruetrueif (combine(i,j,k)) winflag = true;</span><br><span class="line">truetruetruebreak;</span><br><span class="line">truetruetruecase 1 : </span><br><span class="line">truetruetruetruefor (int j = 3; j &gt;= 0; --j)</span><br><span class="line">truetruetruetruetruefor (int i = 0; i &lt; 4; ++i)</span><br><span class="line">truetruetruetruetruetrueif (combine(i,j,k)) winflag = true;</span><br><span class="line">truetruetruebreak;</span><br><span class="line">truetruetruecase 2 : </span><br><span class="line">truetruetruetruefor (int i = 3; i &gt;= 0; --i)</span><br><span class="line">truetruetruetruetruefor (int j = 0; j &lt; 4; ++j)</span><br><span class="line">truetruetruetruetruetrueif (combine(i,j,k)) winflag = true;</span><br><span class="line">truetruetruebreak;</span><br><span class="line">truetruetruecase 3 : </span><br><span class="line">truetruetruetruefor (int j = 0; j &lt; 4; ++j)</span><br><span class="line">truetruetruetruetruefor (int i = 0; i &lt; 4; ++i)</span><br><span class="line">truetruetruetruetruetrueif (combine(i,j,k)) winflag = true;</span><br><span class="line">truetruetruebreak;</span><br><span class="line">truetrue&#125;</span><br><span class="line"></span><br><span class="line">truetrue// 判断胜负条件</span><br><span class="line">truetrueif (winflag) &#123;</span><br><span class="line">truetruetruegameWin();</span><br><span class="line">truetruetruereturn;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrueif (!randomNew()) &#123;</span><br><span class="line">truetruetruegameOver();</span><br><span class="line">truetrue&#125;</span><br><span class="line"></span><br><span class="line">truetrueGlib::RefPtr&lt;Gdk::Window&gt; win = game-&gt;get_window();</span><br><span class="line">truetrueif (win)</span><br><span class="line">truetrue&#123;</span><br><span class="line">truetruetruem_area.setData(data);</span><br><span class="line">truetrue    Gdk::Rectangle r(0, 0, 600, 600);</span><br><span class="line">truetrue    win-&gt;invalidate_rect(r, false);</span><br><span class="line">truetruetruem_area.show();</span><br><span class="line">truetruetruechar score_text[20]; memset(score_text, 0, 20);</span><br><span class="line">truetruetruesprintf(score_text, &quot;Score : %d&quot;, score);</span><br><span class="line">truetruetruem_score.set_text(score_text);</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br></pre></td></tr></table></figure></p>
<p>而创建新数字的方式也很清晰，但这里使用模拟栈的方式进行了处理。<br>设计很独特，由于目前的位置数目有限，直接rand的方式，效率较低，我们先扫描所有可能的位置，然后将其入栈，random时，直接找一个位置，然后直接随机从其中找一个就可以了。数组模拟栈的方式，主要是希望避免vector的低效率，实现较简易。而且扩展较方便，如果你想random跟多，修改起来也十分方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool randomNew() &#123;</span><br><span class="line">trueint empty_block[17][2]; int sum = 0;</span><br><span class="line">truefor (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">truetruefor (int j = 0; j &lt; 4; ++j) &#123;</span><br><span class="line">truetruetrueif (data[i][j] == 0) &#123;</span><br><span class="line">truetruetruetrueempty_block[sum][0] = i; </span><br><span class="line">truetruetruetrueempty_block[sum][1] = j;</span><br><span class="line">truetruetruetrue++sum;</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">trueif (sum &lt; 1) return false;</span><br><span class="line"></span><br><span class="line">trueint t = rand() % sum;</span><br><span class="line">truedata[ empty_block[t][0] ][ empty_block[t][1] ] = (rand() % 4) &lt; 3 ? 1 : 2;</span><br><span class="line">trueempty_block[t][0] = empty_block[sum-1][0];</span><br><span class="line">trueempty_block[t][1] = empty_block[sum-1][1]; </span><br><span class="line">true--sum;</span><br><span class="line">true</span><br><span class="line">truereturn true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染类十分简单，主要就是根据数组中的数值，渲染出对应的图像，设计思想就是不断将问题抽象，不断简化，将复杂的问题从上层一层层拨开，这样就使得结构更加简洁优雅。</p>
<p>整个项目完整代码已经放到Github上了，需要的可以参考：<br><a href="https://github.com/sunxfancy/Gtk2048" target="_blank" rel="external">【github仓库】</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（1）——何为面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（1）——何为面向对象/" class="article-date">
  	<time datetime="2016-03-28T15:45:02.489Z" itemprop="datePublished">2016-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（1）——何为面向对象/">C和C++的面向对象专题（1）——何为面向对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>面向对象是一种思想，而不是一门语言<br>我们上哪去找对象，都面向对象去了</p>
<p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="一、何为面向对象"><a href="#一、何为面向对象" class="headerlink" title="一、何为面向对象"></a>一、何为面向对象</h2><p>现在学软件开发，都讲面向对象的编程模型，其实也很简单。用一句话来总结，面向对象就是将方法和方法的属性整合在一起，让每个方法引用的属性值尽可能在对象内部，对外保持简洁的接口。</p>
<p>实现面向对象的设计，目标不是写类，而是设计结构，对每一个对象设计良好的接口和封装模式，将优雅的接口提供给使用者，最大程度的降低代码耦合。</p>
<p>面向对象的设计，可以用一本书来讲解，但我们这里将演示面向对象的基本思想和如何实现</p>
<h3 id="从一个简单的例子看对象"><a href="#从一个简单的例子看对象" class="headerlink" title="从一个简单的例子看对象"></a>从一个简单的例子看对象</h3><p>恩，那好，我们现在构建一个对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">truewindow(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height) &#123;</span><br><span class="line">truetrue<span class="keyword">this</span>.x = x; <span class="keyword">this</span>.y = y;</span><br><span class="line">truetrue<span class="keyword">this</span>.width = width;</span><br><span class="line">truetrue<span class="keyword">this</span>.height = height;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">true<span class="keyword">int</span> x, y, width, height;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 也许你还可以添加更多属性，例如透明度、子元素列表、菜单、状态栏等待</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一个基本的窗口对象，也许它并不能给你直观的印象，但我希望能通过其说明一些问题。<br>对象有公开方法，有私有属性，我们在构造这个对象的时候，将一些参数传入，那么我们发现，这个过程简化了我们对于某些方法的使用。</p>
<p>例如在C函数中，如何你希望绘制一些内容，那么你可能需要做的是写这样一个函数：</p>
<pre><code>int Draw(struct window*, int, int, int, int);
</code></pre><p>将全部的参数传入进去，但如果使用次数多后，我们发现参数大多一样，那么不如把他们都打包进入window结构体中，于是函数变成了这样：</p>
<pre><code>int Draw(struct window*);
</code></pre><p>这样我们只需要改变结构体中的值就可以了，这个思想，就是面向对象的基础，而C++正是让这要传入的结构体自动传入，进而演变为了this指针。</p>
<h3 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h3><p>几乎软件的设计原则都是高内聚，低耦合。</p>
<p>C++的设计也是一样，类的公共方法应该尽可能清晰明确，简单好用，而不必要外部了解的信息，和细节过程，都放入到私有成员中，避免被误用。</p>
<p>避免过度继承和重载，虽然继承和重载很大程度上能够降低两个模块间的耦合，但其实现复杂，结构混乱，容易使得代码不够清晰。同样，也要避免设计模式的滥用。</p>
<p>C++的开发应该本着面向对象的思想，利用类的封装特性，将模块内部的部分高效的组织在一起，而接口，可以采用多态调用的方式，保证灵活性。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（2）——C语言也能实现面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（2）——C语言也能实现面向对象/" class="article-date">
  	<time datetime="2016-03-28T15:45:02.488Z" itemprop="datePublished">2016-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（2）——C语言也能实现面向对象/">C和C++的面向对象专题（2）——C语言也能实现面向对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="二、C语言也能实现面向对象"><a href="#二、C语言也能实现面向对象" class="headerlink" title="二、C语言也能实现面向对象"></a>二、C语言也能实现面向对象</h2><p>今天要为大家介绍C语言的面向对象设计方法，正如题记上面所说，面向对象是一种思想，而并非是一种语言，我们将会介绍C语言实现的面向对象开发方式。</p>
<h3 id="简单实用的C语言面向对象设计思路"><a href="#简单实用的C语言面向对象设计思路" class="headerlink" title="简单实用的C语言面向对象设计思路"></a>简单实用的C语言面向对象设计思路</h3><p>众所周知，C++中的面向对象十分方便，但在C中，并没有类，但我们可以通过C的结构体来实现，然后，手动将this指针传入<br>目前这个方法，应该是C语言设计中，简便易用的方式，而且能较好的体现面向对象的设计思路，然而遗憾的是，没有继承和多态。</p>
<p>例如，我们这样一个C++类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> test &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">truetest(<span class="keyword">char</span>* str, <span class="keyword">int</span> k) &#123;</span><br><span class="line">truetrue<span class="keyword">this</span>-&gt;str = str;</span><br><span class="line">truetrue<span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">ShowMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">truetrue<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">truetruetrue<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);	</span><br><span class="line">true&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">true<span class="keyword">int</span> k;</span><br><span class="line">true<span class="keyword">char</span>* str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么我们可以这样转换为一个C类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test.h */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _test &#123;</span><br><span class="line">true<span class="keyword">int</span> k;</span><br><span class="line">true<span class="keyword">char</span>* str;</span><br><span class="line">&#125; test;</span><br><span class="line"></span><br><span class="line"><span class="function">test* <span class="title">TestCreate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowMessage</span><span class="params">(test*)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test.c */</span></span><br><span class="line"></span><br><span class="line"><span class="function">test* <span class="title">TestCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="keyword">return</span> (test*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowMessage</span><span class="params">(test* t)</span> </span>&#123;</span><br><span class="line">true<span class="keyword">int</span> i;</span><br><span class="line">true<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; t-&gt;k; ++i) &#123;</span><br><span class="line">truetrue<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, t-&gt;str);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实思路也很清晰，思路简单易懂，实现也很清新明快，在各类C工程中使用极为广泛。</p>
<h3 id="复杂的基于GObject的面向对象程序设计"><a href="#复杂的基于GObject的面向对象程序设计" class="headerlink" title="复杂的基于GObject的面向对象程序设计"></a>复杂的基于GObject的面向对象程序设计</h3><p>如果你希望学习C语言的GUI程序设计，那么，必定要学习的就是GObject的类实现方式。<br>GObject相当于从C层面上模拟了一个C++的类对象模型，实现当然相对复杂的多。</p>
<p>下面我们来实际看一下一个GTK的窗口类，这是GTK+-3.0的一段样例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* appwin.h */</span><br><span class="line">#ifndef APPWIN_H</span><br><span class="line">#define APPWIN_H</span><br><span class="line"></span><br><span class="line">#include &quot;app.h&quot;</span><br><span class="line">#include &lt;gtk/gtk.h&gt;</span><br><span class="line"></span><br><span class="line">/* 该类的类型定义以及类型转换宏 */</span><br><span class="line">#define APP_WINDOW_TYPE (app_window_get_type())</span><br><span class="line">#define APP_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), APP_WINDOW_TYPE, AppWindow))</span><br><span class="line"></span><br><span class="line">/* 该类分成两部分，一部分是成员，一部分是类本身 */</span><br><span class="line">typedef struct _AppWindow      AppWindow;</span><br><span class="line">typedef struct _AppWindowClass AppWindowClass;</span><br><span class="line"></span><br><span class="line">GType      app_window_get_type (void);</span><br><span class="line">AppWindow* app_window_new      (App *app);</span><br><span class="line">void       app_window_open     (AppWindow *win, GFile *file);</span><br><span class="line"></span><br><span class="line">#endif // APPWIN_H</span><br></pre></td></tr></table></figure>
<p>而其真实的定义是在.c文件中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _AppWindow</span><br><span class="line">&#123;</span><br><span class="line">trueGtkApplicationWindow parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _AppWindowClass</span><br><span class="line">&#123;</span><br><span class="line">trueGtkApplicationWindowClass parent_class;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _AppWindowPrivate AppWindowPrivate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _AppWindowPrivate</span><br><span class="line">&#123;</span><br><span class="line">trueGSettings *settings;</span><br><span class="line">trueGtkWidget *<span class="built_in">stack</span>;</span><br><span class="line">trueGtkWidget *search;</span><br><span class="line">trueGtkWidget *searchbar;</span><br><span class="line">trueGtkWidget *searchentry;</span><br><span class="line">trueGtkWidget *gears;</span><br><span class="line">trueGtkWidget *sidebar;</span><br><span class="line">trueGtkWidget *words;</span><br><span class="line">trueGtkWidget *lines;</span><br><span class="line">trueGtkWidget *lines_label;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">G_DEFINE_TYPE_WITH_PRIVATE(AppWindow, app_window, GTK_TYPE_APPLICATION_WINDOW);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后面有具体的实现方法，这里就不一一列举 */</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现，这种定义方式比C++中的其实更有优势，封装的更加彻底。为何这样说呢？首先，我们的声明文件十分的简洁，如果公开方法不修改的话，那么将其余内容如何改动，都不会影响我们的外部接口。</p>
<p>其次，由于需要显示的向GObject注册，那么动态进行类注册就成为可能，这样的设计优势表现在哪里呢？多语言的互通性就很好了，因为很多动态语言，是支持类的动态加载以及反射加载的。</p>
<p>另外，vala语言就是基于GObject类型的，他是一门新兴的编译时语言，但其也有很多动态语言的特性，用其开发gtk程序，比C具有明显的优势。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（3）——C++中的不优雅特性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（3）——C++中的不优雅特性/" class="article-date">
  	<time datetime="2016-03-28T15:45:02.487Z" itemprop="datePublished">2016-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（3）——C++中的不优雅特性/">C和C++的面向对象专题（3）——C++中的不优雅特性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="三、C-中的不优雅特性"><a href="#三、C-中的不优雅特性" class="headerlink" title="三、C++中的不优雅特性"></a>三、C++中的不优雅特性</h2><p>今天来说一说C++中不优雅的一些问题，C++虽然是面向对象的设计语言，但也有很多缺陷和弊病，我们将会讨论如何通过良好的设计解决这些问题。</p>
<h3 id="C-编译缓慢"><a href="#C-编译缓慢" class="headerlink" title="C++编译缓慢"></a>C++编译缓慢</h3><p>C++编译慢已经成为了业界共识，一个大型C++项目甚至要用专用的服务器编译好久才能完成，Java和.net作为大型开发平台， 却也没发现编译如此缓慢的问题，那么究竟是什么，导致了C++编译难的问题呢？</p>
<h3 id="模板的纠结"><a href="#模板的纠结" class="headerlink" title="模板的纠结"></a>模板的纠结</h3><p>C++中模板有个很神奇的问题，就是实现和声明都必须被使用者引用，这段模板代码才有效，也就是说，模板是在编译时展开的代码生成机制。</p>
<p>我们不妨做个实验，这是类的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class CObject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">trueCObject(T k) &#123;obj = k;&#125;</span><br><span class="line">true~CObject() &#123;&#125;</span><br><span class="line">trueT getObj();</span><br><span class="line">private:</span><br><span class="line">trueT obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面是类的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;CObject.h&quot;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T CObject&lt;T&gt;::getObj()&#123;</span><br><span class="line">truereturn this-&gt;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主函数中调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;CObject.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">trueCObject&lt;int&gt; Obj(10);</span><br><span class="line">trueint k = Obj.getObj();</span><br><span class="line">trueprintf(&quot;%d\n&quot;, k);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一切看起来是那么的顺利，但是！我的电脑给我显示如下错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scanning dependencies of target template_test</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/template_test.dir/src/CObject.cpp.o</span><br><span class="line">[100%] Building CXX object CMakeFiles/template_test.dir/src/main.cpp.o</span><br><span class="line">Linking CXX executable template_test</span><br><span class="line">CMakeFiles/template_test.dir/src/main.cpp.o：在函数‘main’中：</span><br><span class="line">main.cpp:(.text+0x22)：对‘CObject&lt;int&gt;::getObj()’未定义的引用</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make[2]: *** [template_test] 错误 1</span><br><span class="line">make[1]: *** [CMakeFiles/template_test.dir/all] 错误 2</span><br><span class="line">make: *** [all] 错误 2</span><br></pre></td></tr></table></figure></p>
<p>链接器告诉我，我们找不到一个叫做‘CObject<int>::getObj()’的函数，恩？为何，我们不是将类实现链接进来了么？</int></p>
<p>如果你这样想就错了，上网查找解决方案，得到的回复居然是这样：<br><code>#include &quot;CObject.h&quot;</code> =&gt; <code>#include &quot;CObject.cpp&quot;</code></p>
<p>omg，那我还不如把两个文件写成一个hpp来的方便呢，其实C++也是推荐你这样做的，理由就是——模板是编译时，在用到的时候进行代码展开得到的<br>如果不这样做，链接器是不会找到对应的代码的。</p>
<p>那么也找到了很多大型工程如boost库，为何编译缓慢的直接原因，大量的模板展开消耗了巨大的资源，而且模板展开是很不利于代码复用的，同样的算法，换一种类型，必须全部编译，生成新的代码，并且这类模板生成的代码，不能提前编译成二进制库，这样的结果就是，项目哪里改动一点，好多文件重复编译，造成编译十分缓慢。</p>
<h3 id="封装的问题"><a href="#封装的问题" class="headerlink" title="封装的问题"></a>封装的问题</h3><p>C++的类并没有很好的将代码封起来，这和上次讲到的GObject对比可以发现，C++的私有变量是一同放置在类的声明中，而我们知道，一个类的声明，是会被很多其他类引用的。<br>那么，思考我们的C++编译过程，很多类都引用了一个.h文件，那么这个.h文件一旦发生更改，那么所有引用这个文件的cpp文件都将被触发重复编译，而我们在实现一个类时，对类的成员函数小修小补是很平常的，但由于封装的不彻底，那么我们的项目又将被反复编译，带来编译的速度缓慢。</p>
<p>而且，如果是库的话，那么私有成员的更新甚至还会影响用户使用，非常麻烦。<br>例如下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">public:</span><br><span class="line">trueTest();</span><br><span class="line">true~Test();</span><br><span class="line"></span><br><span class="line">truevoid Show();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">truestd::string message;</span><br><span class="line">trueint pointer;</span><br><span class="line">truevoid formatMessage(std::string&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>很明显，一般的C++类，私有成员都会比公开成员多，那么私有成员修改一点，哪怕只是一不小心多了个空格，都会带来这个文件的更新，触发makefile的重编译，带来了低效率。</p>
<h3 id="缺乏反射机制"><a href="#缺乏反射机制" class="headerlink" title="缺乏反射机制"></a>缺乏反射机制</h3><p>最新的C++11，引入了众多的新特性，包括好用的auto关键字以及模板元编程特性等，但这些，还是不能弥补反射机制缺失带来的影响。反射是对象串行化、GUI界面事件响应和根据数据动态调用代码等技术的核心，缺乏反射机制，会使得C++很多地方十分的不便。</p>
<p>很多大型软件，如firefox，在实现中，往往搭建了反射框架，供系统使用。但由于C++本身语法的问题，缺乏反射依旧会使得类书写变得困难。</p>
<h3 id="跨平台困难"><a href="#跨平台困难" class="headerlink" title="跨平台困难"></a>跨平台困难</h3><p>C++的跨平台性真的不好，甚至很多编译器上都会出现匪夷所思的问题，例如在不同平台上，基本类型的大小会随CPU字长而变化，如果有跨平台需求的软件，最好使用跨平台定义的类型。<br>C++的结构体中数据往往有内存对齐的问题，有些编译器还能通过编译器指令对其设置，这些问题最好还是能避开就避开。</p>
<p>跨平台时，还应小心异常处理的代码，因为有些版本的C++编译器对抛出的异常规格并不很遵守规范。<br>另外，不同平台的宽字符集也是大问题，往往并不能轻松统一，另外MinGW里貌似就没有宽字符- -</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（4）——解决封装，避免接口" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（4）——解决封装，避免接口/" class="article-date">
  	<time datetime="2016-03-28T15:45:02.486Z" itemprop="datePublished">2016-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（4）——解决封装，避免接口/">C和C++的面向对象专题（4）——解决封装，避免接口</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="四、解决封装，避免接口"><a href="#四、解决封装，避免接口" class="headerlink" title="四、解决封装，避免接口"></a>四、解决封装，避免接口</h2><p>恩，今天我们来讨论，如何通过设计，解决C++中的不优雅特性，改进项目的结构，改善编译速度。</p>
<p>上次我们提到，如果一个类的封装不好，容易导致种种不便，那么如何设计能够避免这种现象呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class test &#123;</span><br><span class="line">public:</span><br><span class="line">truevoid print() &#123;</span><br><span class="line">truetrueprintf(&quot;Hello\n&quot;);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truevoid print2() &#123;</span><br><span class="line">truetrueprintf(&quot;K : %d\n&quot;, k);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">trueint k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="简要的改进，将函数的实现移动到类cpp实现文件中"><a href="#简要的改进，将函数的实现移动到类cpp实现文件中" class="headerlink" title="简要的改进，将函数的实现移动到类cpp实现文件中"></a>简要的改进，将函数的实现移动到类cpp实现文件中</h3><p>最简单的想法就是将实现和声明分开，这也是C++提倡的，这样虽然文件会增多，但编译速度和代码的清晰度会提升。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* test.h */</span><br><span class="line">class test &#123;</span><br><span class="line">public:</span><br><span class="line">truevoid print();</span><br><span class="line">truevoid print2();</span><br><span class="line">private:</span><br><span class="line">trueint k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* test.cpp */</span><br><span class="line">#include &quot;test.h&quot;</span><br><span class="line">void test::print() &#123;</span><br><span class="line">trueprintf(&quot;Hello\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test::print2() &#123;</span><br><span class="line">trueprintf(&quot;K : %d\n&quot;, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显的，这样我们改动cpp文件中，.h文件不会受到影响，但假若我的private方法增加了，那么还是需要改动.h文件，进而会影响所有引用我的部分，为了避免这种情况出现，有什么好设计方法么？</p>
<h3 id="使用接口降低代码耦合"><a href="#使用接口降低代码耦合" class="headerlink" title="使用接口降低代码耦合"></a>使用接口降低代码耦合</h3><p>一种标准的设计模式是使用接口，这在很多库的设计时也被经常采用，核心思想是通过多态调用的方式，避免内部方法的暴露。</p>
<p>接口一般就是C++的多态类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* Itest.h */</span><br><span class="line">class Itest &#123;</span><br><span class="line">public:</span><br><span class="line">truevirtual void print() = 0;</span><br><span class="line">truevirtual void print2() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern ITest* createItest(); // 类似工厂的方式为你构建类</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Itest.cpp */</span><br><span class="line">#include &quot;test.h&quot;</span><br><span class="line"></span><br><span class="line">ITest* createItest() &#123;</span><br><span class="line">truereturn new test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让test从这个接口继承出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* test.h */</span><br><span class="line">class test : public Itest &#123;</span><br><span class="line">public:</span><br><span class="line">truevirtual void print();</span><br><span class="line">truevirtual void print2();</span><br><span class="line">private:</span><br><span class="line">trueint k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样的好处当然十分明显了，将类转成接口的形式，就能方便的修改下面的实现类，无论实现类如何改动，都在模块范围内，接口不变。<br>但这样做的坏处也很明显，如果C++大量使用这样的方式实现内部封装，那么很多情况下效率比较低，而且代码复杂度就上来了，需要添加很多的接口类。</p>
<h3 id="轻便的成员类封装"><a href="#轻便的成员类封装" class="headerlink" title="轻便的成员类封装"></a>轻便的成员类封装</h3><p>下面介绍一种简单的方式来实现类封装性的提升，首先还是看这个test类，我们将其提示为test2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* test2.h */</span><br><span class="line">class test2 &#123;</span><br><span class="line">public:</span><br><span class="line">truevoid print();</span><br><span class="line">truevoid print2();</span><br><span class="line">private:</span><br><span class="line">trueint k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里的k实际上并不需要写在这里，我们需要的是将private的部分整体的封装成一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* test2.h */</span><br><span class="line">class test2_private;</span><br><span class="line"></span><br><span class="line">class test2 &#123;</span><br><span class="line">public:</span><br><span class="line">truetest2();</span><br><span class="line">truetest2(int);</span><br><span class="line">true~test2();</span><br><span class="line"></span><br><span class="line">truevoid print();</span><br><span class="line">truevoid print2();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">truetest2_private* that;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* test2.cpp */</span><br><span class="line">#include &quot;test2.h&quot;</span><br><span class="line"></span><br><span class="line">class test2_private &#123;</span><br><span class="line">public:</span><br><span class="line">trueint k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test2::test2() &#123;</span><br><span class="line">truethat = new test2_private();</span><br><span class="line">truethat-&gt;k = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test2::test2(int k) &#123;</span><br><span class="line">truethat = new test2_private();</span><br><span class="line">truethat-&gt;k = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test2::~test2() &#123;</span><br><span class="line">truedelete that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我们发现，这种封装可以很有效的解决类的接口不便的问题，而由于只使用了类指针，所以我们并不需要前向声明这个私有类，于是这个类可以方便的被修改，从而避免了接口和多态调用的问题。</p>
<p>这种设计还有一个用途，假若你有另外的代码生成器生成的代码，需要和已有的类嵌入使用，那么推荐使用这种方式，Qt中就是这样做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MAINWINDOW_H</span><br><span class="line">#define MAINWINDOW_H</span><br><span class="line"></span><br><span class="line">#include &lt;QMainWindow&gt;</span><br><span class="line"></span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class MainWindow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainWindow : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit MainWindow(QWidget *parent = 0);</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // MAINWINDOW_H</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &quot;ui_mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(new Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现这里有一个神奇的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespace Ui &#123;</span><br><span class="line">class MainWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实这只是另外一个类，和本类并不同名，Ui::MainWindow是qt设计器帮忙生成的类，用来标注UI界面生成的一些代码，为了让代码很好的和我们自己的类统一起来，他们用了这种方式。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（5）——合理使用模板，避免代码冗余" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（5）——合理使用模板，避免代码冗余/" class="article-date">
  	<time datetime="2016-03-28T15:45:02.484Z" itemprop="datePublished">2016-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（5）——合理使用模板，避免代码冗余/">C和C++的面向对象专题（5）——合理使用模板，避免代码冗余</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="五、合理使用模板，避免代码冗余"><a href="#五、合理使用模板，避免代码冗余" class="headerlink" title="五、合理使用模板，避免代码冗余"></a>五、合理使用模板，避免代码冗余</h2><p>下面我们来讨论一下，如何解决模板的不易封装的问题。</p>
<p>我们提供这样一种思路，对于链表一类的通用类型，我们尽量采取强制类型转换的方式，尽量避免模板的滥用。</p>
<p>同样，我们应该避免对结构体的直接存储，尽量使用类似java的指针传递方式来传递对象。</p>
<p>我们首先来写一个单类型的list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ifndef LIST_C_H</span><br><span class="line">#define LIST_C_H</span><br><span class="line"></span><br><span class="line">class list_c_private;</span><br><span class="line">struct list_c_node;</span><br><span class="line"></span><br><span class="line">class list_c &#123;</span><br><span class="line">public:</span><br><span class="line">truelist_c();</span><br><span class="line">true~list_c();</span><br><span class="line"></span><br><span class="line">truevoid insert(void*);</span><br><span class="line">trueint size();</span><br><span class="line">truevoid* get(int);</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">truelist_c_private* priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // LIST_C_H</span><br></pre></td></tr></table></figure>
<p>这里我们使用了上面讲到的封装方式，降低了类间的耦合度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;list_c.h&quot;</span><br><span class="line"></span><br><span class="line">class list_c_private</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">trueint size;</span><br><span class="line">truelist_c_node* head;</span><br><span class="line">&#125;;	</span><br><span class="line"></span><br><span class="line">struct list_c_node</span><br><span class="line">&#123;</span><br><span class="line">truevoid* data;</span><br><span class="line">truelist_c_node* next;</span><br><span class="line"></span><br><span class="line">truelist_c_node() &#123;</span><br><span class="line">truetruedata = next = nullptr;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_c::list_c() &#123;</span><br><span class="line">truepriv = new list_c_private();</span><br><span class="line">truepriv-&gt;head = new list_c_node();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list_c::~list_c() &#123;</span><br><span class="line">truedelete priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void list_c::insert(void* data) &#123;</span><br><span class="line">truelist_c_node* p;</span><br><span class="line">truefor (p = priv-&gt;head; p-&gt;next != nullptr; p = p-&gt;next) &#123;&#125;</span><br><span class="line">truep-&gt;next = new list_c_node();</span><br><span class="line">truep-&gt;next-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int list_c::size() &#123;</span><br><span class="line">truereturn priv-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* list_c::get(int k) &#123;</span><br><span class="line">trueint t; list_c_node* p;</span><br><span class="line">truefor (p = priv-&gt;head-&gt;next, t = 0; p != nullptr &amp;&amp; t != k ; p = p-&gt;next, ++t) &#123;&#125;</span><br><span class="line">truereturn p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的链表，只是作为示例使用，写了插入和获取的两个方法。</p>
<p>而为了通用性支持，我们写一个模板，进行类型的强制转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#ifndef LIST</span><br><span class="line">#define LIST</span><br><span class="line"></span><br><span class="line">#include &quot;list_c.h&quot;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class list &#123;</span><br><span class="line">public:</span><br><span class="line">truelist() &#123; clist = new list_c(); &#125;</span><br><span class="line">true~list() &#123; delete clist; &#125;</span><br><span class="line"></span><br><span class="line">truevoid insert(T data) &#123;</span><br><span class="line">truetrueclist-&gt;insert((void*)data);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">trueint size() &#123; return clist-&gt;size(); &#125;</span><br><span class="line"></span><br><span class="line">trueT get(int k) &#123;</span><br><span class="line">truetruereturn (T)clist-&gt;get(k);</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">truelist_c* clist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // LIST</span><br></pre></td></tr></table></figure>
<p>这样，带来的好处有，首先能够将模板封装操作，其次，能够在封装类中，动态的调整内部实例。<br>对于一个传入的类型，你可以判断一下，是否适合当前的模板，如果不适合，可以在其中动态的报错。</p>
<p>最后是模板的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;list&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">truelist&lt;long&gt; testlist;</span><br><span class="line">truetestlist.insert(10);</span><br><span class="line">truetestlist.insert(20);</span><br><span class="line"></span><br><span class="line">truelong k = testlist.get(1);</span><br><span class="line">trueprintf(&quot;%d\n&quot;, k);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（6）——C++也能反射" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（6）——C++也能反射/" class="article-date">
  	<time datetime="2016-03-28T15:45:02.483Z" itemprop="datePublished">2016-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（6）——C++也能反射/">C和C++的面向对象专题（6）——C++也能反射</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="六、C-也能反射"><a href="#六、C-也能反射" class="headerlink" title="六、C++也能反射"></a>六、C++也能反射</h2><p>今天我们来探讨C++的反射问题，缺乏反射机制一直是C++的大问题，很多系统的设计时，需要根据外部资源文件的定义，动态的调用内部的函数和接口，如果没有反射，将很难将外部的数据，转换为内部的方法。</p>
<p>Java和.net的反射机制很容易实现，由于其动态语言的特性，在编译时就存储了大量的<strong>元数据</strong>，而在动态装载时，也是根据这些元数据载入的模块。由于C++缺乏这些信息，往往并不能很好的动态装载和链接。操作系统为了实现C和C++的动态装载功能，特意设计了动态链接库，将符号表保存在动态库中，运行时重定位代码，然后进行链接操作。而这是操作系统实现的，并不能很好的被用在用户工程中，所以我们有必要自己构建一套<strong>元数据</strong>集合，保存反射所需的内容。</p>
<h3 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h3><p>反射的核心就是根据字符串名字，创建对应的类或者调用对应类的方法，为此，我们使用C++中的map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, meta_class*&gt;</span><br></pre></td></tr></table></figure>
<p>meta_class 是保存一个类中的关键元数据用的类，可以支持反射构造，反射调用函数等功能。</p>
<p>meta_func 是保存一个方法的关键信息类，但由于方法有不定的参数和返回类型，我们使用模板的方式，将一个抽象存储的成员函数指针，转换为我们确定类型的成员函数指针，然后再去调用，达到动态调用的目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename R, typename... Args&gt;</span><br><span class="line">R Call(T* that, Args... args) &#123;</span><br><span class="line">trueR (T::*mp)();</span><br><span class="line">truemp = *((R (T::**)())func_pointer);</span><br><span class="line">truereturn (that-&gt;*mp)(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的代码十分混乱，如果你没学过C的函数指针的话，建议先去补习一下函数指针的定义和用法。</p>
<p>这里涉及到的是成员函数指针的传递，一会儿将会详细讲解如何传递任意一个函数指针。</p>
<h3 id="反射类对象"><a href="#反射类对象" class="headerlink" title="反射类对象"></a>反射类对象</h3><p>首先，我们肯定要为类对象建立meta_class的模型，但每个meta_class，应该都能够构建本类的对象，为了实现这一特点，我们想到了模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class MetaClass : public IMetaClass &#123;</span><br><span class="line">public:</span><br><span class="line">truevirtual void* CreateObject() &#123;</span><br><span class="line">truetruereturn new T();</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了让每个类都能有统一的创建方法，我们将使用IMetaClass接口进行多态调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class IMetaClass &#123;</span><br><span class="line">public:</span><br><span class="line">truevirtual void* CreateObject() = 0;</span><br><span class="line"></span><br><span class="line">truetemplate&lt;typename T&gt;</span><br><span class="line">trueT* Create() &#123;</span><br><span class="line">truetruereturn (T*) CreateObject();</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truevoid AddFunc(const std::string s, MetaFunc* c) &#123; func_map[s] = c; &#125;</span><br><span class="line">trueMetaFunc* GetFunc(const std::string s) &#123;</span><br><span class="line">truetrueif (func_map.find(s) != func_map.end()) return func_map[s];</span><br><span class="line">truetrueelse return NULL;</span><br><span class="line">true&#125;</span><br><span class="line">private:</span><br><span class="line">truestd::map&lt;const std::string, MetaFunc*&gt; func_map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们在接口类中编写了方法和成员函数，我觉得这是C++的优势，不像Java，为了安全性，而取消了这么简单好用的功能。</p>
<p>接口统一实现相同的类对象构建方式，避免了在实现类中反复编写的困难。</p>
<p>这样，我们只要在每个类的定义时，向我们的类注册器注册该MetaClass对象就可以了</p>
<p>但问题是，如何才能在类定义时编写代码呢？我们的C和C++可是只能在函数中调用代码，不能像脚本一样随时随地执行。</p>
<h3 id="利用全局对象的构造函数执行代码"><a href="#利用全局对象的构造函数执行代码" class="headerlink" title="利用全局对象的构造函数执行代码"></a>利用全局对象的构造函数执行代码</h3><p>我们发现，C++有一个很有趣的特性，有些代码是可以在main函数执行前就执行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">truetest() &#123;</span><br><span class="line">truetrueprintf(&quot;%s\n&quot;,&quot;Hello Ctor!&quot;);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test show_message();</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">trueprintf(&quot;Main function run!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，哦？好像不大对，貌似我们的对象并没有启动，这有可能是被编译器优化掉了。。。= =！<br>控制台的显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sxf@sxf-PC:~/data/workspace/C++/OObyCpp/testCppRunCode$ ./main</span><br><span class="line">Main function run!</span><br></pre></td></tr></table></figure></p>
<p>稍加改动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">truetest(const char* msg) &#123;</span><br><span class="line">truetrueprintf(&quot;%s\n&quot;,msg);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test show_message(&quot;Hello Ctor!&quot;);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">trueprintf(&quot;Main function run!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好的，我们发现构造函数运行在了main函数之前，也就是我们的类型定义的构造期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sxf@sxf-PC:~/data/workspace/C++/OObyCpp/testCppRunCode$ ./main</span><br><span class="line">Hello Ctor!</span><br><span class="line">Main function run!</span><br></pre></td></tr></table></figure></p>
<p>具体想详细了解C++的运行环境的细节，推荐看一本英文的开源书：<br>【How to Make a Computer Operating System】<br>这本书讲解如何利用C++开发了一个小型操作系统，而在C++运行时的导入过程中，就介绍了C++全局对象构造函数的运行过程，可以清楚的看出，C++的主函数在汇编层的调用流程是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">truepush ebx</span><br><span class="line">true </span><br><span class="line">static_ctors_loop: 					; 全局构造函数初始化</span><br><span class="line">   mov ebx, start_ctors</span><br><span class="line">   jmp .test</span><br><span class="line">.body:</span><br><span class="line">   call [ebx]</span><br><span class="line">   add ebx,4</span><br><span class="line">.test:</span><br><span class="line">   cmp ebx, end_ctors</span><br><span class="line">   jb .body</span><br><span class="line"> </span><br><span class="line">   call kmain  						; 调用主函数</span><br><span class="line"> </span><br><span class="line">static_dtors_loop:					; 全局对象的析构函数调用</span><br><span class="line">   mov ebx, start_dtors</span><br><span class="line">   jmp .test</span><br><span class="line">.body:</span><br><span class="line">   call [ebx]</span><br><span class="line">   add ebx,4</span><br><span class="line">.test:</span><br><span class="line">   cmp ebx, end_dtors</span><br><span class="line">   jb .body</span><br></pre></td></tr></table></figure>
<p>于是我们可以这样编写一个类，专门用来注册一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class reflector_class &#123;</span><br><span class="line">public:</span><br><span class="line">truereflector_class(const char* name, IMetaClass* meta_class) &#123;</span><br><span class="line">truetrueClassRegister::Add(name, meta_class);</span><br><span class="line">truetrueprintf(&quot;define class: %s\n&quot;, name);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类的对象在构造时，会去调用ClassRegister类中的静态方法，向其中添加类名和类元数据</p>
<h3 id="利用宏定义处理类的注册"><a href="#利用宏定义处理类的注册" class="headerlink" title="利用宏定义处理类的注册"></a>利用宏定义处理类的注册</h3><p>我们希望每个类对象能够方便的找到自己的meta_class，最简单的方式就是将其添加为自己的成员，为何不用继承机制呢？首先继承较为复杂，并且父类也同样可能拥有meta_class, 我们希望每个类型都能方便的找到meta_class，那么可以建一条Reflectible宏，让大家写在class中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef Reflectible</span><br><span class="line">#define Reflectible \</span><br><span class="line">public:\</span><br><span class="line">truestatic IMetaClass* meta_class;\</span><br><span class="line">private:</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>为了避免放置在最上面时，影响下面成员的private的默认定义，所以写成这样。</p>
<p>我们在写一个宏，让用户添加到类的cpp文件中，真正定义该meta_class对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef ReflectClass</span><br><span class="line">#define ReflectClass(class_name) \</span><br><span class="line">trueIMetaClass* class_name :: meta_class = new MetaClass&lt; class_name &gt;(); \</span><br><span class="line">truereflector_class class_name##reflector_class( #class_name , class_name::meta_class)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>这里我们用到了两个宏技巧：</p>
<pre><code>## 表示将两个符号连接在一起，由于词法分析中，宏是按照词的顺序分隔的，如果直接连接，往往会造成符号分析不清。
#something 表示将该内容展开成字符串的形式 =&gt; &quot;something data&quot;，所以我们可以很方便的用这个宏将宏符号转为字符串传入到函数中。
</code></pre><h3 id="反射成员函数"><a href="#反射成员函数" class="headerlink" title="反射成员函数"></a>反射成员函数</h3><p>首先编写一个能调用成员函数的模板类，根据我们的反射原理，将一个函数指针转换为成员函数的指针：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MetaFunc &#123;</span><br><span class="line">public:</span><br><span class="line">trueMetaFunc(void* p) &#123; func_pointer = p; &#125;</span><br><span class="line">truevoid setFuncPointer(void* p) &#123; func_pointer = p; &#125;</span><br><span class="line">truetemplate &lt;typename T, typename R, typename... Args&gt;</span><br><span class="line">trueR Call(T* that, Args... args) &#123;</span><br><span class="line">truetrueR (T::*mp)();</span><br><span class="line">truetruemp = *((R (T::**)())func_pointer);</span><br><span class="line">truetruereturn (that-&gt;*mp)(args...);</span><br><span class="line">true&#125;</span><br><span class="line">private:</span><br><span class="line">truevoid* func_pointer;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我在这里使用了C++11的新特性，可变参数的模板，这样可以更方便的接受目标参数<br>如果我们直接对成员函数取地址，返回的是一个return_type (ClassName::<em>)(args)这样的成员函数指针。<br>注意，成员函数指针不能直接被传递，成员函数指针由于包含了很多其他数据信息，并不能被被强制类型转换成void</em>,一个显而易见的例子是，成员函数指针，往往比较大，最大的指针甚至可以达到20byte。</p>
<p>为了能够传递函数指针，我们可以将成员函数指针赋值给一个该成员函数指针类型的对象，然后再对这个指针对象取地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto p = &amp;test::print;</span><br><span class="line">&amp;p  //这个地址可以被轻松传递</span><br></pre></td></tr></table></figure>
<p>这个地址是一个指针的指针<code>return_type (ClassName::**)(args)</code><br>于是就有了我们前面代码中，强制类型转换的方法</p>
<h3 id="利用C语言的可变参数函数来定义函数"><a href="#利用C语言的可变参数函数来定义函数" class="headerlink" title="利用C语言的可变参数函数来定义函数"></a>利用C语言的可变参数函数来定义函数</h3><p>我们目前要将地址传递过来，但是我们并不知道每个类中有多少个函数，所以我们要使用C语言的宏，对可变参数进行处理。</p>
<p>下面将reflector_class进行一下修改，支持多个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class reflector_class &#123;</span><br><span class="line">public:</span><br><span class="line">truereflector_class(const char* name, IMetaClass* meta_class, ...) &#123;</span><br><span class="line">truetrueClassRegister::Add(name, meta_class);</span><br><span class="line">truetrueprintf(&quot;define class: %s\n&quot;, name);</span><br><span class="line"></span><br><span class="line">truetrueva_list ap;</span><br><span class="line">truetrueva_start(ap, meta_class);  </span><br><span class="line">truetruefor (int arg = va_arg(ap, int); arg != -1; arg = va_arg(ap, int) ) </span><br><span class="line">truetrue&#123;</span><br><span class="line">truetruetruestd::string name(va_arg(ap, const char*));  </span><br><span class="line">truetruetruevoid* p = va_arg(ap, void*);</span><br><span class="line">truetruetrueif (arg == 0) &#123;</span><br><span class="line">truetruetruetrueprintf(&quot;\tdefine func: %s\n&quot;, name.c_str());</span><br><span class="line">truetruetruetrueMetaFunc* f = new MetaFunc(p);</span><br><span class="line">truetruetruetruemeta_class-&gt;AddFunc(name, f);</span><br><span class="line">truetruetrue&#125; else &#123;</span><br><span class="line">truetruetruetrueprintf(&quot;\tdefine prop: %s\n&quot;, name.c_str());</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetrue&#125;  </span><br><span class="line">truetrueva_end(ap);  </span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<pre><code>va_list ap; 可变参数列表

va_start(ap, meta_class);  这里的第二个参数，是当前函数的最后一个固定参数位置

void* p = va_arg(ap, void*); 可以用来获得一个固定类型的参数
</code></pre><p>使用过后释放资源：</p>
<pre><code>va_end(ap);  
</code></pre><p>为了支持函数和属性两种声明，我们定义如下宏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#ifndef DefReflectFunc</span><br><span class="line">#define DefReflectFunc(class_name, func_name) \</span><br><span class="line">trueauto func_name##_function_pointer = &amp;class_name::func_name</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef ReflectClass</span><br><span class="line">#define ReflectClass(class_name) \</span><br><span class="line">trueIMetaClass* class_name :: meta_class = new MetaClass&lt; class_name &gt;(); \</span><br><span class="line">truereflector_class class_name##reflector_class( #class_name , class_name::meta_class ,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef ReflectFunc</span><br><span class="line">#define ReflectFunc(func_name) \</span><br><span class="line">true0, #func_name, _F(func_name##_function_pointer) ,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef ReflectProp</span><br><span class="line">#define ReflectProp(prop_names) \</span><br><span class="line">true1, #prop_names, _F(prop_names) ,</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef _F</span><br><span class="line">#define _F(x) reinterpret_cast&lt;void*&gt;(&amp;x)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef End</span><br><span class="line">#define End -1 )</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>这样我们在cpp中使用这些宏时只需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DefReflectFunc(test2,print2);</span><br><span class="line">ReflectClass(test2)</span><br><span class="line">trueReflectFunc(print2)</span><br><span class="line">End;</span><br></pre></td></tr></table></figure></p>
<h3 id="类的全局注册难题"><a href="#类的全局注册难题" class="headerlink" title="类的全局注册难题"></a>类的全局注册难题</h3><p>好的，关键的部分已经都清楚了，但目前我们还欠缺一个很重要的类，就是类的全局注册器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ClassRegister</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">truestatic std::map&lt;const std::string, IMetaClass*&gt; class_map;</span><br><span class="line">truestatic void Add(const std::string s, IMetaClass* k) &#123;</span><br><span class="line">truetrueclass_map[s] = k;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这个类有一个严重的漏洞，会造成程序崩溃，我们在接下来的章节中，将会介绍这个尴尬的问题的发生原因。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-C和C++的面向对象专题/C和C++的面向对象专题（7）——单例模式解决静态成员对象和全局对象的构造顺序难题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（7）——单例模式解决静态成员对象和全局对象的构造顺序难题/" class="article-date">
  	<time datetime="2016-03-28T15:45:02.482Z" itemprop="datePublished">2016-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/C和C++的面向对象专题/C和C++的面向对象专题（7）——单例模式解决静态成员对象和全局对象的构造顺序难题/">C和C++的面向对象专题（7）——单例模式解决静态成员对象和全局对象的构造顺序难题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本专栏文章列表</strong></p>
<p>一、何为面向对象</p>
<p>二、C语言也能实现面向对象</p>
<p>三、C++中的不优雅特性</p>
<p>四、解决封装，避免接口</p>
<p>五、合理使用模板，避免代码冗余</p>
<p>六、C++也能反射</p>
<p>七、单例模式解决静态成员对象和全局对象的构造顺序难题</p>
<p>八、更为高级的预处理器PHP</p>
<p>九、Gtkmm的最佳实践</p>
<p>本系列文章由 西风逍遥游 原创，转载请注明出处：西风广场 <a href="http://sunxfancy.github.io/">http://sunxfancy.github.io/</a></p>
<h2 id="七、单例模式解决静态成员对象和全局对象的构造顺序难题"><a href="#七、单例模式解决静态成员对象和全局对象的构造顺序难题" class="headerlink" title="七、单例模式解决静态成员对象和全局对象的构造顺序难题"></a>七、单例模式解决静态成员对象和全局对象的构造顺序难题</h2><p>上回书说道，我们的程序有一个隐藏的漏洞，如果ClassRegister这个类所在的.o文件，如果在所有.o文件中是第一个被链接的的，那么就不会出问题。<br>这么说太抽象了，让我们画个图表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassRegister.o</span><br><span class="line">--------------------</span><br><span class="line">Meta.o</span><br><span class="line">--------------------</span><br><span class="line">Main.o</span><br></pre></td></tr></table></figure>
<p>这样的结构，也就是链接顺序要这样指定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main ClassRegister.o Meta.o Main.o</span><br></pre></td></tr></table></figure></p>
<p>就不会出问题，但如果调换一下顺序就可能出问题。</p>
<p>思考一下原因，ClassRegister中的map对象，是一个全局对象，而我们注册类的时候，也使用了全局对象的构造函数，两个谁先执行呢？这个就不得而知了，C++并未说明两个谁先谁后，而一般链接器，都是从前往后链接代码，而构造函数的执行顺序，也往往和链接时的顺序有关。</p>
<p>但这样实现就很不好，我们的系统居然要靠链接器的顺序才能正确编译执行，太不可靠了，万一用户没注意到这一点，直接编译链接，就会出现未知的错误。</p>
<p>那么如何避免这种情况呢？</p>
<h3 id="C-的单例模式"><a href="#C-的单例模式" class="headerlink" title="C++的单例模式"></a>C++的单例模式</h3><p>C++中有一种极好的设计模式很适合这种情况，那就是用单例，单例模式也很容易理解，核心就是推迟构造，如果没有使用时，就不会被构造，被用到时，对象就会构造，并且仅一次，最常见的写法就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CSingleton  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    CSingleton()   //构造函数是私有的  </span><br><span class="line">    &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    static CSingleton *m_pInstance;  </span><br><span class="line">public:  </span><br><span class="line">    static CSingleton * GetInstance()  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(m_pInstance == NULL)  //判断是否第一次调用  </span><br><span class="line">            m_pInstance = new CSingleton();  </span><br><span class="line">        return m_pInstance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然，我们这里并没有考虑多线程，因为多线程时单例模式一般要加锁来保障不会多次构造引发冲突。</p>
<p>于是经过简要修改，就能用单例模式设计一个类注册器了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ClassRegister</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">trueClassRegister() &#123; printf(&quot;register\n&quot;); &#125;  //构造函数是私有的   </span><br><span class="line">truestd::map&lt;const std::string, IMetaClass*&gt; class_map;</span><br><span class="line">public:</span><br><span class="line">truestatic ClassRegister * GetInstance() &#123;  </span><br><span class="line">truetruestatic ClassRegister instance;   //局部静态变量  </span><br><span class="line">truetruereturn &amp;instance;</span><br><span class="line">true&#125;</span><br><span class="line">truestatic void Add(const std::string s, IMetaClass* k) &#123;</span><br><span class="line">truetrueGetInstance()-&gt;class_map[s] = k;</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">truestatic IMetaClass* Get(const std::string s) &#123;</span><br><span class="line">truetruestd::map&lt;const std::string, IMetaClass*&gt;&amp; m =  GetInstance()-&gt;class_map;</span><br><span class="line">truetrueif (m.find(s) != m.end()) return m[s];</span><br><span class="line">truetrueelse return NULL;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个类注册器简单实用，采用的设计方式和指针的模式稍有不同，这里用到了局部静态变量的概念。<br>局部静态变量能够改变对象的生存周期，这样就能很好的符合我们的要求。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-编译器架构的王者——LLVM/编译器架构的王者LLVM——（10）变量的存储与读取" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/28/编译器架构的王者——LLVM/编译器架构的王者LLVM——（10）变量的存储与读取/" class="article-date">
  	<time datetime="2016-03-28T15:45:02.479Z" itemprop="datePublished">2016-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/28/编译器架构的王者——LLVM/编译器架构的王者LLVM——（10）变量的存储与读取/">编译器架构的王者LLVM——（10）变量的存储与读取</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>LLVM平台，短短几年间，改变了众多编程语言的走向，也催生了一大批具有特色的编程语言的出现，不愧为编译器架构的王者，也荣获2012年ACM软件系统奖 —— 题记</p>
<p>版权声明：本文为 西风逍遥游 原创文章，转载请注明出处 西风世界 <a href="http://blog.csdn.net/xfxyy_sxfancy" target="_blank" rel="external">http://blog.csdn.net/xfxyy_sxfancy</a></p>
<h1 id="变量的存储与读取"><a href="#变量的存储与读取" class="headerlink" title="变量的存储与读取"></a>变量的存储与读取</h1><p>变量是一款编程语言中的核心，说编译语言是一种符号处理工具，其实是有些道理的。栈式符号表可以方便的记录编译过程中的变量和语法符号，我们上节已经了解了其中的实现方法。那么，还有没有其他的办法能够简单的实现变量的存取呢？</p>
<h2 id="LLVM的内置符号表"><a href="#LLVM的内置符号表" class="headerlink" title="LLVM的内置符号表"></a>LLVM的内置符号表</h2><p>其实LLVM还提供了一个内部符号表，这个和我们的符号表不一样，它的符号是以函数为界的，函数内的是局部符号，外面的是全局符号。这个符号表的作用，主要是供LLVM找到各个底层的语法元素而设计的，所以它的功能较为有限。</p>
<p>例如下面这段字节码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define void @print(i64 %k1) &#123;</span><br><span class="line">entry:</span><br><span class="line">true...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过符号表，找到k1这个元素。</p>
<p>这个符号表的获取也很简单，只要你有basicblock，你就能够找到这个符号表的指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BasicBlock* bb = context-&gt;getNowBlock();</span><br><span class="line">   ValueSymbolTable* st = bb-&gt;getValueSymbolTable();</span><br><span class="line">   Value* v = st-&gt;lookup(value);</span><br></pre></td></tr></table></figure>
<h2 id="栈上变量空间的分配，AllocaInst语句"><a href="#栈上变量空间的分配，AllocaInst语句" class="headerlink" title="栈上变量空间的分配，AllocaInst语句"></a>栈上变量空间的分配，AllocaInst语句</h2><p>AllocaInst是LLVM的一条标准语句，负责栈上空间的分配，你无需考虑栈的增长的操作，它会自动帮你完成，并返回给你对应空间的指针。</p>
<p>千万不要认为这个语句能够动态分配堆内存，堆内存实际上是通过调用Malloc语句来分配的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%k = alloca i64</span><br></pre></td></tr></table></figure>
<p>以上语句，会让k的类型变为你分配类型的指针。</p>
<p>这个语句的C++接口非常的好用，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllocaInst *alloc = new AllocaInst(t, var_name, context-&gt;getNowBlock());</span><br></pre></td></tr></table></figure></p>
<p>t对应分配的类型，var_name对应语句返回的那个变量名（上面的‘k’），最后一个参数当然是插入的basicblock。</p>
<p>这时，返回的语句，就代表k这个指针了。</p>
<h2 id="变量的存储"><a href="#变量的存储" class="headerlink" title="变量的存储"></a>变量的存储</h2><p>LLVM中，变量的存储，都需要知道要存储地址的指针，注意，一定是指针，而不是值。</p>
<p>原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StoreInst (Value *Val, Value *Ptr, bool isVolatile, BasicBlock *InsertAtEnd)</span><br></pre></td></tr></table></figure></p>
<p>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new StoreInst(value2, value1, false, context-&gt;getNowBlock());</span><br></pre></td></tr></table></figure></p>
<p>这个value1，就是目标的存储指针，而value2则是要放入的值。false表示不是易变的，这个参数相当与C语言中的volatile关键字，主要是防止这个变量在重复读取时的编译器优化。因为一般的编译器优化，都会将一个变量在没有改变情况下的多次读取，认为取到同一个值，虽然这在多线程和硬中断的环境下并不成立。</p>
<h2 id="变量的读取"><a href="#变量的读取" class="headerlink" title="变量的读取"></a>变量的读取</h2><p>变量的读取，就用Load语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadInst (Value *Ptr, const Twine &amp;NameStr, bool isVolatile, unsigned Align, BasicBlock *InsertAtEnd)</span><br></pre></td></tr></table></figure></p>
<p>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new LoadInst(v, &quot;&quot;, false, bb);</span><br></pre></td></tr></table></figure></p>
<p>我们这里暂时没有考虑内存对齐的问题，当然，一般在Clang中，都是4字节对齐的。我们注意到，其实Load语句也是从指针中取值的，返回的则是一个值类型。</p>
<h2 id="打造一个赋值语句"><a href="#打造一个赋值语句" class="headerlink" title="打造一个赋值语句"></a>打造一个赋值语句</h2><p>赋值语句其实是一个挺尴尬的语句，左边要赋值的，应该是一个指针地址，而右边的部分，则应该是一个获取到的值。而之前我们的运算，函数调用等等，绝大部分都是依赖值类型的。</p>
<p>我们先要为变量实现一个值的获取，这部分因为很通用，我们放到IDNode节点的代码生成中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Value* IDNode::codeGen(CodeGenContext* context) &#123;</span><br><span class="line">    BasicBlock* bb = context-&gt;getNowBlock();</span><br><span class="line">    ValueSymbolTable* st = bb-&gt;getValueSymbolTable();</span><br><span class="line">    Value* v = st-&gt;lookup(value);</span><br><span class="line">    if (v == NULL || v-&gt;hasName() == false) &#123;</span><br><span class="line">        errs() &lt;&lt; &quot;undeclared variable &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    Value* load = new LoadInst(v, &quot;&quot;, false, bb);</span><br><span class="line">    return load;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>value是我们类的成员变量，记录的是变量名。</p>
<p>然而赋值语句有时还会要求获取到的是指针，不是值，现在我们要为赋值语句实现一个符号指针的获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Value* IDNode::codeGen(CodeGenContext* context) &#123;</span><br><span class="line">    BasicBlock* bb = context-&gt;getNowBlock();</span><br><span class="line">    ValueSymbolTable* st = bb-&gt;getValueSymbolTable();</span><br><span class="line">    Value* v = st-&gt;lookup(value);</span><br><span class="line">    if (v == NULL || v-&gt;hasName() == false) &#123;</span><br><span class="line">        errs() &lt;&lt; &quot;undeclared variable &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    if (context-&gt;isSave()) return v; // 我们在上下文类中记录了一个变量，看当前状态是存还是取</span><br><span class="line">    Value* load = new LoadInst(v, &quot;&quot;, false, bb);</span><br><span class="line">    return load;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么我们在调用时，只需要这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static Value* opt2_macro(CodeGenContext* context, Node* node) &#123;</span><br><span class="line">truestd::string opt = node-&gt;getStr();</span><br><span class="line"></span><br><span class="line">trueNode* op1 = (node = node-&gt;getNext());</span><br><span class="line">trueif (node == NULL) return NULL;</span><br><span class="line">trueNode* op2 = (node = node-&gt;getNext());</span><br><span class="line">trueif (node == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">trueif (opt == &quot;=&quot;) &#123;</span><br><span class="line">truetruecontext-&gt;setIsSave(true); // 这两句设置的目前是为下面的节点解析时,返回指针而不是load后的值</span><br><span class="line">truetrueValue* ans1 = op1-&gt;codeGen(context);</span><br><span class="line">truetruecontext-&gt;setIsSave(false);</span><br><span class="line">truetrueValue* ans2 = op2-&gt;codeGen(context);</span><br><span class="line">truetruereturn new StoreInst(ans2, ans1, false, context-&gt;getNowBlock());</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们这里也可以单独实现一个函数来处理这个功能，但由于两个函数功能太像，所以也不怎么想添加一个类似的函数了。<br>这个部分暂时先这样处理一下，待整体结构完善后，应该有更好的实现方法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 西风逍遥游
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>